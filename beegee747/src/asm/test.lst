PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000 C3 45 00 04 0003       jp start
040004 FF FF FF FF 0004       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005       db "MOS"
040043 00          0006       db 00h
040044 01          0007       db 01h
040045             0008   
040045             0009   start:
040045 F5          0010       push af
040046 C5          0011       push bc
040047 D5          0012       push de
040048 DD E5       0013       push ix
04004A FD E5       0014       push iy
04004C CD 46 43 04 0015       call init
040050 CD 47 43 04 0016       call main
040054             0017   
040054             0018   exit:
040054 FD E1       0019       pop iy
040056 DD E1       0020       pop ix
040058 D1          0021       pop de
040059 C1          0022       pop bc
04005A F1          0023       pop af
04005B 21 00 00 00 0024       ld hl,0
04005F             0025   
04005F C9          0026       ret
040060             0027   
040060             0028   ; API INCLUDES
040060             0029       include "mos_api.inc"
040060             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*  ; Title:	AGON MOS - API for user projects
040060             0003*  ; Author:	Dean Belfield
040060             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*  ;			Added MOS error codes for return in HL
040060             0006*  ; Created:	03/08/2022
040060             0007*  ; Last Updated:	10/08/2023
040060             0008*  ;
040060             0009*  ; Modinfo:
040060             0010*  ; 05/08/2022:	Added mos_feof
040060             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*  ; 13/10/2022:	Added mos_oscli
040060             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*  ; 19/05/2023:	Added sysvar_scrMode
040060             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*  ; 03/08/2023:	Added mos_setkbvector
040060             0028*  ; 10/08/2023:	Added mos_getkbmap
040060             0029*  
040060             0030*  ; VDP control (VDU 23, 0, n)
040060             0031*  ;
040060             0032*  vdp_gp:				EQU 80h
040060             0033*  vdp_keycode:		EQU 81h
040060             0034*  vdp_cursor:			EQU	82h
040060             0035*  vdp_scrchar:		EQU	83h
040060             0036*  vdp_scrpixel:		EQU	84h
040060             0037*  vdp_audio:			EQU	85h
040060             0038*  vdp_mode:			EQU	86h
040060             0039*  vdp_rtc:			EQU	87h
040060             0040*  vdp_keystate:		EQU	88h
040060             0041*  vdp_logicalcoords:	EQU	C0h
040060             0042*  vdp_terminalmode:	EQU	FFh
040060             0043*  
040060             0044*  ; MOS high level functions
040060             0045*  ;
040060             0046*  mos_getkey:			EQU	00h
040060             0047*  mos_load:			EQU	01h
040060             0048*  mos_save:			EQU	02h
040060             0049*  mos_cd:				EQU	03h
040060             0050*  mos_dir:			EQU	04h
040060             0051*  mos_del:			EQU	05h
040060             0052*  mos_ren:			EQU	06h
040060             0053*  mos_mkdir:			EQU	07h
040060             0054*  mos_sysvars:		EQU	08h
040060             0055*  mos_editline:		EQU	09h
040060             0056*  mos_fopen:			EQU	0Ah
040060             0057*  mos_fclose:			EQU	0Bh
040060             0058*  mos_fgetc:			EQU	0Ch
040060             0059*  mos_fputc:			EQU	0Dh
040060             0060*  mos_feof:			EQU	0Eh
040060             0061*  mos_getError:		EQU	0Fh
040060             0062*  mos_oscli:			EQU	10h
040060             0063*  mos_copy:			EQU	11h
040060             0064*  mos_getrtc:			EQU	12h
040060             0065*  mos_setrtc:			EQU	13h
040060             0066*  mos_setintvector:	EQU	14h
040060             0067*  mos_uopen:			EQU	15h
040060             0068*  mos_uclose:			EQU	16h
040060             0069*  mos_ugetc:			EQU	17h
040060             0070*  mos_uputc:			EQU	18h
040060             0071*  mos_getfil:			EQU	19h
040060             0072*  mos_fread:			EQU	1Ah
040060             0073*  mos_fwrite:			EQU	1Bh
040060             0074*  mos_flseek:			EQU	1Ch
040060             0075*  mos_setkbvector:	EQU	1Dh
040060             0076*  mos_getkbmap:		EQU	1Eh
040060             0077*  
040060             0078*  ; MOS program exit codes
040060             0079*  ;
040060             0080*  EXIT_OK:				EQU  0;	"OK",
040060             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*  ; FatFS file access functions
040060             0103*  ;
040060             0104*  ffs_fopen:			EQU	80h
040060             0105*  ffs_fclose:			EQU	81h
040060             0106*  ffs_fread:			EQU	82h
040060             0107*  ffs_fwrite:			EQU	83h
040060             0108*  ffs_flseek:			EQU	84h
040060             0109*  ffs_ftruncate:		EQU	85h
040060             0110*  ffs_fsync:			EQU	86h
040060             0111*  ffs_fforward:		EQU	87h
040060             0112*  ffs_fexpand:		EQU	88h
040060             0113*  ffs_fgets:			EQU	89h
040060             0114*  ffs_fputc:			EQU	8Ah
040060             0115*  ffs_fputs:			EQU	8Bh
040060             0116*  ffs_fprintf:		EQU	8Ch
040060             0117*  ffs_ftell:			EQU	8Dh
040060             0118*  ffs_feof:			EQU	8Eh
040060             0119*  ffs_fsize:			EQU	8Fh
040060             0120*  ffs_ferror:			EQU	90h
040060             0121*  
040060             0122*  ; FatFS directory access functions
040060             0123*  ;
040060             0124*  ffs_dopen:			EQU	91h
040060             0125*  ffs_dclose:			EQU	92h
040060             0126*  ffs_dread:			EQU	93h
040060             0127*  ffs_dfindfirst:		EQU	94h
040060             0128*  ffs_dfindnext:		EQU	95h
040060             0129*  
040060             0130*  ; FatFS file and directory management functions
040060             0131*  ;
040060             0132*  ffs_stat:			EQU	96h
040060             0133*  ffs_unlink:			EQU	97h
040060             0134*  ffs_rename:			EQU	98h
040060             0135*  ffs_chmod:			EQU	99h
040060             0136*  ffs_utime:			EQU	9Ah
040060             0137*  ffs_mkdir:			EQU	9Bh
040060             0138*  ffs_chdir:			EQU	9Ch
040060             0139*  ffs_chdrive:		EQU	9Dh
040060             0140*  ffs_getcwd:			EQU	9Eh
040060             0141*  
040060             0142*  ; FatFS volume management and system configuration functions
040060             0143*  ;
040060             0144*  ffs_mount:			EQU	9Fh
040060             0145*  ffs_mkfs:			EQU	A0h
040060             0146*  ffs_fdisk:			EQU	A1h
040060             0147*  ffs_getfree:		EQU	A2h
040060             0148*  ffs_getlabel:		EQU	A3h
040060             0149*  ffs_setlabel:		EQU	A4h
040060             0150*  ffs_setcp:			EQU	A5h
040060             0151*  
040060             0152*  ; File access modes
040060             0153*  ;
040060             0154*  fa_read:			EQU	01h
040060             0155*  fa_write:			EQU	02h
040060             0156*  fa_open_existing:	EQU	00h
040060             0157*  fa_create_new:		EQU	04h
040060             0158*  fa_create_always:	EQU	08h
040060             0159*  fa_open_always:		EQU	10h
040060             0160*  fa_open_append:		EQU	30h
040060             0161*  
040060             0162*  ; System variable indexes for api_sysvars
040060             0163*  ; Index into _sysvars in globals.inc
040060             0164*  ;
040060             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*  
040060             0192*  ; Flags for the VPD protocol
040060             0193*  ;
040060             0194*  vdp_pflag_cursor:		EQU	00000001b
040060             0195*  vdp_pflag_scrchar:		EQU	00000010b
040060             0196*  vdp_pflag_point:		EQU	00000100b
040060             0197*  vdp_pflag_audio:		EQU	00001000b
040060             0198*  vdp_pflag_mode:			EQU	00010000b
040060             0199*  vdp_pflag_rtc:			EQU	00100000b
040060             0200*  
040060             0201*  ;
040060             0202*  ; FatFS structures
040060             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*  ;
040060             0205*  ; Object ID and allocation information (FFOBJID)
040060             0206*  ;
040060             0207*  ; Indexes into FFOBJID structure
040060             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*  ;
040060             0215*  ; File object structure (FIL)
040060             0216*  ;
040060             0217*  ; Indexes into FIL structure
040060             0218*  fil_obj:		EQU 0	; 15: Object identifier
040060             0219*  fil_flag:		EQU	15 	;  1: File status flags
040060             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*  ;
040060             0227*  ; Directory object structure (DIR)
040060             0228*  ; Indexes into DIR structure
040060             0229*  dir_obj:		EQU  0	; 15: Object identifier
040060             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*  dir_clust:		EQU	19	;  4: Current cluster
040060             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*  ;
040060             0237*  ; File information structure (FILINFO)
040060             0238*  ;
040060             0239*  ; Indexes into FILINFO structure
040060             0240*  filinfo_fsize:		EQU 0	;   4: File size
040060             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*  ;
040060             0247*  ; Macro for calling the API
040060             0248*  ; Parameters:
040060             0249*  ; - function: One of the function numbers listed above
040060             0250*  ;
040060             0251*  	MACRO	MOSCALL	function
040060             0252*  			LD	A, function
040060             0253*  			RST.LIL	08h
040060             0254*  	ENDMACRO
040060             0030       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*      LD A, char
040060             0004*      RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*      ld bc,@F ; Address of first instruction after the jump
040060             0013*      push bc ; which constitutes the return address
040060             0014*      jp (hl) ; Jump to the address in HL
040060             0015*  @@:
040060             0016*      ENDMACRO
040060             0017*  
040060             0018*  ; Simulated call to subroutine at IX
040060             0019*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0020*  ; outputs: whatever the subroutine does, including IX and BC
040060             0021*  ; destroys: only what the subroutine does, but always BC
040060             0022*      MACRO callIX
040060             0023*      ld bc,@F ; Address of first instruction after the jump
040060             0024*      push bc ; which constitutes the return address
040060             0025*      jp (ix) ; Jump to the address in IX
040060             0026*  @@:
040060             0027*      ENDMACRO
040060             0028*  
040060             0029*  ; Simulated call to soubroutinte at IY
040060             0030*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0031*  ; outputs: whatever the subroutine does, including IY and BC
040060             0032*  ; destroys: only what the subroutine does, but always BC
040060             0033*      MACRO callIY
040060             0034*      ld bc,@F ; Address of first instruction after the jump
040060             0035*      push bc ; which constitutes the return address
040060             0036*      jp (iy) ; Jump to the address in IY
040060             0037*  @@:
040060             0038*      ENDMACRO
040060             0039*  
040060             0040*  ; put the value in HLU into the accumulator
040060             0041*  ; destroys: af
040060             0042*      MACRO HLU_TO_A
040060             0043*      push hl ; 4 cycles
040060             0044*      inc sp ; 1 cycle
040060             0045*      pop af ; 4 cycles
040060             0046*      dec sp ; 1 cycle
040060             0047*      ; 10 cycles total
040060             0048*      ENDMACRO
040060             0049*  
040060             0050*  A_TO_HLU:
040060             0051*      ; call is 7 cycles
040060 22 6D 00 04 0052*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0053*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0054*      ld hl,(@scratch) ; 7 cycles
04006C C9          0055*      ret ; 6 cycles
04006D             0056*      ; 25 cycles total
04006D 00 00 00    0057*  @scratch: dl 0
040070             0058*  
040070             0059*      ; TODO: implement this
040070             0060*      ; MACRO A_TO_HLU
040070             0061*      ;     push.s af
040070             0062*      ;     inc sp
040070             0063*      ;     push.s hl
040070             0064*      ;     pop hl
040070             0065*      ;     inc sp
040070             0066*      ;     inc sp
040070             0067*      ; ENDMACRO
040070             0068*  
040070             0069*      MACRO PUSH_ALL
040070             0070*      ex af,af'
040070             0071*      exx
040070             0072*      push af
040070             0073*      push hl
040070             0074*      push bc
040070             0075*      push de
040070             0076*  
040070             0077*      ex af,af'
040070             0078*      exx
040070             0079*      push af
040070             0080*      push hl
040070             0081*      push bc
040070             0082*      push de
040070             0083*      push ix
040070             0084*      push iy
040070             0085*      ENDMACRO
040070             0086*  
040070             0087*      MACRO POP_ALL
040070             0088*      pop iy
040070             0089*      pop ix
040070             0090*      pop de
040070             0091*      pop bc
040070             0092*      pop hl
040070             0093*      pop af
040070             0094*      ex af,af'
040070             0095*      exx
040070             0096*  
040070             0097*      pop de
040070             0098*      pop bc
040070             0099*      pop hl
040070             0100*      pop af
040070             0101*      ex af,af'
040070             0102*      exx
040070             0103*      ENDMACRO
040070             0104*  
040070             0105*  ; Print a zero-terminated string inline with code, e.g.:
040070             0106*  ;
040070             0107*  ;    call printInline
040070             0108*  ;    ASCIZ "Hello, world!\r\n"
040070             0109*  ;
040070             0110*  ; Destroys: HL,AF
040070             0111*  printInline:
040070 E1          0112*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0113*      call printString ; HL advances to end of string
040075 E5          0114*      push hl ; restore the return address = pointer to end of string
040076 C9          0115*      ret
040077             0116*  
040077             0117*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0118*  ; Print a zero-terminated string
040077             0119*  ; HL: Pointer to string
040077             0120*  printString:
040077 C5          0121*      PUSH BC
040078 01 00 00 00 0122*      LD BC,0
04007C 3E 00       0123*      LD A,0
04007E 5B DF       0124*      RST.LIL 18h
040080 C1          0125*      POP BC
040081 C9          0126*      RET
040082             0127*  ; print a VDU sequence
040082             0128*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0129*  sendVDUsequence:
040082 C5          0130*      PUSH BC
040083 01 00 00 00 0131*      LD BC, 0
040087 4E          0132*      LD C, (HL)
040088 5B DF       0133*      RST.LIL 18h
04008A C1          0134*      POP BC
04008B C9          0135*      RET
04008C             0136*  ; Print Newline sequence to VDP
04008C             0137*  printNewLine:
04008C F5          0138*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0139*      LD A, '\r'
04008F 5B D7       0140*      RST.LIL 10h
040091 3E 0A       0141*      LD A, '\n'
040093 5B D7       0142*      RST.LIL 10h
040095 F1          0143*      pop af
040096 C9          0144*      RET
040097             0145*  
040097             0146*  ; Print a 24-bit HEX number
040097             0147*  ; HLU: Number to print
040097             0148*  printHex24:
040097             0149*      HLU_TO_A
040097 E5          0001*M     push hl ; 4 cycles
040098 33          0002*M     inc sp ; 1 cycle
040099 F1          0003*M     pop af ; 4 cycles
04009A 3B          0004*M     dec sp ; 1 cycle
04009B             0005*M     ; 10 cycles total
04009B CD A5 00 04 0150*      CALL printHex8
04009F             0151*  ; Print a 16-bit HEX number
04009F             0152*  ; HL: Number to print
04009F             0153*  printHex16:
04009F 7C          0154*      LD A,H
0400A0 CD A5 00 04 0155*      CALL printHex8
0400A4 7D          0156*      LD A,L
0400A5             0157*  ; Print an 8-bit HEX number
0400A5             0158*  ; A: Number to print
0400A5             0159*  printHex8:
0400A5 4F          0160*      LD C,A
0400A6 1F          0161*      RRA
0400A7 1F          0162*      RRA
0400A8 1F          0163*      RRA
0400A9 1F          0164*      RRA
0400AA CD AF 00 04 0165*      CALL @F
0400AE 79          0166*      LD A,C
0400AF             0167*  @@:
0400AF E6 0F       0168*      AND 0Fh
0400B1 C6 90       0169*      ADD A,90h
0400B3 27          0170*      DAA
0400B4 CE 40       0171*      ADC A,40h
0400B6 27          0172*      DAA
0400B7 5B D7       0173*      RST.LIL 10h
0400B9 C9          0174*      RET
0400BA             0175*  
0400BA             0176*  printHexA:
0400BA F5          0177*      push af
0400BB C5          0178*      push bc
0400BC CD A5 00 04 0179*      call printHex8
0400C0 3E 20       0180*      ld a,' '
0400C2 5B D7       0181*      rst.lil 10h
0400C4 C1          0182*      pop bc
0400C5 F1          0183*      pop af
0400C6 C9          0184*      ret
0400C7             0185*  
0400C7             0186*  printHexHL:
0400C7 F5          0187*      push af
0400C8 C5          0188*      push bc
0400C9 CD 9F 00 04 0189*      call printHex16
0400CD 3E 20       0190*      ld a,' '
0400CF 5B D7       0191*      rst.lil 10h
0400D1 C1          0192*      pop bc
0400D2 F1          0193*      pop af
0400D3 C9          0194*      ret
0400D4             0195*  
0400D4             0196*  printHexUHL:
0400D4 F5          0197*      push af
0400D5 C5          0198*      push bc
0400D6 CD 97 00 04 0199*      call printHex24
0400DA 3E 20       0200*      ld a,' '
0400DC 5B D7       0201*      rst.lil 10h
0400DE C1          0202*      pop bc
0400DF F1          0203*      pop af
0400E0 C9          0204*      ret
0400E1             0205*  
0400E1             0206*  printHexAUHL:
0400E1 F5          0207*      push af
0400E2 C5          0208*      push bc
0400E3 CD A5 00 04 0209*      call printHex8
0400E7 3E 2E       0210*      ld a,'.'
0400E9 5B D7       0211*      rst.lil 10h
0400EB CD 97 00 04 0212*      call printHex24
0400EF 3E 20       0213*      ld a,' '
0400F1 5B D7       0214*      rst.lil 10h
0400F3 C1          0215*      pop bc
0400F4 F1          0216*      pop af
0400F5 C9          0217*      ret
0400F6             0218*  
0400F6             0219*  printHexABHL:
0400F6             0220*  ; preserve registers
0400F6 C5          0221*      push bc ; b will be ok c will not
0400F7 F5          0222*      push af ; will get totally destroyed
0400F8             0223*  ; print a
0400F8 CD A5 00 04 0224*      call printHex8
0400FC             0225*  ; print b
0400FC 78          0226*      ld a,b
0400FD CD A5 00 04 0227*      call printHex8
040101             0228*  ; print hl
040101 CD 9F 00 04 0229*      call printHex16
040105             0230*  ; restore registers
040105 F1          0231*      pop af
040106 C1          0232*      pop bc
040107 C9          0233*      ret
040108             0234*  
040108             0235*  printHexBHL:
040108             0236*  ; preserve registers
040108 C5          0237*      push bc ; b will be ok c will not
040109 F5          0238*      push af ; will get totally destroyed
04010A             0239*  ; print b
04010A 78          0240*      ld a,b
04010B CD A5 00 04 0241*      call printHex8
04010F             0242*  ; print hl
04010F CD 9F 00 04 0243*      call printHex16
040113             0244*  ; restore registers
040113 F1          0245*      pop af
040114 C1          0246*      pop bc
040115 C9          0247*      ret
040116             0248*  
040116             0249*  printHexCDE:
040116             0250*  ; preserve registers
040116 C5          0251*      push bc ; b will be ok c will not
040117 F5          0252*      push af ; will get totally destroyed
040118             0253*  ; print c
040118 79          0254*      ld a,c
040119 CD A5 00 04 0255*      call printHex8
04011D             0256*  ; print de
04011D EB          0257*      ex de,hl
04011E CD 9F 00 04 0258*      call printHex16
040122 EB          0259*      ex de,hl
040123             0260*  ; restore registers
040123 F1          0261*      pop af
040124 C1          0262*      pop bc
040125 C9          0263*      ret
040126             0264*  
040126             0265*  printHexUIX:
040126             0266*  ; store everything in scratch
040126 22 9F 05 04 0267*      ld (uhl),hl
04012A ED 43 A2 05 0268*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0269*      ld (ude),de
       04          
040134 DD 22 A8 05 0270*      ld (uix),ix
       04          
040139 FD 22 AB 05 0271*      ld (uiy),iy
       04          
04013E F5          0272*      push af ; fml
04013F             0273*  
04013F 21 36 05 04 0274*      ld hl,str_ixu
040143 CD 77 00 04 0275*      call printString
040147 2A A8 05 04 0276*      ld hl,(uix)
04014B CD 97 00 04 0277*      call printHex24
04014F CD 8C 00 04 0278*      call printNewLine
040153             0279*  
040153             0280*  ; restore everything
040153 2A 9F 05 04 0281*      ld hl, (uhl)
040157 ED 4B A2 05 0282*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0283*      ld de, (ude)
       04          
040161 DD 2A A8 05 0284*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0285*      ld iy, (uiy)
       04          
04016B F1          0286*      pop af
04016C             0287*  ; all done
04016C C9          0288*      ret
04016D             0289*  
04016D             0290*  ; Print a 0x HEX prefix
04016D             0291*  DisplayHexPrefix:
04016D 3E 30       0292*      LD A, '0'
04016F 5B D7       0293*      RST.LIL 10h
040171 3E 78       0294*      LD A, 'x'
040173 5B D7       0295*      RST.LIL 10h
040175 C9          0296*      RET
040176             0297*  
040176             0298*      MACRO printDecBC
040176             0299*      push hl
040176             0300*      push bc
040176             0301*      pop hl
040176             0302*      call printDec
040176             0303*      pop hl
040176             0304*      ENDMACRO
040176             0305*  
040176             0306*      MACRO printDecDE
040176             0307*      push hl
040176             0308*      push de
040176             0309*      pop hl
040176             0310*      call printDec
040176             0311*      pop hl
040176             0312*      ENDMACRO
040176             0313*  
040176             0314*      MACRO printDecHL
040176             0315*      call printDec
040176             0316*      ENDMACRO
040176             0317*  
040176             0318*      MACRO printDecIX
040176             0319*      push hl
040176             0320*      push ix
040176             0321*      pop hl
040176             0322*      call printDec
040176             0323*      pop hl
040176             0324*      ENDMACRO
040176             0325*  
040176             0326*      MACRO printDecIY
040176             0327*      push hl
040176             0328*      push iy
040176             0329*      pop hl
040176             0330*      call printDec
040176             0331*      pop hl
040176             0332*      ENDMACRO
040176             0333*  
040176             0334*  
040176             0335*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0336*  ; HL : Value to print
040176             0337*  ; preserves all registers and flags
040176             0338*  printDec:
040176             0339*  ; BEGIN MY CODE
040176             0340*  ; back up all the things
040176 F5          0341*      push af
040177 C5          0342*      push bc
040178 D5          0343*      push de
040179 E5          0344*      push hl
04017A             0345*  ; END MY CODE
04017A 11 A2 01 04 0346*      LD DE, _printDecBuffer
04017E CD B2 01 04 0347*      CALL u24_to_ascii
040182             0348*  ; BEGIN MY CODE
040182             0349*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0350*      LD HL, _printDecBuffer
040186 06 07       0351*      ld B, 7 ; if HL was 0, we want to keep the final zero
040188             0352*  @loop:
040188 7E          0353*      LD A, (HL)
040189 FE 30       0354*      CP '0'
04018B C2 95 01 04 0355*      JP NZ, @done
04018F 3E 20       0356*      LD A, ' '
040191 77          0357*      LD (HL), A
040192 23          0358*      INC HL
040193             0359*      ; CALL vdu_cursor_forward
040193 10 F3       0360*      DJNZ @loop
040195             0361*  @done:
040195             0362*  ; END MY CODE
040195 21 A2 01 04 0363*      LD HL, _printDecBuffer
040199 CD 77 00 04 0364*      CALL printString
04019D             0365*  ; BEGIN MY CODE
04019D             0366*  ; restore all the things
04019D E1          0367*      pop hl
04019E D1          0368*      pop de
04019F C1          0369*      pop bc
0401A0 F1          0370*      pop af
0401A1             0371*  ; END MY CODE
0401A1 C9          0372*      RET
0401A2 00 00 00 00 0373*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0374*  
0401B2             0375*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0376*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0377*  ; so it will allways be 8 characters length
0401B2             0378*  ; HL : Value to convert to string
0401B2             0379*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0380*  u24_to_ascii:
0401B2 01 80 69 67 0381*      LD BC,-10000000
0401B6 CD E9 01 04 0382*      CALL @one_digit
0401BA 01 C0 BD F0 0383*      LD BC,-1000000
0401BE CD E9 01 04 0384*      CALL @one_digit
0401C2 01 60 79 FE 0385*      LD BC,-100000
0401C6 CD E9 01 04 0386*      CALL @one_digit
0401CA 01 F0 D8 FF 0387*      LD BC,-10000
0401CE CD E9 01 04 0388*      CALL @one_digit
0401D2 01 18 FC FF 0389*      LD BC,-1000
0401D6 CD E9 01 04 0390*      CALL @one_digit
0401DA 01 9C FF FF 0391*      LD BC,-100
0401DE CD E9 01 04 0392*      CALL @one_digit
0401E2 0E F6       0393*      LD C,-10
0401E4 CD E9 01 04 0394*      CALL @one_digit
0401E8 48          0395*      LD C,B
0401E9             0396*  @one_digit:
0401E9 3E 2F       0397*      LD A,'0'-1
0401EB             0398*  @divide_me:
0401EB 3C          0399*      INC A
0401EC 09          0400*      ADD HL,BC
0401ED 38 FC       0401*      JR C,@divide_me
0401EF ED 42       0402*      SBC HL,BC
0401F1 12          0403*      LD (DE),A
0401F2 13          0404*      INC DE
0401F3 C9          0405*      RET
0401F4             0406*  
0401F4             0407*  print_u24:
0401F4 D5          0408*      push de
0401F5 E5          0409*      push hl
0401F6 11 A2 01 04 0410*      ld de,_printDecBuffer
0401FA CD B2 01 04 0411*      call u24_to_ascii
0401FE 21 A2 01 04 0412*      ld hl,_printDecBuffer
040202 CD 77 00 04 0413*      call printString
040206 3E 20       0414*      ld a,' '
040208 5B D7       0415*      rst.lil 10h
04020A E1          0416*      pop hl
04020B D1          0417*      pop de
04020C C9          0418*      ret
04020D             0419*  
04020D             0420*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0421*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0422*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0423*  u168_to_ascii:
04020D             0424*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0425*      ld a,' '
04020F 12          0426*      ld (de),a
040210 13          0427*      inc de
040211             0428*  ; Convert integer part
040211 E5          0429*      push hl ; Save HL (weâ€™ll need the fractional part later)
040212 CD E5 07 04 0430*      call hlu_udiv256 ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0431*      ld bc, -10000
04021A CD 3D 02 04 0432*      call @one_int
04021E 01 18 FC FF 0433*      ld bc, -1000
040222 CD 3D 02 04 0434*      call @one_int
040226 01 9C FF FF 0435*      ld bc, -100
04022A CD 3D 02 04 0436*      call @one_int
04022E 0E F6       0437*      ld c, -10
040230 CD 3D 02 04 0438*      call @one_int
040234 48          0439*      ld c, b
040235 CD 3D 02 04 0440*      call @one_int
040239 C3 48 02 04 0441*      jp @frac ; Jump to fractional part conversion
04023D             0442*  @one_int:
04023D 3E 2F       0443*      ld a, '0' - 1 ; Start ASCII character at '0'
04023F             0444*  @divide_me:
04023F 3C          0445*      inc a
040240 09          0446*      add hl, bc ; Accumulate until overflow
040241 38 FC       0447*      jr c, @divide_me
040243 ED 42       0448*      sbc hl, bc ; Remove excess after overflow
040245 12          0449*      ld (de), a ; Store ASCII digit
040246 13          0450*      inc de
040247 C9          0451*      ret
040248             0452*  ; Convert fractional part
040248             0453*  @frac:
040248 3E 2E       0454*      ld a, '.' ; Decimal point
04024A 12          0455*      ld (de), a
04024B 13          0456*      inc de
04024C E1          0457*      pop hl ; Restore HL with original fraction
04024D 06 03       0458*      ld b, 3 ; Loop counter for 3 fractional digits
04024F             0459*  @frac_loop:
04024F 26 0A       0460*      ld h, 10 ; Load multiplier for fractional part
040251 ED 6C       0461*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0462*      ld a, '0'
040255 84          0463*      add a, h ; Convert integer part to ASCII
040256 12          0464*      ld (de), a
040257 13          0465*      inc de
040258 10 F5       0466*      djnz @frac_loop ; Repeat for each fractional digit
04025A             0467*  ; Add null terminator
04025A AF          0468*      xor a ; Null terminator
04025B 12          0469*      ld (de), a
04025C C9          0470*      ret
04025D             0471*  
04025D             0472*  print_u168:
04025D D5          0473*      push de
04025E E5          0474*      push hl
04025F 11 A2 01 04 0475*      ld de,_printDecBuffer
040263 CD 0D 02 04 0476*      call u168_to_ascii
040267 21 A2 01 04 0477*      ld hl,_printDecBuffer
04026B CD 77 00 04 0478*      call printString
04026F E1          0479*      pop hl
040270 D1          0480*      pop de
040271 C9          0481*      ret
040272             0482*  
040272             0483*  ; signed version of u168_to_ascii
040272             0484*  s168_to_ascii:
040272 D5          0485*      push de ; save starting address of buffer
040273 CD 7E 07 04 0486*      call hlu_abs
040277 F5          0487*      push af ; save sign flag
040278 CD 0D 02 04 0488*      call u168_to_ascii
04027C F1          0489*      pop af ; restore sign flag
04027D D1          0490*      pop de ; restore starting address of buffer
04027E F0          0491*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0492*      ld a,'-'
040281 12          0493*      ld (de),a
040282 C9          0494*      ret
040283             0495*  
040283             0496*  print_s168:
040283 D5          0497*      push de
040284 E5          0498*      push hl
040285 11 A2 01 04 0499*      ld de,_printDecBuffer
040289 CD 72 02 04 0500*      call s168_to_ascii
04028D 21 A2 01 04 0501*      ld hl,_printDecBuffer
040291 CD 77 00 04 0502*      call printString
040295 E1          0503*      pop hl
040296 D1          0504*      pop de
040297 C9          0505*      ret
040298             0506*  
040298             0507*  print_s168_hl:
040298 F5          0508*      push af
040299 E5          0509*      push hl
04029A CD 83 02 04 0510*      call print_s168
04029E 3E 20       0511*      ld a,' '
0402A0 5B D7       0512*      rst.lil 10h
0402A2 E1          0513*      pop hl
0402A3 F1          0514*      pop af
0402A4 C9          0515*      ret
0402A5             0516*  
0402A5             0517*  print_s168_bc:
0402A5 F5          0518*      push af
0402A6 C5          0519*      push bc
0402A7 E5          0520*      push hl
0402A8 C5          0521*      push bc
0402A9 E1          0522*      pop hl
0402AA CD 83 02 04 0523*      call print_s168
0402AE 3E 20       0524*      ld a,' '
0402B0 5B D7       0525*      rst.lil 10h
0402B2 E1          0526*      pop hl
0402B3 C1          0527*      pop bc
0402B4 F1          0528*      pop af
0402B5 C9          0529*      ret
0402B6             0530*  
0402B6             0531*  print_s168_de:
0402B6 F5          0532*      push af
0402B7 D5          0533*      push de
0402B8 E5          0534*      push hl
0402B9 EB          0535*      ex de,hl
0402BA CD 83 02 04 0536*      call print_s168
0402BE 3E 20       0537*      ld a,' '
0402C0 5B D7       0538*      rst.lil 10h
0402C2 E1          0539*      pop hl
0402C3 D1          0540*      pop de
0402C4 F1          0541*      pop af
0402C5 C9          0542*      ret
0402C6             0543*  
0402C6             0544*  print_s168_hl_bc_de:
0402C6 F5          0545*      push af
0402C7 C5          0546*      push bc
0402C8 D5          0547*      push de
0402C9 E5          0548*      push hl
0402CA CD 83 02 04 0549*      call print_s168
0402CE 3E 20       0550*      ld a,' '
0402D0 5B D7       0551*      rst.lil 10h
0402D2 C5          0552*      push bc
0402D3 E1          0553*      pop hl
0402D4 CD 83 02 04 0554*      call print_s168
0402D8 3E 20       0555*      ld a,' '
0402DA 5B D7       0556*      rst.lil 10h
0402DC EB          0557*      ex de,hl
0402DD CD 83 02 04 0558*      call print_s168
0402E1 3E 20       0559*      ld a,' '
0402E3 5B D7       0560*      rst.lil 10h
0402E5 E1          0561*      pop hl
0402E6 D1          0562*      pop de
0402E7 C1          0563*      pop bc
0402E8 F1          0564*      pop af
0402E9 C9          0565*      ret
0402EA             0566*  
0402EA             0567*  print_s168_bc_de:
0402EA F5          0568*      push af
0402EB C5          0569*      push bc
0402EC D5          0570*      push de
0402ED C5          0571*      push bc
0402EE E1          0572*      pop hl
0402EF CD 83 02 04 0573*      call print_s168
0402F3 3E 20       0574*      ld a,' '
0402F5 5B D7       0575*      rst.lil 10h
0402F7 EB          0576*      ex de,hl
0402F8 CD 83 02 04 0577*      call print_s168
0402FC 3E 20       0578*      ld a,' '
0402FE 5B D7       0579*      rst.lil 10h
040300 E1          0580*      pop hl
040301 D1          0581*      pop de
040302 C1          0582*      pop bc
040303 F1          0583*      pop af
040304 C9          0584*      ret
040305             0585*  
040305             0586*  print_s168_a:
040305 F5          0587*      push af
040306 C5          0588*      push bc
040307 E5          0589*      push hl
040308 21 00 00 00 0590*      ld hl,0
04030C 6F          0591*      ld l,a
04030D CD 98 02 04 0592*      call print_s168_hl
040311 E1          0593*      pop hl
040312 C1          0594*      pop bc
040313 F1          0595*      pop af
040314 C9          0596*      ret
040315             0597*  
040315             0598*  ; #### new functions added by Brandon R. Gates ####
040315             0599*  
040315             0600*  ; print the binary representation of the 8-bit value in a
040315             0601*  ; destroys a, hl, bc
040315             0602*  printBin8:
040315 06 08       0603*      ld b,8 ; loop counter for 8 bits
040317 21 32 03 04 0604*      ld hl,@cmd ; set hl to the low byte of the output string
04031B             0605*      ; (which will be the high bit of the value in a)
04031B             0606*  @loop:
04031B 07          0607*      rlca ; put the next highest bit into carry
04031C 38 04       0608*      jr c,@one
04031E 36 30       0609*      ld (hl),'0'
040320 18 02       0610*      jr @next_bit
040322             0611*  @one:
040322 36 31       0612*      ld (hl),'1'
040324             0613*  @next_bit:
040324 23          0614*      inc hl
040325 10 F4       0615*      djnz @loop
040327             0616*  ; print it
040327 21 32 03 04 0617*      ld hl,@cmd
04032B 01 08 00 00 0618*      ld bc,@end-@cmd
04032F 5B DF       0619*      rst.lil $18
040331 C9          0620*      ret
040332             0621*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0622*  @end:
04033A             0623*  
04033A             0624*  ; print the binary representation of the 8-bit value in a
04033A             0625*  ; in reverse order (lsb first)
04033A             0626*  ; destroys a, hl, bc
04033A             0627*  printBin8Rev:
04033A 06 08       0628*      ld b,8 ; loop counter for 8 bits
04033C 21 57 03 04 0629*      ld hl,@cmd ; set hl to the low byte of the output string
040340             0630*      ; (which will be the high bit of the value in a)
040340             0631*  @loop:
040340 0F          0632*      rrca ; put the next lowest bit into carry
040341 38 04       0633*      jr c,@one
040343 36 30       0634*      ld (hl),'0'
040345 18 02       0635*      jr @next_bit
040347             0636*  @one:
040347 36 31       0637*      ld (hl),'1'
040349             0638*  @next_bit:
040349 23          0639*      inc hl
04034A 10 F4       0640*      djnz @loop
04034C             0641*  ; print it
04034C 21 57 03 04 0642*      ld hl,@cmd
040350 01 08 00 00 0643*      ld bc,@end-@cmd
040354 5B DF       0644*      rst.lil $18
040356 C9          0645*      ret
040357             0646*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0647*  @end:
04035F             0648*  
04035F             0649*  ; print registers to screen in hexidecimal format
04035F             0650*  ; inputs: none
04035F             0651*  ; outputs: values of every register printed to screen
04035F             0652*  ;    values of each register in global scratch memory
04035F             0653*  ; destroys: nothing
04035F             0654*  stepRegistersHex:
04035F             0655*  ; store everything in scratch
04035F 22 9F 05 04 0656*      ld (uhl),hl
040363 ED 43 A2 05 0657*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0658*      ld (ude),de
       04          
04036D DD 22 A8 05 0659*      ld (uix),ix
       04          
040372 FD 22 AB 05 0660*      ld (uiy),iy
       04          
040377 F5          0661*      push af ; fml
040378 E1          0662*      pop hl ; thanks, zilog
040379 22 9C 05 04 0663*      ld (uaf),hl
04037D F5          0664*      push af ; dammit
04037E             0665*  
04037E             0666*  ; home the cursor
04037E             0667*      ; call vdu_home_cursor
04037E             0668*  
04037E             0669*  ; print each register
04037E 21 22 05 04 0670*      ld hl,str_afu
040382 CD 77 00 04 0671*      call printString
040386 2A 9C 05 04 0672*      ld hl,(uaf)
04038A CD 97 00 04 0673*      call printHex24
04038E CD 8C 00 04 0674*      call printNewLine
040392             0675*  
040392 21 27 05 04 0676*      ld hl,str_hlu
040396 CD 77 00 04 0677*      call printString
04039A 2A 9F 05 04 0678*      ld hl,(uhl)
04039E CD 97 00 04 0679*      call printHex24
0403A2 CD 8C 00 04 0680*      call printNewLine
0403A6             0681*  
0403A6 21 2C 05 04 0682*      ld hl,str_bcu
0403AA CD 77 00 04 0683*      call printString
0403AE 2A A2 05 04 0684*      ld hl,(ubc)
0403B2 CD 97 00 04 0685*      call printHex24
0403B6 CD 8C 00 04 0686*      call printNewLine
0403BA             0687*  
0403BA 21 31 05 04 0688*      ld hl,str_deu
0403BE CD 77 00 04 0689*      call printString
0403C2 2A A5 05 04 0690*      ld hl,(ude)
0403C6 CD 97 00 04 0691*      call printHex24
0403CA CD 8C 00 04 0692*      call printNewLine
0403CE             0693*  
0403CE 21 36 05 04 0694*      ld hl,str_ixu
0403D2 CD 77 00 04 0695*      call printString
0403D6 2A A8 05 04 0696*      ld hl,(uix)
0403DA CD 97 00 04 0697*      call printHex24
0403DE CD 8C 00 04 0698*      call printNewLine
0403E2             0699*  
0403E2 21 3B 05 04 0700*      ld hl,str_iyu
0403E6 CD 77 00 04 0701*      call printString
0403EA 2A AB 05 04 0702*      ld hl,(uiy)
0403EE CD 97 00 04 0703*      call printHex24
0403F2 CD 8C 00 04 0704*      call printNewLine
0403F6             0705*  
0403F6             0706*      ; call vsync
0403F6             0707*  
0403F6 CD 8C 00 04 0708*      call printNewLine
0403FA             0709*  
0403FA             0710*  ; check for right shift key and quit if pressed
0403FA             0711*      MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0712*  @stayhere:
0403FE             0713*  ; 7 RightShift
0403FE DD CB 00 76 0714*      bit 6,(ix+0)
040402 20 02       0715*      jr nz,@RightShift
040404 18 F8       0716*      jr @stayhere
040406             0717*  @RightShift:
040406 DD CB 0E 86 0718*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0719*      ld a,%10000000
04040C             0720*      ; call multiPurposeDelay
04040C             0721*  
04040C             0722*  ; restore everything
04040C 2A 9F 05 04 0723*      ld hl, (uhl)
040410 ED 4B A2 05 0724*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0725*      ld de, (ude)
       04          
04041A DD 2A A8 05 0726*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0727*      ld iy, (uiy)
       04          
040424 F1          0728*      pop af
040425             0729*  ; all done
040425 C9          0730*      ret
040426             0731*  
040426             0732*  ; print registers to screen in hexidecimal format
040426             0733*  ; inputs: none
040426             0734*  ; outputs: values of every register printed to screen
040426             0735*  ;    values of each register in global scratch memory
040426             0736*  ; destroys: nothing
040426             0737*  dumpRegistersHex:
040426             0738*  ; store everything in scratch
040426 22 9F 05 04 0739*      ld (uhl),hl
04042A ED 43 A2 05 0740*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0741*      ld (ude),de
       04          
040434 DD 22 A8 05 0742*      ld (uix),ix
       04          
040439 FD 22 AB 05 0743*      ld (uiy),iy
       04          
04043E F5          0744*      push af ; fml
04043F E1          0745*      pop hl ; thanks, zilog
040440 22 9C 05 04 0746*      ld (uaf),hl
040444 F5          0747*      push af ; dammit
040445             0748*  
040445             0749*  ; home the cursor
040445             0750*      ; call vdu_home_cursor
040445             0751*      ; call printNewLine
040445             0752*  
040445             0753*  ; print each register
040445 21 22 05 04 0754*      ld hl,str_afu
040449 CD 77 00 04 0755*      call printString
04044D 2A 9C 05 04 0756*      ld hl,(uaf)
040451 CD 97 00 04 0757*      call printHex24
040455             0758*      ; call printNewLine
040455             0759*  
040455 21 27 05 04 0760*      ld hl,str_hlu
040459 CD 77 00 04 0761*      call printString
04045D 2A 9F 05 04 0762*      ld hl,(uhl)
040461 CD 97 00 04 0763*      call printHex24
040465             0764*      ; call printNewLine
040465             0765*  
040465 21 2C 05 04 0766*      ld hl,str_bcu
040469 CD 77 00 04 0767*      call printString
04046D 2A A2 05 04 0768*      ld hl,(ubc)
040471 CD 97 00 04 0769*      call printHex24
040475             0770*      ; call printNewLine
040475             0771*  
040475 21 31 05 04 0772*      ld hl,str_deu
040479 CD 77 00 04 0773*      call printString
04047D 2A A5 05 04 0774*      ld hl,(ude)
040481 CD 97 00 04 0775*      call printHex24
040485             0776*      ; call printNewLine
040485             0777*  
040485 21 36 05 04 0778*      ld hl,str_ixu
040489 CD 77 00 04 0779*      call printString
04048D 2A A8 05 04 0780*      ld hl,(uix)
040491 CD 97 00 04 0781*      call printHex24
040495             0782*      ; call printNewLine
040495             0783*  
040495 21 3B 05 04 0784*      ld hl,str_iyu
040499 CD 77 00 04 0785*      call printString
04049D 2A AB 05 04 0786*      ld hl,(uiy)
0404A1 CD 97 00 04 0787*      call printHex24
0404A5             0788*      ; call printNewLine
0404A5             0789*  
0404A5             0790*      ; call vdu_vblank
0404A5             0791*  
0404A5 CD 8C 00 04 0792*      call printNewLine
0404A9             0793*  ; restore everything
0404A9 2A 9F 05 04 0794*      ld hl, (uhl)
0404AD ED 4B A2 05 0795*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0796*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0797*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0798*      ld iy, (uiy)
       04          
0404C1 F1          0799*      pop af
0404C2             0800*  ; all done
0404C2 C9          0801*      ret
0404C3             0802*  
0404C3             0803*  dumpRegistersHexPrime:
0404C3 D9          0804*      exx
0404C4 08          0805*      ex af,af'
0404C5 CD 26 04 04 0806*      call dumpRegistersHex
0404C9 08          0807*      ex af,af'
0404CA D9          0808*      exx
0404CB C9          0809*      ret
0404CC             0810*  
0404CC             0811*  ; additionally dump prime registers
0404CC             0812*  ; inputs: none
0404CC             0813*  ; outputs: values of every register printed to screen
0404CC             0814*  ; destroys: nothing
0404CC             0815*  dumpRegistersHexAll:
0404CC CD 26 04 04 0816*      call dumpRegistersHex
0404D0 08          0817*      ex af,af'
0404D1 D9          0818*      exx
0404D2 CD 26 04 04 0819*      call dumpRegistersHex
0404D6 08          0820*      ex af,af'
0404D7 D9          0821*      exx
0404D8 C9          0822*      ret
0404D9             0823*  
0404D9             0824*  ; print hlu to screen in hexidecimal format
0404D9             0825*  ; inputs: none
0404D9             0826*  ; destroys: nothing
0404D9             0827*  print_hex_hl:
0404D9 F5          0828*      push af
0404DA E5          0829*      push hl
0404DB 21 27 05 04 0830*      ld hl,str_hlu
0404DF CD 77 00 04 0831*      call printString
0404E3 E1          0832*      pop hl
0404E4 E5          0833*      push hl
0404E5 CD 97 00 04 0834*      call printHex24
0404E9 3E 20       0835*      ld a,' '
0404EB 5B D7       0836*      rst.lil 10h
0404ED E1          0837*      pop hl
0404EE F1          0838*      pop af
0404EF C9          0839*      ret
0404F0             0840*  
0404F0             0841*  ; print bcu to screen in hexidecimal format
0404F0             0842*  ; inputs: none
0404F0             0843*  ; destroys: nothing
0404F0             0844*  print_hex_bc:
0404F0 F5          0845*      push af
0404F1 E5          0846*      push hl
0404F2 C5          0847*      push bc
0404F3 21 2C 05 04 0848*      ld hl,str_bcu
0404F7 CD 77 00 04 0849*      call printString
0404FB E1          0850*      pop hl
0404FC E5          0851*      push hl
0404FD CD 97 00 04 0852*      call printHex24
040501 3E 20       0853*      ld a,' '
040503 5B D7       0854*      rst.lil 10h
040505 C1          0855*      pop bc
040506 E1          0856*      pop hl
040507 F1          0857*      pop af
040508 C9          0858*      ret
040509             0859*  
040509             0860*  ; print deu to screen in hexidecimal format
040509             0861*  ; inputs: none
040509             0862*  ; destroys: nothing
040509             0863*  print_hex_de:
040509 F5          0864*      push af
04050A E5          0865*      push hl
04050B D5          0866*      push de
04050C 21 31 05 04 0867*      ld hl,str_deu
040510 CD 77 00 04 0868*      call printString
040514 E1          0869*      pop hl
040515 E5          0870*      push hl
040516 CD 97 00 04 0871*      call printHex24
04051A 3E 20       0872*      ld a,' '
04051C 5B D7       0873*      rst.lil 10h
04051E D1          0874*      pop de
04051F E1          0875*      pop hl
040520 F1          0876*      pop af
040521 C9          0877*      ret
040522             0878*  
040522 20 61 66 3D 0879*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0880*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0881*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0882*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0883*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0884*  str_iyu: db " iy=",0
       00          
040540             0885*  
040540             0886*  ; print udeuhl to screen in hexidecimal format
040540             0887*  ; inputs: none
040540             0888*  ; outputs: concatenated hexidecimal udeuhl
040540             0889*  ; destroys: nothing
040540             0890*  dumpUDEUHLHex:
040540             0891*  ; store everything in scratch
040540 22 9F 05 04 0892*      ld (uhl),hl
040544 ED 43 A2 05 0893*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0894*      ld (ude),de
       04          
04054E DD 22 A8 05 0895*      ld (uix),ix
       04          
040553 FD 22 AB 05 0896*      ld (uiy),iy
       04          
040558 F5          0897*      push af
040559             0898*  
040559             0899*  ; print each register
040559             0900*  
040559 21 93 05 04 0901*      ld hl,str_udeuhl
04055D CD 77 00 04 0902*      call printString
040561 2A A5 05 04 0903*      ld hl,(ude)
040565 CD 97 00 04 0904*      call printHex24
040569 3E 2E       0905*      ld a,'.' ; print a dot to separate the values
04056B 5B D7       0906*      rst.lil 10h
04056D 2A 9F 05 04 0907*      ld hl,(uhl)
040571 CD 97 00 04 0908*      call printHex24
040575 CD 8C 00 04 0909*      call printNewLine
040579             0910*  
040579             0911*  ; restore everything
040579 2A 9F 05 04 0912*      ld hl, (uhl)
04057D ED 4B A2 05 0913*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0914*      ld de, (ude)
       04          
040587 DD 2A A8 05 0915*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0916*      ld iy, (uiy)
       04          
040591 F1          0917*      pop af
040592             0918*  ; all done
040592 C9          0919*      ret
040593             0920*  
040593 75 64 65 2E 0921*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0922*  
04059C             0923*  ; global scratch memory for registers
04059C 00 00 00    0924*  uaf: dl 0
04059F 00 00 00    0925*  uhl: dl 0
0405A2 00 00 00    0926*  ubc: dl 0
0405A5 00 00 00    0927*  ude: dl 0
0405A8 00 00 00    0928*  uix: dl 0
0405AB 00 00 00    0929*  uiy: dl 0
0405AE 00 00 00    0930*  usp: dl 0
0405B1 00 00 00    0931*  upc: dl 0
0405B4             0932*  
0405B4             0933*  ; inputs: whatever is in the flags register
0405B4             0934*  ; outputs: binary representation of flags
0405B4             0935*  ;          with a header so we know which is what
0405B4             0936*  ; destroys: nothing
0405B4             0937*  ; preserves: everything
0405B4             0938*  dumpFlags:
0405B4             0939*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0940*      push af ; this is so we can send it back unharmed
0405B5 F5          0941*      push af ; this is so we can pop it to hl
0405B6             0942*  ; store everything in scratch
0405B6 22 9F 05 04 0943*      ld (uhl),hl
0405BA ED 43 A2 05 0944*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0945*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0946*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0947*      ld (uiy),iy
       04          
0405CE             0948*  ; next we print the header
0405CE 21 FA 05 04 0949*      ld hl,@header
0405D2 CD 77 00 04 0950*      call printString
0405D6 E1          0951*      pop hl ; flags are now in l
0405D7 7D          0952*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0953*      call printBin8
0405DC CD 8C 00 04 0954*      call printNewLine
0405E0             0955*  ; restore everything
0405E0 2A 9F 05 04 0956*      ld hl, (uhl)
0405E4 ED 4B A2 05 0957*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0958*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0959*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0960*      ld iy, (uiy)
       04          
0405F8 F1          0961*      pop af ; send her home the way she came
0405F9 C9          0962*      ret
0405FA             0963*  ; Bit 7 (S): Sign flag
0405FA             0964*  ; Bit 6 (Z): Zero flag
0405FA             0965*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0966*  ; Bit 4 (H): Half Carry flag
0405FA             0967*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0968*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0969*  ; Bit 1 (N): Subtract flag
0405FA             0970*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0971*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0972*  
040605             0973*  ; set all the bits in the flag register
040605             0974*  ; more of an academic exercise than anything useful
040605             0975*  ; inputs; none
040605             0976*  ; outputs; a=0,f=255
040605             0977*  ; destroys: flags, hl
040605             0978*  ; preserves: a, because why not
040605             0979*  setAllFlags:
040605 21 FF 00 00 0980*      ld hl,255
040609 67          0981*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0982*      push hl
04060B F1          0983*      pop af
04060C C9          0984*      ret
04060D             0985*  
04060D             0986*  ; reset all the bits in the flag register
04060D             0987*  ; unlike its inverse counterpart, this may actually be useful
04060D             0988*  ; inputs; none
04060D             0989*  ; outputs; a=0,f=0
04060D             0990*  ; destroys: flags, hl
04060D             0991*  ; preserves: a, because why not
04060D             0992*  resetAllFlags:
04060D 21 00 00 00 0993*      ld hl,0
040611 67          0994*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0995*      push hl
040613 F1          0996*      pop af
040614 C9          0997*      ret
040615             0998*  
040615             0999*  ; wait until user presses a key
040615             1000*  ; inputs: none
040615             1001*  ; outputs: ascii code of key pressed in a
040615             1002*  ; destroys: af,ix
040615             1003*  waitKeypress:
040615             1004*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1005*      ret
04061A             1006*  
04061A             1007*  ; print bytes from an address to the screen in hexidecimal format
04061A             1008*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1009*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1010*  ; destroys: nothing
04061A             1011*  dumpMemoryHex:
04061A             1012*  ; save registers to the stack
04061A C5          1013*      push bc
04061B E5          1014*      push hl
04061C F5          1015*      push af
04061D             1016*  
04061D             1017*  ; print the address and separator
04061D CD 97 00 04 1018*      call printHex24
040621 3E 3A       1019*      ld a,':'
040623 5B D7       1020*      rst.lil 10h
040625 3E 20       1021*      ld a,' '
040627 5B D7       1022*      rst.lil 10h
040629             1023*  
040629             1024*  ; set b to be our loop counter
040629 F1          1025*      pop af
04062A 47          1026*      ld b,a
04062B E1          1027*      pop hl
04062C E5          1028*      push hl
04062D F5          1029*      push af
04062E             1030*  @loop:
04062E             1031*  ; print the byte
04062E 7E          1032*      ld a,(hl)
04062F CD A5 00 04 1033*      call printHex8
040633             1034*  ; print a space
040633 3E 20       1035*      ld a,' '
040635 5B D7       1036*      rst.lil 10h
040637 23          1037*      inc hl
040638 10 F4       1038*      djnz @loop
04063A CD 8C 00 04 1039*      call printNewLine
04063E             1040*  
04063E             1041*  ; restore everything
04063E F1          1042*      pop af
04063F E1          1043*      pop hl
040640 C1          1044*      pop bc
040641             1045*  
040641             1046*  ; all done
040641 C9          1047*      ret
040642             1048*  
040642             1049*  
040642             1050*  ; print bytes from an address to the screen in binary format
040642             1051*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1052*  ; outputs: values of each byte printed to screen separated by spaces
040642             1053*  ; destroys: nothing
040642             1054*  dumpMemoryBin:
040642             1055*  ; save all registers to the stack
040642 F5          1056*      push af
040643 C5          1057*      push bc
040644 D5          1058*      push de
040645 E5          1059*      push hl
040646 DD E5       1060*      push ix
040648 FD E5       1061*      push iy
04064A             1062*  
04064A             1063*  ; set b to be our loop counter
04064A 47          1064*      ld b,a
04064B             1065*  @loop:
04064B             1066*  ; print the byte
04064B 7E          1067*      ld a,(hl)
04064C E5          1068*      push hl
04064D C5          1069*      push bc
04064E CD 15 03 04 1070*      call printBin8
040652 C1          1071*      pop bc
040653             1072*  ; print a space
040653 3E 20       1073*      ld a,' '
040655 5B D7       1074*      rst.lil 10h
040657 E1          1075*      pop hl
040658 23          1076*      inc hl
040659 10 F0       1077*      djnz @loop
04065B CD 8C 00 04 1078*      call printNewLine
04065F             1079*  
04065F             1080*  ; restore everything
04065F FD E1       1081*      pop iy
040661 DD E1       1082*      pop ix
040663 E1          1083*      pop hl
040664 D1          1084*      pop de
040665 C1          1085*      pop bc
040666 F1          1086*      pop af
040667             1087*  ; all done
040667 C9          1088*      ret
040668             1089*  
040668             1090*  ; print bytes from an address to the screen in binary format
040668             1091*  ; with the bits of each byte in reverse order (lsb first)
040668             1092*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1093*  ; outputs: values of each byte printed to screen separated by spaces
040668             1094*  ; destroys: nothing
040668             1095*  dumpMemoryBinRev:
040668             1096*  ; save all registers to the stack
040668 F5          1097*      push af
040669 C5          1098*      push bc
04066A D5          1099*      push de
04066B E5          1100*      push hl
04066C DD E5       1101*      push ix
04066E FD E5       1102*      push iy
040670             1103*  
040670             1104*  ; set b to be our loop counter
040670 47          1105*      ld b,a
040671             1106*  @loop:
040671             1107*  ; print the byte
040671 7E          1108*      ld a,(hl)
040672 E5          1109*      push hl
040673 C5          1110*      push bc
040674 CD 3A 03 04 1111*      call printBin8Rev
040678 C1          1112*      pop bc
040679             1113*  ; print a space
040679 3E 20       1114*      ld a,' '
04067B 5B D7       1115*      rst.lil 10h
04067D E1          1116*      pop hl
04067E 23          1117*      inc hl
04067F 10 F0       1118*      djnz @loop
040681 CD 8C 00 04 1119*      call printNewLine
040685             1120*  
040685             1121*  ; restore everything
040685 FD E1       1122*      pop iy
040687 DD E1       1123*      pop ix
040689 E1          1124*      pop hl
04068A D1          1125*      pop de
04068B C1          1126*      pop bc
04068C F1          1127*      pop af
04068D             1128*  ; all done
04068D C9          1129*      ret
04068E             0031       include "arith24.inc"
04068E             0001*  ;------------------------------------------------------------------------
04068E             0002*  ;  arith24.asm
04068E             0003*  ;  24-bit ez80 arithmetic routines
04068E             0004*  ;  Copyright (c) Shawn Sijnstra 2024
04068E             0005*  ;  MIT license
04068E             0006*  ;
04068E             0007*  ;  This library was created as a tool to help make ez80
04068E             0008*  ;  24-bit native assembly routines for simple mathematical problems
04068E             0009*  ;  more widely available.
04068E             0010*  ;
04068E             0011*  ;------------------------------------------------------------------------
04068E             0012*  
04068E             0013*  ; ;------------------------------------------------------------------------
04068E             0014*  ; ; DEPRECATED BY umul24 in fixed168.inc
04068E             0015*  ; ;------------------------------------------------------------------------
04068E             0016*  ; ; umul24:	HL = HL*DE (unsigned)
04068E             0017*  ; ; Preserves AF, BC, DE
04068E             0018*  ; ; Uses a fast multiply routine.
04068E             0019*  ; ;------------------------------------------------------------------------
04068E             0020*  ; umul24:
04068E             0021*  ; 	push	DE
04068E             0022*  ; 	push	BC
04068E             0023*  ; 	push	AF
04068E             0024*  ; 	push	HL
04068E             0025*  ; 	pop		BC
04068E             0026*  ;     ld	 	a, 24 ; No. of bits to process
04068E             0027*  ;     ld	 	hl, 0 ; Result
04068E             0028*  ; umul24_lp:
04068E             0029*  ; 	add	hl,hl
04068E             0030*  ; 	ex	de,hl
04068E             0031*  ; 	add	hl,hl
04068E             0032*  ; 	ex	de,hl
04068E             0033*  ; 	jr	nc,umul24_nc
04068E             0034*  ; 	add	hl,bc
04068E             0035*  ; umul24_nc:
04068E             0036*  ; 	dec	a
04068E             0037*  ; 	jr	nz,umul24_lp
04068E             0038*  ; 	pop	af
04068E             0039*  ; 	pop	bc
04068E             0040*  ; 	pop	de
04068E             0041*  ; 	ret
04068E             0042*  
04068E             0043*  
04068E             0044*  ;------------------------------------------------------------------------
04068E             0045*  ; udiv24
04068E             0046*  ; Unsigned 24-bit division
04068E             0047*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
04068E             0048*  ;
04068E             0049*  ; Uses AF BC DE HL
04068E             0050*  ; Uses Restoring Division algorithm
04068E             0051*  ;------------------------------------------------------------------------
04068E             0052*  
04068E             0053*  udiv24:
04068E E5          0054*  	push	hl
04068F C1          0055*  	pop		bc	;move dividend to BCU
040690 21 00 00 00 0056*  	ld		hl,0	;result
040694 A7          0057*  	and		a
040695 ED 52       0058*  	sbc		hl,de	;test for div by 0
040697 C8          0059*  	ret		z		;it's zero, carry flag is clear
040698 19          0060*  	add		hl,de	;HL is 0 again
040699 3E 18       0061*  	ld		a,24	;number of loops through.
04069B             0062*  udiv1:
04069B C5          0063*  	push	bc	;complicated way of doing this because of lack of access to top bits
04069C E3          0064*  	ex		(sp),hl
04069D 37          0065*  	scf
04069E ED 6A       0066*  	adc	hl,hl
0406A0 E3          0067*  	ex	(sp),hl
0406A1 C1          0068*  	pop	bc		;we now have bc = (bc * 2) + 1
0406A2             0069*  
0406A2 ED 6A       0070*  	adc	hl,hl
0406A4 A7          0071*  	and	a		;is this the bug
0406A5 ED 52       0072*  	sbc	hl,de
0406A7 30 02       0073*  	jr	nc,udiv2
0406A9 19          0074*  	add	hl,de
0406AA             0075*  ;	dec	c
0406AA 0B          0076*  	dec	bc
0406AB             0077*  udiv2:
0406AB 3D          0078*  	dec	a
0406AC 20 ED       0079*  	jr	nz,udiv1
0406AE 37          0080*  	scf		;flag used for div0 error
0406AF C5          0081*  	push	bc
0406B0 D1          0082*  	pop		de	;remainder
0406B1 C9          0083*  	ret
0406B2             0084*  
0406B2             0085*  
0406B2             0086*  
0406B2             0087*  ;------------------------------------------------------------------------
0406B2             0088*  ; neg24
0406B2             0089*  ; Returns: HLU = 0-HLU
0406B2             0090*  ; preserves all other registers
0406B2             0091*  ;------------------------------------------------------------------------
0406B2             0092*  neg24:
0406B2 D5          0093*  	push	de
0406B3 EB          0094*  	ex		de,hl
0406B4 21 00 00 00 0095*  	ld		hl,0
0406B8 B7          0096*  	or		a
0406B9 ED 52       0097*  	sbc		hl,de
0406BB D1          0098*  	pop		de
0406BC C9          0099*  	ret
0406BD             0100*  
0406BD             0101*  ;------------------------------------------------------------------------
0406BD             0102*  ; or_hlu_deu: 24 bit bitwise OR
0406BD             0103*  ; Returns: hlu = hlu OR deu
0406BD             0104*  ; preserves all other registers
0406BD             0105*  ;------------------------------------------------------------------------
0406BD             0106*  or_hlu_deu:
0406BD 22 46 07 04 0107*  	ld	(bitbuf1),hl
0406C1 ED 53 49 07 0108*  	ld	(bitbuf2),de
       04          
0406C6 D5          0109*  	push	de	;preserve DEU
0406C7 C5          0110*  	push	bc	;preserve BCU
0406C8 06 03       0111*  	ld		b,3
0406CA 21 46 07 04 0112*  	ld	hl,bitbuf1
0406CE 11 46 07 04 0113*  	ld	de,bitbuf1
0406D2             0114*  orloop_24:
0406D2 1A          0115*  	ld	a,(de)
0406D3 B6          0116*  	or	(hl)
0406D4 12          0117*  	ld	(de),a
0406D5 13          0118*  	inc	de
0406D6 23          0119*  	inc	hl
0406D7 10 F9       0120*  	djnz	orloop_24
0406D9 2A 49 07 04 0121*  	ld	hl,(bitbuf2)
0406DD C1          0122*  	pop		bc	;restore BC
0406DE D1          0123*  	pop		de	;restore DE
0406DF             0124*  
0406DF             0125*  ;------------------------------------------------------------------------
0406DF             0126*  ; and_hlu_deu: 24 bit bitwise AND
0406DF             0127*  ; Returns: hlu = hlu AND deu
0406DF             0128*  ; preserves all other registers
0406DF             0129*  ;------------------------------------------------------------------------
0406DF             0130*  and_hlu_deu:
0406DF 22 46 07 04 0131*  	ld	(bitbuf1),hl
0406E3 ED 53 49 07 0132*  	ld	(bitbuf2),de
       04          
0406E8 D5          0133*  	push	de	;preserve DEU
0406E9 C5          0134*  	push	bc	;preserve BCU
0406EA 06 03       0135*  	ld		b,3
0406EC 21 46 07 04 0136*  	ld	hl,bitbuf1
0406F0 11 46 07 04 0137*  	ld	de,bitbuf1
0406F4             0138*  andloop_24:
0406F4 1A          0139*  	ld	a,(de)
0406F5 A6          0140*  	and	(hl)
0406F6 12          0141*  	ld	(de),a
0406F7 13          0142*  	inc	de
0406F8 23          0143*  	inc	hl
0406F9 10 F9       0144*  	djnz	andloop_24
0406FB 2A 49 07 04 0145*  	ld	hl,(bitbuf2)
0406FF C1          0146*  	pop		bc	;restore BC
040700 D1          0147*  	pop		de	;restore DE
040701             0148*  
040701             0149*  ;------------------------------------------------------------------------
040701             0150*  ; xor_hlu_deu: 24 bit bitwise XOR
040701             0151*  ; Returns: hlu = hlu XOR deu
040701             0152*  ; preserves all other registers
040701             0153*  ;------------------------------------------------------------------------
040701             0154*  xor_hlu_deu:
040701 22 46 07 04 0155*  	ld	(bitbuf1),hl
040705 ED 53 49 07 0156*  	ld	(bitbuf2),de
       04          
04070A D5          0157*  	push	de	;preserve DEU
04070B C5          0158*  	push	bc	;preserve BCU
04070C 06 03       0159*  	ld		b,3
04070E 21 46 07 04 0160*  	ld	hl,bitbuf1
040712 11 46 07 04 0161*  	ld	de,bitbuf1
040716             0162*  xorloop_24:
040716 1A          0163*  	ld	a,(de)
040717 AE          0164*  	xor	(hl)
040718 12          0165*  	ld	(de),a
040719 13          0166*  	inc	de
04071A 23          0167*  	inc	hl
04071B 10 F9       0168*  	djnz	xorloop_24
04071D 2A 49 07 04 0169*  	ld	hl,(bitbuf2)
040721 C1          0170*  	pop		bc	;restore BC
040722 D1          0171*  	pop		de	;restore DE
040723             0172*  
040723             0173*  ;------------------------------------------------------------------------
040723             0174*  ; shl_hlu: 24 bit shift left hlu by a positions
040723             0175*  ; Returns: hlu = hlu << a
040723             0176*  ;		   a = 0
040723             0177*  ; NOTE: only considers a up to 16 bits.
040723             0178*  ; preserves all other registers
040723             0179*  ; modified by Brandon R. Gates to use a instead of de
040723             0180*  ;------------------------------------------------------------------------
040723             0181*  shl_hlu:
040723 B7          0182*  	or a
040724 C8          0183*  	ret		z		;we're done
040725 29          0184*  	add		hl,hl	;shift HLU left
040726 3D          0185*  	dec a
040727 18 FA       0186*  	jr		shl_hlu
040729             0187*  
040729             0188*  ;------------------------------------------------------------------------
040729             0189*  ; shr_hlu: 24 bit shift right hlu by a positions
040729             0190*  ; Returns: hlu = hlu >> a
040729             0191*  ;		   a = 0
040729             0192*  ; NOTE: only considers a up to 16 bits.
040729             0193*  ; preserves all other registers
040729             0194*  ; modified by Brandon R. Gates to use a instead of de
040729             0195*  ;------------------------------------------------------------------------
040729             0196*  shr_hlu:
040729 22 46 07 04 0197*  	ld		(bitbuf1),hl
04072D 21 48 07 04 0198*  	ld		hl,bitbuf1+2
040731             0199*  @shr_loop:
040731 B7          0200*  	or a
040732 28 0D       0201*  	jr		z,@shr_done		;we're done
040734             0202*  ;carry is clear from or instruction
040734 CB 1E       0203*  	rr		(hl)
040736 2B          0204*  	dec		hl
040737 CB 1E       0205*  	rr		(hl)
040739 2B          0206*  	dec		hl
04073A CB 1E       0207*  	rr		(hl)
04073C 23          0208*  	inc		hl
04073D 23          0209*  	inc		hl
04073E 3D          0210*  	dec a
04073F 18 F0       0211*  	jr		@shr_loop
040741             0212*  @shr_done:
040741 2A 46 07 04 0213*  	ld		hl,(bitbuf1)	;collect result
040745 C9          0214*  	ret
040746             0215*  
040746             0216*  ;------------------------------------------------------------------------
040746             0217*  ; Scratch area for calculations
040746             0218*  ;------------------------------------------------------------------------
040746 00 00 00    0219*  bitbuf1:	dw24	0	;bit manipulation buffer 1
040749 00 00 00    0220*  bitbuf2:	dw24	0	;bit manipulation buffer 2
04074C             0221*  
04074C             0222*  ; -----------------------------------------------------------------------
04074C             0223*  ; Functions added by Brandon R. Gates
04074C             0224*  ; -----------------------------------------------------------------------
04074C             0225*  
04074C             0226*  ;------------------------------------------------------------------------
04074C             0227*  ; shr_hlu_div: Quick division by powers of two based on log2 of A
04074C             0228*  ;              Determines the LSB of A and shifts HLU accordingly.
04074C             0229*  ;              HLU = HLU >> LSB(A)
04074C             0230*  ; Returns: HLU = HLU >> LSB(A)
04074C             0231*  ; Destroys: af
04074C             0232*  ;------------------------------------------------------------------------
04074C             0233*  shr_hlu_log2a:
04074C B7          0234*  	or a    ; check for zero
04074D C8          0235*  	ret z   ; nothing to shift so we're done
04074E C5          0236*  	push 	bc ; preserve
04074F 06 00       0237*  	ld		b,0 ; clear b
040751             0238*  @find_bit:
040751 0F          0239*  	rrca ; bit 0 to carry
040752 DA 5B 07 04 0240*  	jp c,@found_bit
040756 04          0241*  	inc b ; next bit
040757 C3 51 07 04 0242*  	jp @find_bit
04075B             0243*  @found_bit:
04075B 78          0244*  	ld a,b
04075C CD 29 07 04 0245*  	call shr_hlu
040760 C1          0246*  	pop 	bc ; restore
040761 C9          0247*  	ret
040762             0248*  ; end shr_hlu_log2a
040762             0249*  
040762             0250*  ;------------------------------------------------------------------------
040762             0251*  ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
040762             0252*  ;                Determines the LSB of A and shifts HLU accordingly.
040762             0253*  ;                HLU = HLU << LSB(A)
040762             0254*  ; Returns: HLU = HLU << LSB(A)
040762             0255*  ; Destroys: af
040762             0256*  ;------------------------------------------------------------------------
040762             0257*  shl_hlu_log2a:
040762 B7          0258*  	or a    ; check for zero
040763 C8          0259*  	ret z   ; nothing to shift so we're done
040764 C5          0260*  	push 	bc ; preserve
040765 06 00       0261*  	ld		b,0 ; clear b
040767             0262*  @find_bit:
040767 0F          0263*  	rrca ; bit 0 to carry
040768 DA 71 07 04 0264*  	jp c,@found_bit
04076C 04          0265*  	inc b ; next bit
04076D C3 67 07 04 0266*  	jp @find_bit
040771             0267*  @found_bit:
040771 78          0268*  	ld a,b
040772 CD 23 07 04 0269*  	call shl_hlu
040776 C1          0270*  	pop 	bc ; restore
040777 C9          0271*  	ret
040778             0272*  ; end shl_hlu_log2a
040778             0032       include "maths.inc"
040778             0001*  ; test the sign of HL
040778             0002*  ; inputs: HL obviously
040778             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040778             0004*  ; destroys: flags
040778             0005*      MACRO sign_hlu
040778             0006*      add hl,de
040778             0007*      or a ; clear flags
040778             0008*      sbc hl,de
040778             0009*      ENDMACRO
040778             0010*  
040778             0011*  
040778             0012*  ;------------------------------------------------------------------------
040778             0013*  ; Scratch area for calculations
040778             0014*  ;------------------------------------------------------------------------
040778 00 00 00    0015*  scratch1: dw24 0 ;bit manipulation buffer 1
04077B 00 00 00    0016*  scratch2: dw24 0 ;bit manipulation buffer 2
04077E             0017*  
04077E             0018*  ; absolute value of hlu
04077E             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
04077E             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
04077E             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
04077E             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
04077E             0023*  ; destroys: a
04077E             0024*  hlu_abs:
04077E 19          0025*      add hl,de
04077F B7          0026*      or a
040780 ED 52       0027*      sbc hl,de
040782 FA 87 07 04 0028*      jp m,@is_neg
040786 C9          0029*      ret ; hlu is positive or zero so we're done
040787             0030*  @is_neg:
040787 F5          0031*      push af ; otherwise, save current flags for return
040788 CD 8E 07 04 0032*      call neg_hlu ; negate hlu
04078C F1          0033*      pop af ; get back flags
04078D C9          0034*      ret
04078E             0035*  
04078E             0036*  ; flip the sign of hlu
04078E             0037*  ; inputs: hlu
04078E             0038*  ; returns: 0-hlu, flags set appropriately for the result:
04078E             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
04078E             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
04078E             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
04078E             0042*  ; destroys a
04078E             0043*  neg_hlu:
04078E D5          0044*      push de ; save de
04078F EB          0045*      ex de,hl ; put hl into de
040790 21 00 00 00 0046*      ld hl,0 ; clear hl
040794 AF          0047*      xor a ; clear carry
040795 ED 52       0048*      sbc hl,de ; 0-hlu = -hlu
040797 D1          0049*      pop de ; get de back
040798 C9          0050*      ret ; easy peasy
040799             0051*  
040799             0052*  ;------------------------------------------------------------------------
040799             0053*  ; divide hlu by 2, inspired by above
040799             0054*  ;------------------------------------------------------------------------
040799             0055*  hlu_div2:
040799 22 78 07 04 0056*      ld (scratch1),hl
04079D 21 7A 07 04 0057*      ld hl,scratch1+2
0407A1 CB 1E       0058*      rr (hl)
0407A3 2B          0059*      dec hl
0407A4 CB 1E       0060*      rr (hl)
0407A6 2B          0061*      dec hl
0407A7 CB 1E       0062*      rr (hl)
0407A9 23          0063*      inc hl
0407AA 23          0064*      inc hl
0407AB 2A 78 07 04 0065*      ld hl,(scratch1)
0407AF C9          0066*      ret
0407B0             0067*  
0407B0             0068*  ; this is my little hack to divide by 16
0407B0             0069*  hlu_div16:
0407B0 AF          0070*      xor a
0407B1 29          0071*      add hl,hl
0407B2 17          0072*      rla
0407B3 29          0073*      add hl,hl
0407B4 17          0074*      rla
0407B5 29          0075*      add hl,hl
0407B6 17          0076*      rla
0407B7 29          0077*      add hl,hl
0407B8 17          0078*      rla
0407B9 22 C6 07 04 0079*      ld (@scratch),hl
0407BD 32 C9 07 04 0080*      ld (@scratch+3),a
0407C1 2A C7 07 04 0081*      ld hl,(@scratch+1)
0407C5 C9          0082*      ret
0407C6             0083*  @scratch: ds 4
0407CA             0084*  
0407CA             0085*  ; hlu signed division by 256
0407CA             0086*  ; returns: hlu / 256
0407CA             0087*  ; destroys: af
0407CA             0088*  hlu_sdiv256:
0407CA AF          0089*      xor a ; assume hl is positive
0407CB 22 E1 07 04 0090*      ld (@buffer),hl
0407CF             0091*      sign_hlu
0407CF 19          0001*M     add hl,de
0407D0 B7          0002*M     or a ; clear flags
0407D1 ED 52       0003*M     sbc hl,de
0407D3 F2 D8 07 04 0092*      jp p,@hl_pos
0407D7 3D          0093*      dec a
0407D8             0094*  @hl_pos:
0407D8 32 E4 07 04 0095*      ld (@buffer+3),a
0407DC 2A E2 07 04 0096*      ld hl,(@buffer+1)
0407E0 C9          0097*      ret
0407E1             0098*  @buffer: ds 4
0407E5             0099*  
0407E5             0100*  ; hlu 1 byte right shift, unsigned
0407E5             0101*  ; returns: hlu / 256, fractional portion in a
0407E5             0102*  ; destroys: af
0407E5             0103*  hlu_udiv256:
0407E5 AF          0104*      xor a
0407E6 32 F7 07 04 0105*      ld (@buffer+3),a
0407EA 7D          0106*      ld a,l ; save the fractional portion
0407EB 22 F4 07 04 0107*      ld (@buffer),hl
0407EF 2A F5 07 04 0108*      ld hl,(@buffer+1)
0407F3 C9          0109*      ret
0407F4             0110*  @buffer: ds 4
0407F8             0111*  
0407F8             0112*      MACRO hlu_mul256
0407F8             0113*      add hl,hl ; * 2
0407F8             0114*      add hl,hl ; * 4
0407F8             0115*      add hl,hl ; * 8
0407F8             0116*      add hl,hl ; * 16
0407F8             0117*      add hl,hl ; * 32
0407F8             0118*      add hl,hl ; * 64
0407F8             0119*      add hl,hl ; * 128
0407F8             0120*      add hl,hl ; * 256
0407F8             0121*      ENDMACRO
0407F8             0122*  
0407F8             0123*  ; compute the modulo of hlu by deu
0407F8             0124*  ; outputs: hlu = hlu % deu
0407F8             0125*  ; destroys: f, hl
0407F8             0126*  hlu_mod:
0407F8 B7          0127*      or a ; clear carry
0407F9             0128*  @loop:
0407F9 ED 52       0129*      sbc hl,de
0407FB DA 03 08 04 0130*      jp c, @end
0407FF C3 F9 07 04 0131*      jp @loop
040803             0132*  @end:
040803 19          0133*      add hl,de
040804 C9          0134*      ret
040805             0135*  
040805             0136*  
040805 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
040809 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
04080D             0139*  
04080D             0140*  ; set bcd values in a scratch memory address from registers bcde
04080D             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
04080D             0142*  ; destroys ; hl
04080D             0143*  set_bcd:
04080D 73          0144*      ld (hl),e
04080E 23          0145*      inc hl
04080F 72          0146*      ld (hl),d
040810 23          0147*      inc hl
040811 71          0148*      ld (hl),c
040812 23          0149*      inc hl
040813 70          0150*      ld (hl),b
040814 C9          0151*      ret
040815             0152*  
040815             0153*  ; load bcd values from a scratch memory address to bcde
040815             0154*  ; input: hl; scratch address
040815             0155*  ; output: bcde; 8-place bcd number
040815             0156*  ; destroys: hl
040815             0157*  get_bcd:
040815 5E          0158*      ld e,(hl)
040816 23          0159*      inc hl
040817 56          0160*      ld d,(hl)
040818 23          0161*      inc hl
040819 4E          0162*      ld c,(hl)
04081A 23          0163*      inc hl
04081B 46          0164*      ld b,(hl)
04081C C9          0165*      ret
04081D             0166*  
04081D             0167*  ; BCD addition
04081D             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04081D             0169*  ;       a is the number of bytes holding each number (number of places/2)
04081D             0170*  ; outputs: (hl) + (de) --> (hl)
04081D             0171*  ; destroys: a,b,de,hl
04081D             0172*  add_bcd:
04081D 47          0173*      ld b,a ; loop counter
04081E AF          0174*      xor a ; reset a, clear carry flag
04081F             0175*  adcec:
04081F 1A          0176*      ld a,(de) ; addend to acc
040820 8E          0177*      adc a,(hl) ; add (hl) to acc
040821 27          0178*      daa ; adjust result to bcd
040822 77          0179*      ld (hl),a ; store result
040823 23          0180*      inc hl ; advance memory pointers
040824 13          0181*      inc de
040825 10 F8       0182*      djnz adcec ; loop until b == 0
040827 C9          0183*      ret
040828             0184*  
040828             0185*  ; BCD subtraction
040828             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040828             0187*  ;       a is the number of bytes holding each number (number of places/2)
040828             0188*  ; outputs: (hl) - (de) --> (hl)
040828             0189*  ; destroys: a,b,de,hl
040828             0190*  sub_bcd:
040828 47          0191*      ld b,a ; loop counter
040829 AF          0192*      xor a ; reset a,clear carry flag
04082A             0193*  subdec:
04082A 1A          0194*      ld a,(de) ; subtrahend to acc
04082B 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
04082C 27          0196*      daa ; adjust result to bcd
04082D 77          0197*      ld (hl),a ; store result
04082E 23          0198*      inc hl ; advance memory pointers
04082F 13          0199*      inc de
040830 10 F8       0200*      djnz subdec ; loop until b == 0
040832 C9          0201*      ret
040833             0202*  
040833             0203*  ; http://www.z80.info/pseudo-random.txt
040833             0204*  rand_8:
040833 C5          0205*      push bc
040834 3A 47 08 04 0206*      ld a,(r_seed)
040838 4F          0207*      ld c,a
040839             0208*  
040839 0F          0209*      rrca ; multiply by 32
04083A 0F          0210*      rrca
04083B 0F          0211*      rrca
04083C EE 1F       0212*      xor 0x1f
04083E             0213*  
04083E 81          0214*      add a,c
04083F DE FF       0215*      sbc a,255 ; carry
040841             0216*  
040841 32 47 08 04 0217*      ld (r_seed),a
040845 C1          0218*      pop bc
040846 C9          0219*      ret
040847 50          0220*  r_seed: defb $50
040848             0221*  
040848             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
040848             0223*  prng24:
040848             0224*  ;;Expects ADL mode.
040848             0225*  ;;Output: HL
040848             0226*  ;;50cc
040848             0227*  ;;33 bytes
040848             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
040848 ED 5B 69 08 0229*      ld de,(seed1)
       04          
04084D B7          0230*      or a
04084E ED 62       0231*      sbc hl,hl
040850 19          0232*      add hl,de
040851 29          0233*      add hl,hl
040852 29          0234*      add hl,hl
040853 2C          0235*      inc l
040854 19          0236*      add hl,de
040855 22 69 08 04 0237*      ld (seed1),hl
040859 2A 6C 08 04 0238*      ld hl,(seed2)
04085D 29          0239*      add hl,hl
04085E 9F          0240*      sbc a,a
04085F E6 1B       0241*      and %00011011
040861 AD          0242*      xor l
040862 6F          0243*      ld l,a
040863 22 6C 08 04 0244*      ld (seed2),hl
040867 19          0245*      add hl,de
040868 C9          0246*      ret
040869 00 00 00    0247*  seed1: dl 0
04086C 00 00 00    0248*  seed2: dl 0
04086F             0033       include "files.inc"
04086F             0001*  ; load to onboard 8k sram
04086F             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
04086F             0034       include "fixed168.inc"
04086F             0001*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
04086F             0002*  ; uses EZ80 MLT instruction for speed
04086F             0003*  ; operation: UHL * A --> UHL
04086F             0004*  ; destroys: AF, HL
04086F             0005*  smul24x8:
04086F             0006*  ; make hl positive and store sign flag
04086F CD 7E 07 04 0007*      call hlu_abs
040873 F5          0008*      push af
040874             0009*  ; do the division
040874 CD 7F 08 04 0010*      call mul24x8 ; hl = product
040878             0011*  ; adjust sign of result
040878 F1          0012*      pop af ; sign de
040879 F0          0013*      ret p ; hl was positive, nothing to do
04087A CD 8E 07 04 0014*      call neg_hlu ; result is negative
04087E C9          0015*      ret
04087F             0016*  
04087F             0017*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
04087F             0018*  ; uses EZ80 MLT instruction for speed
04087F             0019*  ; operation: UHL * A --> AUHL
04087F             0020*  ; destroys: AF, HL
04087F             0021*  mul24x8:
04087F D5          0022*      push de ; preserve de
040880             0023*  ; low byte
040880 5D          0024*      ld e,l
040881 57          0025*      ld d,a
040882 ED 5C       0026*      mlt de
040884 6B          0027*      ld l,e ; product low byte
040885 08          0028*      ex af,af' ; save multiplier
040886 7A          0029*      ld a,d ; carry
040887 08          0030*      ex af,af' ; save carry, restore multiplier
040888             0031*  ; high byte
040888 5C          0032*      ld e,h
040889 57          0033*      ld d,a
04088A ED 5C       0034*      mlt de
04088C 08          0035*      ex af,af' ; save multiplier, restore carry
04088D 83          0036*      add a,e ; add carry
04088E 67          0037*      ld h,a ; product middle byte
04088F 7A          0038*      ld a,d ; carry
040890 08          0039*      ex af,af' ; save carry, restore multiplier
040891             0040*  ; upper byte
040891 22 AC 08 04 0041*      ld (@scratch),hl ; 7 cycles
040895 5F          0042*      ld e,a
040896 3A AE 08 04 0043*      ld a,(@scratch+2)
04089A 57          0044*      ld d,a
04089B ED 5C       0045*      mlt de
04089D 08          0046*      ex af,af' ; restore carry
04089E 8B          0047*      adc a,e ; add carry
04089F 32 AE 08 04 0048*      ld (@scratch+2),a ; 5 cycles
0408A3 2A AC 08 04 0049*      ld hl,(@scratch) ; 7 cycles
0408A7             0050*  ; highest byte
0408A7 3E 00       0051*      ld a,0 ; preserve carry flag
0408A9 8A          0052*      adc a,d ; product highest byte
0408AA D1          0053*      pop de ; restore de
0408AB C9          0054*      ret
0408AC             0055*  @scratch: ds 3
0408AF             0056*  
0408AF 00 00 00 00 0057*  mul24out: blkb 6,0
       00 00       
0408B5             0058*  
0408B5             0059*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0408B5             0060*  ; operation: UHL * UDE --> mul24out
0408B5             0061*  mul24:
0408B5 DD E5       0062*      push ix ; preserve
0408B7             0063*  ; point to output buffer and clear it
0408B7 DD 21 AF 08 0064*      ld ix,mul24out
       04          
0408BC C5          0065*      push bc
0408BD 01 00 00 00 0066*      ld bc,0
0408C1 DD 0F 00    0067*      ld (ix),bc
0408C4 DD 0F 03    0068*      ld (ix+3),bc
0408C7 C1          0069*      pop bc
0408C8             0070*  ; STEP 1: UHL * E
0408C8 7B          0071*      ld a,e
0408C9 E5          0072*      push hl
0408CA CD 7F 08 04 0073*      call mul24x8
0408CE DD 2F 00    0074*      ld (ix+0),hl
0408D1 DD 77 03    0075*      ld (ix+3),a
0408D4             0076*  ; STEP 2: UHL * D
0408D4 E1          0077*      pop hl
0408D5 E5          0078*      push hl
0408D6 7A          0079*      ld a,d
0408D7 CD 7F 08 04 0080*      call mul24x8
0408DB CD F4 08 04 0081*      call @accumulate
0408DF             0082*  ; STEP 3: UHL * DEU
0408DF E1          0083*      pop hl
0408E0 ED 53 24 09 0084*      ld (@de),de
       04          
0408E5 3A 26 09 04 0085*      ld a,(@de+2)
0408E9 CD 7F 08 04 0086*      call mul24x8
0408ED CD F4 08 04 0087*      call @accumulate
0408F1             0088*  ; all done
0408F1 DD E1       0089*      pop ix ; restore
0408F3 C9          0090*      ret
0408F4             0091*  @accumulate:
0408F4 DD 23       0092*      inc ix
0408F6             0093*  ; highest byte of product to carry
0408F6 DD 77 03    0094*      ld (ix+3),a
0408F9             0095*  ; low byte of product
0408F9 7D          0096*      ld a,l
0408FA DD 86 00    0097*      add a,(ix+0)
0408FD DD 77 00    0098*      ld (ix+0),a
040900             0099*  ; high byte of product
040900 7C          0100*      ld a,h
040901 DD 8E 01    0101*      adc a,(ix+1)
040904 DD 77 01    0102*      ld (ix+1),a
040907             0103*  ; uppper byte of product
040907 22 21 09 04 0104*      ld (@hl),hl
04090B 3A 23 09 04 0105*      ld a,(@hl+2)
04090F DD 8E 02    0106*      adc a,(ix+2)
040912 DD 77 02    0107*      ld (ix+2),a
040915             0108*  ; carry
040915 3E 00       0109*      ld a,0 ; preserve flags
040917 DD 8E 03    0110*      adc a,(ix+3)
04091A DD 77 03    0111*      ld (ix+3),a
04091D C9          0112*      ret
04091E             0113*  
04091E 00 00 00    0114*  @ix: dl 0
040921 00 00 00    0115*  @hl: dl 0
040924 00 00 00    0116*  @de: dl 0
040927             0117*  
040927             0118*  ; UHL * UDE --> UHL (unsigned)
040927             0119*  umul24:
040927 CD B5 08 04 0120*      call mul24
04092B 2A AF 08 04 0121*      ld hl,(mul24out)
04092F C9          0122*      ret
040930             0123*  
040930             0124*  ; UH.L = UH.L*UD.E (unsigned)
040930             0125*  umul168:
040930 CD B5 08 04 0126*      call mul24
040934 2A B0 08 04 0127*      ld hl,(mul24out+1)
040938 C9          0128*      ret
040939             0129*  
040939             0130*  ; UH.L * UD.E --> UH.L (signed)
040939             0131*  smul168:
040939             0132*  ; make everything positive and store sign flags
040939 CD 7E 07 04 0133*      call hlu_abs
04093D F5          0134*      push af
04093E EB          0135*      ex de,hl
04093F CD 7E 07 04 0136*      call hlu_abs
040943 EB          0137*      ex de,hl
040944 F5          0138*      push af
040945             0139*  ; do the division
040945 CD 30 09 04 0140*      call umul168 ; hl = product
040949             0141*  ; adjust sign of result
040949 F1          0142*      pop af ; sign de
04094A FA 55 09 04 0143*      jp m,@de_neg
04094E F1          0144*      pop af ; sign hl
04094F F0          0145*      ret p ; both positive, nothing to do
040950             0146*  @hl_neg:
040950 CD 8E 07 04 0147*      call neg_hlu ; de pos, hl neg, result is negative
040954 C9          0148*      ret
040955             0149*  @de_neg:
040955 F1          0150*      pop af
040956 F8          0151*      ret m ; both negative, nothing to do
040957 CD 8E 07 04 0152*      call neg_hlu ; result is negative
04095B C9          0153*      ret
04095C             0154*  
04095C             0155*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
04095C             0156*  ; perform unsigned division of 16.8 fixed place values
04095C             0157*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
04095C             0158*  udiv168:
04095C             0159*  ; back up divisor
04095C ED 53 93 09 0160*      ld (@ude),de
       04          
040961             0161*  ; get the 16-bit integer part of the quotient
040961 CD 8E 06 04 0162*      call udiv24 ; de = quotient, hl = remainder
040965             0163*  ; load quotient to upper three bytes of output
040965 ED 53 9A 09 0164*      ld (div168_out+1),de
       04          
04096A             0165*  @div256:
04096A             0166*  ; multiply remainder by 256
04096A             0167*      hlu_mul256
04096A 29          0001*M     add hl,hl ; * 2
04096B 29          0002*M     add hl,hl ; * 4
04096C 29          0003*M     add hl,hl ; * 8
04096D 29          0004*M     add hl,hl ; * 16
04096E 29          0005*M     add hl,hl ; * 32
04096F 29          0006*M     add hl,hl ; * 64
040970 29          0007*M     add hl,hl ; * 128
040971 29          0008*M     add hl,hl ; * 256
040972             0168*  ; skip fractional computation if remainder is zero
040972             0169*      sign_hlu
040972 19          0001*M     add hl,de
040973 B7          0002*M     or a ; clear flags
040974 ED 52       0003*M     sbc hl,de
040976 20 03       0170*      jr nz,@div_frac
040978 AF          0171*      xor a
040979 18 0A       0172*      jr @write_frac
04097B             0173*  ; now divide the shifted remainder by the divisor
04097B             0174*  @div_frac:
04097B ED 5B 93 09 0175*      ld de,(@ude) ; get back divisor
       04          
040980 CD 8E 06 04 0176*      call udiv24 ; de = quotient, hl = remainder
040984             0177*  ; load low byte of quotient to low byte of output
040984 7B          0178*      ld a,e
040985             0179*  @write_frac:
040985 32 99 09 04 0180*      ld (div168_out),a
040989             0181*  ; load de with return value
040989 ED 5B 99 09 0182*      ld de,(div168_out)
       04          
04098E             0183*  ; load a with any overflow
04098E 3A 9C 09 04 0184*      ld a,(div168_out+3)
040992 C9          0185*      ret ; ud.e is the 16.8 result
040993             0186*  @ude: ds 6
040999             0187*  div168_out: ds 4 ; the extra byte is for overflow
04099D             0188*  
04099D             0189*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
04099D             0190*  ; perform signed division of 16.8 fixed place values
04099D             0191*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
04099D             0192*  sdiv168:
04099D             0193*  ; make everything positive and store sign flags
04099D CD 7E 07 04 0194*      call hlu_abs
0409A1 F5          0195*      push af
0409A2 EB          0196*      ex de,hl
0409A3 CD 7E 07 04 0197*      call hlu_abs
0409A7 EB          0198*      ex de,hl
0409A8 F5          0199*      push af
0409A9             0200*  ; do the division
0409A9 CD 5C 09 04 0201*      call udiv168 ; de = quotient, hl = remainder
0409AD             0202*  ; adjust sign of result
0409AD F1          0203*      pop af ; sign de
0409AE FA BB 09 04 0204*      jp m,@de_neg
0409B2 F1          0205*      pop af ; sign hl
0409B3 F0          0206*      ret p ; both positive, nothing to do
0409B4             0207*  @hl_neg:
0409B4 EB          0208*      ex de,hl ; hl = quotient, de = remainder
0409B5 CD 8E 07 04 0209*      call neg_hlu ; de pos, hl neg, result is negative
0409B9 EB          0210*      ex de,hl ; de = negated quotient, hl = remainder
0409BA C9          0211*      ret
0409BB             0212*  @de_neg:
0409BB F1          0213*      pop af
0409BC F8          0214*      ret m ; both negative, nothing to do
0409BD EB          0215*      ex de,hl ; hl = quotient, de = remainder
0409BE CD 8E 07 04 0216*      call neg_hlu ; result is negative
0409C2 EB          0217*      ex de,hl ; de = negated quotient, hl = remainder
0409C3 C9          0218*      ret
0409C4             0219*  
0409C4             0220*  ; convert signed angles from a 360 to 256 degree circle
0409C4             0221*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0409C4             0222*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0409C4             0223*  ; destroys: TODO
0409C4             0224*  deg_360_to_256:
0409C4 D5          0225*      push de ; preserve de
0409C5             0226*  ; make angle positive and store sign flag
0409C5 CD 7E 07 04 0227*      call hlu_abs
0409C9 F5          0228*      push af
0409CA             0229*  ; multiply by coversion factor of 256/360
0409CA 11 B6 00 00 0230*      ld de,0x0000B6 ; 0.711
0409CE CD 30 09 04 0231*      call umul168 ; uh.l = uh.l * 0.711
0409D2             0232*  ; restore sign flag and adjust output accordingly
0409D2 F1          0233*      pop af
0409D3 F2 DB 09 04 0234*      jp p,@pos ; positive number
0409D7 CD 8E 07 04 0235*      call neg_hlu
0409DB             0236*  @pos:
0409DB             0237*  ; restore de and return uh.l as the result
0409DB D1          0238*      pop de
0409DC C9          0239*      ret
0409DD             0240*  
0409DD             0241*  ; convert signed angles from a 256 to 360 degree circle
0409DD             0242*  ; inputs: uh.l is the angle256 in 16.8 fixed format
0409DD             0243*  ; outputs: uh.l is the angle360 in 16.8 fixed format
0409DD             0244*  ; destroys: TODO
0409DD             0245*  deg_256_to_360:
0409DD D5          0246*      push de ; preserve de
0409DE             0247*  ; make angle positive and store sign flag
0409DE CD 7E 07 04 0248*      call hlu_abs
0409E2 F5          0249*      push af
0409E3             0250*  ; multiply by coversion factor of 360/256
0409E3 11 68 01 00 0251*      ld de,0x000168 ; 1.406
0409E7 CD 30 09 04 0252*      call umul168 ; uh.l = uh.l * 1.406
0409EB             0253*  ; restore sign flag and adjust output accordingly
0409EB F1          0254*      pop af
0409EC F2 F4 09 04 0255*      jp p,@pos ; positive number
0409F0 CD 8E 07 04 0256*      call neg_hlu
0409F4             0257*  @pos:
0409F4             0258*  ; restore de and return uh.l as the result
0409F4 D1          0259*      pop de
0409F5 C9          0260*      ret
0409F6             0261*  
0409F6             0262*  ; fixed 16.8 routine
0409F6             0263*  ; cos(uh.l) --> uh.l
0409F6             0264*  ; destroys: f, hl
0409F6             0265*  cos168:
0409F6 D5          0266*      push de ; preserve de
0409F7             0267*  ; for cos we simply increment the angle by 90 degrees
0409F7             0268*  ; or 0x004000 in 16.8 degrees256
0409F7             0269*  ; which makes it a sin problem
0409F7 11 00 40 00 0270*      ld de,0x004000
0409FB 19          0271*      add hl,de ; modulo 256 happens below
0409FC D1          0272*      pop de ; restore de
0409FD             0273*  ; fall through to sin168
0409FD             0274*  
0409FD             0275*  ; ---------------------
0409FD             0276*  ; fixed 16.8 routine
0409FD             0277*  ; sin(uh.l) --> uh.l
0409FD             0278*  ; destroys: f, hl
0409FD             0279*  sin168:
0409FD D5          0280*      push de
0409FE             0281*  ; handle negative angles appropriately
0409FE CD 7E 07 04 0282*      call hlu_abs
040A02 F2 0B 0A 04 0283*      jp p,@F
040A06 11 00 00 FF 0284*      ld de,-256*256
040A0A 19          0285*      add hl,de
040A0B             0286*  @@:
040A0B 2E 03       0287*      ld l,3 ; multiply by 3 to get our lookup index
040A0D ED 6C       0288*      mlt hl
040A0F 11 5A 0C 04 0289*      ld de,sin_lut_168 ; grab the lut address
040A13 19          0290*      add hl,de ; bump hl by the index
040A14 ED 27       0291*      ld hl,(hl) ; don't try this on a z80!
040A16 D1          0292*      pop de
040A17 C9          0293*      ret
040A18             0294*  
040A18             0295*  ; 16.8 fixed inputs / outputs
040A18             0296*  ; takes: uh.l as angle in degrees 256
040A18             0297*  ;        ud.e as radius
040A18             0298*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040A18             0299*  ;        displacements from origin (0,0)
040A18             0300*  ; destroys: everything except indexes
040A18             0301*  polar_to_cartesian:
040A18             0302*  ; back up input parameters
040A18 22 47 0A 04 0303*      ld (@angle), hl
040A1C ED 53 4A 0A 0304*      ld (@radius), de
       04          
040A21             0305*  ; compute dx = sin(uh.l) * ud.e
040A21 CD FD 09 04 0306*      call sin168 ; uh.l = sin(uh.l)
040A25 ED 5B 4A 0A 0307*      ld de,(@radius)
       04          
040A2A CD 39 09 04 0308*      call smul168 ; uh.l = dx
040A2E E5          0309*      push hl
040A2F             0310*  ; compute dy = -cos(uh.l) * ud.e
040A2F 2A 47 0A 04 0311*      ld hl,(@angle)
040A33 CD F6 09 04 0312*      call cos168 ; uh.l = cos(uh.l)
040A37 ED 5B 4A 0A 0313*      ld de,(@radius)
       04          
040A3C CD 39 09 04 0314*      call smul168 ; uh.l = dy
040A40 CD 8E 07 04 0315*      call neg_hlu ; invert dy for screen coords convention
040A44 EB          0316*      ex de,hl ; de = dy for output
040A45 C1          0317*      pop bc ; bc = dx for output
040A46             0318*  ; and out
040A46 C9          0319*      ret
040A47             0320*  @angle: ds 3
040A4A             0321*  @radius: ds 3
040A4D             0322*  
040A4D             0323*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040A4D             0324*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040A4D             0325*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040A4D             0326*  ;         also populates scratch locations dx168 and dy168
040A4D             0327*  ; destroys: a,hl,bc,de
040A4D             0328*  dxy168:
040A4D             0329*  ; compute dx = x1-x0
040A4D AF          0330*      xor a ; clear carry
040A4E DD E5       0331*      push ix ; move ix to hl via the stack
040A50 E1          0332*      pop hl ; hl = x1
040A51 ED 42       0333*      sbc hl,bc ; hl = dx
040A53 22 68 0A 04 0334*      ld (dx168),hl ; dx to scratch
040A57             0335*  ; compute dy = y1-y0
040A57 AF          0336*      xor a ; clear carry
040A58 FD E5       0337*      push iy ; move iy to hl via the stack
040A5A E1          0338*      pop hl ; hl = y1
040A5B ED 52       0339*      sbc hl,de ; hl = dy
040A5D 22 6E 0A 04 0340*      ld (dy168),hl ; dy to scratch
040A61             0341*  ; populate output registers and return
040A61 EB          0342*      ex de,hl ; ud.e = dy
040A62 ED 4B 68 0A 0343*      ld bc,(dx168) ; ub.c = dx
       04          
040A67 C9          0344*      ret
040A68 00 00 00 00 0345*  dx168: blkb 6,0
       00 00       
040A6E 00 00 00 00 0346*  dy168: blkb 6,0
       00 00       
040A74             0347*  
040A74             0348*  ; compute the euclidian distance between two cartesian coordinates
040A74             0349*  ; using the formula d = sqrt(dx^2+dy^2)
040A74             0350*  ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040A74             0351*  ; output; uh.l is the 16.8 fixed format distance
040A74             0352*  ;         also populates scratch locations dx168 and dy168
040A74             0353*  ; destroys: a,hl,bc,de
040A74             0354*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
040A74             0355*  ;       thus the result will always be an integer, albeit in 16.8 format
040A74             0356*  distance168:
040A74             0357*  ; compute dy^2
040A74 2A 6E 0A 04 0358*      ld hl,(dy168)
040A78 CD 7E 07 04 0359*      call hlu_abs
040A7C CD E5 07 04 0360*      call hlu_udiv256 ; make integer to avoid overflow
040A80 E5          0361*      push hl
040A81 D1          0362*      pop de
040A82 CD 27 09 04 0363*      call umul24 ; hl = dy^2
040A86 E5          0364*      push hl ; save dy^2
040A87             0365*  ; compute dx^2
040A87 2A 68 0A 04 0366*      ld hl,(dx168)
040A8B CD 7E 07 04 0367*      call hlu_abs
040A8F CD E5 07 04 0368*      call hlu_udiv256 ; make integer to avoid overflow
040A93 E5          0369*      push hl
040A94 D1          0370*      pop de
040A95 CD 27 09 04 0371*      call umul24 ; hl = dx^2
040A99             0372*  ; add dx^2 and dy^2
040A99 D1          0373*      pop de ; de = dy^2 (was hl)
040A9A 19          0374*      add hl,de ; hl = dx^2 + dy^2
040A9B             0375*  ; compute the square root
040A9B CD 74 0B 04 0376*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
040A9F EB          0377*      ex de,hl ; hl = distance
040AA0             0378*      hlu_mul256 ; convert back to 16.8 fixed
040AA0 29          0001*M     add hl,hl ; * 2
040AA1 29          0002*M     add hl,hl ; * 4
040AA2 29          0003*M     add hl,hl ; * 8
040AA3 29          0004*M     add hl,hl ; * 16
040AA4 29          0005*M     add hl,hl ; * 32
040AA5 29          0006*M     add hl,hl ; * 64
040AA6 29          0007*M     add hl,hl ; * 128
040AA7 29          0008*M     add hl,hl ; * 256
040AA8 C9          0379*      ret
040AA9             0380*  
040AA9             0381*  ; atan2_(ub.c,ud.e) --> uh.l
040AA9             0382*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040AA9             0383*  ;   whether inputs are integers or fractional doesn't matter
040AA9             0384*  ;   so long as the sign bit of the upper byte is correct
040AA9             0385*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040AA9             0386*  ; angles are COMPASS HEADINGS based on
040AA9             0387*  ; screen coordinate conventions,where the y axis is flipped
040AA9             0388*  ; #E0 224      0       32 #20
040AA9             0389*  ;        -x,-y | +x,-y
040AA9             0390*  ; #C0 192------+------ 64 #40
040AA9             0391*  ;        -x,+y | +x,+y
040AA9             0392*  ; #A0 160   128 #80   96 #60
040AA9             0393*  atan2_168fast:
040AA9             0394*  ; get signs and make everything positive
040AA9             0395*  ; get abs(x) and store its original sign
040AA9 C5          0396*      push bc
040AAA E1          0397*      pop hl
040AAB CD 7E 07 04 0398*      call hlu_abs ; if x was negative this also sets the sign flag
040AAF E5          0399*      push hl ; store abs(x)
040AB0 C1          0400*      pop bc ; bc = abs(x)
040AB1 F5          0401*      push af ; store sign of x
040AB2             0402*  ; get abs(y) and store its original sign
040AB2 EB          0403*      ex de,hl ; hl = y
040AB3 CD 7E 07 04 0404*      call hlu_abs ; if y was negative this also sets the sign flag
040AB7 EB          0405*      ex de,hl ; de = abs(y)
040AB8 F5          0406*      push af ; store sign of y
040AB9             0407*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040AB9             0408*  ; this ensures that our lookup value is between 0 and 1 inclusive
040AB9 AF          0409*      xor a ; clear the carry flag
040ABA D5          0410*      push de
040ABB E1          0411*      pop hl
040ABC ED 42       0412*      sbc hl,bc
040ABE F5          0413*      push af ; save sign of de - bc
040ABF F2 C8 0A 04 0414*      jp p,@1 ; bc <= de, so we skip ahead
040AC3             0415*  ; otherwise we swap bc and de
040AC3 C5          0416*      push bc
040AC4 E1          0417*      pop hl
040AC5 EB          0418*      ex de,hl
040AC6 E5          0419*      push hl
040AC7 C1          0420*      pop bc
040AC8             0421*  @1:
040AC8             0422*  ; now we're ready to snag our preliminary result
040AC8 C5          0423*      push bc
040AC9 E1          0424*      pop hl
040ACA CD 38 0B 04 0425*      call atan_168fast ; uh.l comes back with prelim result
040ACE             0426*  ; now we adjust uh.l based on sign of de - bc
040ACE F1          0427*      pop af
040ACF F2 DB 0A 04 0428*      jp p,@2 ; bc <= de,so we skip ahead
040AD3 EB          0429*      ex de,hl
040AD4 21 00 40 00 0430*      ld hl,64*256 ; subtract from 64 (90) degrees
040AD8 AF          0431*      xor a ; clear the carry flag
040AD9 ED 52       0432*      sbc hl,de
040ADB             0433*  @2:
040ADB             0434*  ; adjust the result based on quadrant
040ADB             0435*  ; #E0 224      0       32 #20
040ADB             0436*  ;        -x,-y | +x,-y
040ADB             0437*  ; #C0 192------+------ 64 #40
040ADB             0438*  ;        -x,+y | +x,+y
040ADB             0439*  ; #A0 160   128 #80   96 #60
040ADB F1          0440*      pop af ; sign of y
040ADC CA 19 0B 04 0441*      jp z,@y_zero
040AE0 F2 F9 0A 04 0442*      jp p,@y_pos
040AE4             0443*  ; y neg,check x
040AE4 F1          0444*      pop af ; sign of x
040AE5 CA F3 0A 04 0445*      jp z,@y_neg_x_zero
040AE9 F2 F8 0A 04 0446*      jp p,@y_neg_x_pos
040AED             0447*  ; y neg,x neg
040AED             0448*  ; angle is 128 to 256 (270 to 360)
040AED             0449*  ; negating the intermediate does the trick
040AED CD 8E 07 04 0450*      call neg_hlu
040AF1 18 31       0451*      jr @zero_hlu
040AF3             0452*  
040AF3             0453*  @y_neg_x_zero:
040AF3             0454*  ; y neg,x zero
040AF3             0455*  ; angle is 0
040AF3 21 00 00 00 0456*      ld hl,0
040AF7 C9          0457*      ret
040AF8             0458*  @y_neg_x_pos:
040AF8             0459*  ; y neg,x pos
040AF8             0460*  ; angle is 0 to 64 (0 to 90)
040AF8             0461*  ; so we're good
040AF8 C9          0462*      ret
040AF9             0463*  
040AF9             0464*  @y_pos:
040AF9 F1          0465*      pop af ; sign of x
040AFA CA 09 0B 04 0466*      jp z,@y_pos_x_zero
040AFE F2 0E 0B 04 0467*      jp p,@y_pos_x_pos
040B02             0468*  ; y pos,x neg
040B02             0469*  ; angle is 128 to 192 (180-270)
040B02             0470*  ; so we add 128 to intermediate
040B02 11 00 80 00 0471*      ld de,128*256
040B06 19          0472*      add hl,de
040B07 18 1B       0473*      jr @zero_hlu
040B09             0474*  @y_pos_x_zero:
040B09             0475*  ; y pos,x zero
040B09             0476*  ; angle is 128 (180)
040B09 21 00 80 00 0477*      ld hl,128*256
040B0D C9          0478*      ret
040B0E             0479*  @y_pos_x_pos:
040B0E             0480*  ; y pos,x pos
040B0E             0481*  ; angle is 64 to 128 (90 to 180)
040B0E             0482*  ; neg the intermediate and add 180 degrees
040B0E CD 8E 07 04 0483*      call neg_hlu
040B12 11 00 80 00 0484*      ld de,128*256
040B16 19          0485*      add hl,de
040B17 18 0B       0486*      jr @zero_hlu
040B19             0487*  
040B19             0488*  @y_zero:
040B19 F1          0489*      pop af ; sign of x
040B1A FA 1F 0B 04 0490*      jp m,@y_zero_x_neg
040B1E             0491*  ; y zero,x pos
040B1E             0492*  ; angle is 64 (90),nothing to do
040B1E C9          0493*      ret
040B1F             0494*  @y_zero_x_neg:
040B1F             0495*  ; y zero ,x neg
040B1F             0496*  ; angle is 192 (270)
040B1F 21 00 C0 00 0497*      ld hl,192*256
040B23 C9          0498*      ret
040B24             0499*  @zero_hlu:
040B24 AF          0500*      xor a
040B25 22 32 0B 04 0501*      ld (@scratch),hl
040B29 32 34 0B 04 0502*      ld (@scratch+2),a
040B2D 2A 32 0B 04 0503*      ld hl,(@scratch)
040B31 C9          0504*      ret
040B32             0505*  @scratch: ds 6
040B38             0506*  
040B38             0507*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040B38             0508*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040B38             0509*  ; destroys: a,hl,bc,de
040B38             0510*  ; note: only works for angles from 0 to 32 (45) degrees
040B38             0511*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040B38             0512*  atan_168fast:
040B38             0513*  ; because we use compass headings instead of geometric angles
040B38             0514*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040B38             0515*  ; we can do faster unsigned division here because we know dx and dy are positive
040B38 CD 5C 09 04 0516*      call udiv168 ; ud.e = dx/dy
040B3C EB          0517*      ex de,hl ; uh.l = dx/dy
040B3D             0518*  ; test uh.l for 0
040B3D 19          0519*      add hl,de
040B3E B7          0520*      or a
040B3F ED 52       0521*      sbc hl,de
040B41 28 22       0522*      jr z,@is_zero
040B43             0523*  ; test uh.l for 1
040B43 AF          0524*      xor a ; clear carry
040B44 EB          0525*      ex de,hl
040B45 21 00 01 00 0526*      ld hl,1*256 ; 1 in 16.8 fixed format
040B49 ED 52       0527*      sbc hl,de
040B4B 28 13       0528*      jr z,@is_45
040B4D EB          0529*      ex de,hl
040B4E             0530*  ; no special cases so we move on
040B4E             0531*  ; l contains the fractional portion of tan(uh.l)
040B4E             0532*  ; we multiply it by three to get our lookup table index
040B4E 26 03       0533*      ld h,3
040B50 ED 6C       0534*      mlt hl ; index into lut
040B52 11 00 00 00 0535*      ld de,0 ; clear deu
040B56 54          0536*      ld d,h ; copy hl to de
040B57 5D          0537*      ld e,l ; de contains our index
040B58 21 5D 0F 04 0538*      ld hl,atan_lut_168 ; grab the lut address
040B5C 19          0539*      add hl,de ; bump hl by the index
040B5D ED 27       0540*      ld hl,(hl) ; don't try this on a z80!
040B5F C9          0541*      ret ; and out
040B60             0542*  @is_45:
040B60 21 00 40 00 0543*      ld hl,64*256
040B64 C9          0544*      ret
040B65             0545*  ; for the case tan(0)
040B65             0546*  @is_zero:
040B65 21 00 00 00 0547*      ld hl,0*256
040B69 C9          0548*      ret
040B6A             0549*  
040B6A             0550*  ; Expects  ADL mode
040B6A             0551*  ; Inputs:  UH.L
040B6A             0552*  ; Outputs: UH.L is the 16.8 square root
040B6A             0553*  ;          UDE is the integer difference inputHL-DE^2
040B6A             0554*  sqrt168:
040B6A CD 74 0B 04 0555*      call sqrt24
040B6E EB          0556*      ex de,hl
040B6F 29          0557*      add hl,hl
040B70 29          0558*      add hl,hl
040B71 29          0559*      add hl,hl
040B72 29          0560*      add hl,hl
040B73 C9          0561*      ret
040B74             0562*  
040B74             0563*  ; credit: xeda112358
040B74             0564*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040B74             0565*  sqrt24:
040B74             0566*  ; Expects ADL mode
040B74             0567*  ; Inputs: HL
040B74             0568*  ; Outputs: DE is the integer square root
040B74             0569*  ;  HL is the difference inputHL-DE^2
040B74             0570*  ;  c flag reset
040B74 01 00 00 00 0571*      ld bc,0 ; clear bcu
040B78 11 00 00 00 0572*      ld de,0 ; clear deu
040B7C AF          0573*      xor a
040B7D 45          0574*      ld b,l
040B7E C5          0575*      push bc
040B7F 47          0576*      ld b,a
040B80 6F          0577*      ld l,a
040B81             0578*  ; Iteration 1
040B81 29          0579*      add hl,hl
040B82 CB 11       0580*      rl c
040B84 29          0581*      add hl,hl
040B85 CB 11       0582*      rl c
040B87 91          0583*      sub c
040B88 30 04       0584*      jr nc,$+6
040B8A 1C          0585*      inc e
040B8B 1C          0586*      inc e
040B8C 2F          0587*      cpl
040B8D 4F          0588*      ld c,a
040B8E             0589*  ; Iteration 2
040B8E 29          0590*      add hl,hl
040B8F CB 11       0591*      rl c
040B91 29          0592*      add hl,hl
040B92 CB 11       0593*      rl c
040B94 CB 13       0594*      rl e
040B96 7B          0595*      ld a,e
040B97 91          0596*      sub c
040B98 30 04       0597*      jr nc,$+6
040B9A 1C          0598*      inc e
040B9B 1C          0599*      inc e
040B9C 2F          0600*      cpl
040B9D 4F          0601*      ld c,a
040B9E             0602*  ; Iteration 3
040B9E 29          0603*      add hl,hl
040B9F CB 11       0604*      rl c
040BA1 29          0605*      add hl,hl
040BA2 CB 11       0606*      rl c
040BA4 CB 13       0607*      rl e
040BA6 7B          0608*      ld a,e
040BA7 91          0609*      sub c
040BA8 30 04       0610*      jr nc,$+6
040BAA 1C          0611*      inc e
040BAB 1C          0612*      inc e
040BAC 2F          0613*      cpl
040BAD 4F          0614*      ld c,a
040BAE             0615*  ; Iteration 4
040BAE 29          0616*      add hl,hl
040BAF CB 11       0617*      rl c
040BB1 29          0618*      add hl,hl
040BB2 CB 11       0619*      rl c
040BB4 CB 13       0620*      rl e
040BB6 7B          0621*      ld a,e
040BB7 91          0622*      sub c
040BB8 30 04       0623*      jr nc,$+6
040BBA 1C          0624*      inc e
040BBB 1C          0625*      inc e
040BBC 2F          0626*      cpl
040BBD 4F          0627*      ld c,a
040BBE             0628*  ; Iteration 5
040BBE 29          0629*      add hl,hl
040BBF CB 11       0630*      rl c
040BC1 29          0631*      add hl,hl
040BC2 CB 11       0632*      rl c
040BC4 CB 13       0633*      rl e
040BC6 7B          0634*      ld a,e
040BC7 91          0635*      sub c
040BC8 30 04       0636*      jr nc,$+6
040BCA 1C          0637*      inc e
040BCB 1C          0638*      inc e
040BCC 2F          0639*      cpl
040BCD 4F          0640*      ld c,a
040BCE             0641*  ; Iteration 6
040BCE 29          0642*      add hl,hl
040BCF CB 11       0643*      rl c
040BD1 29          0644*      add hl,hl
040BD2 CB 11       0645*      rl c
040BD4 CB 13       0646*      rl e
040BD6 7B          0647*      ld a,e
040BD7 91          0648*      sub c
040BD8 30 04       0649*      jr nc,$+6
040BDA 1C          0650*      inc e
040BDB 1C          0651*      inc e
040BDC 2F          0652*      cpl
040BDD 4F          0653*      ld c,a
040BDE             0654*  ; Iteration 7
040BDE 29          0655*      add hl,hl
040BDF CB 11       0656*      rl c
040BE1 29          0657*      add hl,hl
040BE2 CB 11       0658*      rl c
040BE4 CB 10       0659*      rl b
040BE6 EB          0660*      ex de,hl
040BE7 29          0661*      add hl,hl
040BE8 E5          0662*      push hl
040BE9 ED 42       0663*      sbc hl,bc
040BEB 30 06       0664*      jr nc,$+8
040BED 7C          0665*      ld a,h
040BEE 2F          0666*      cpl
040BEF 47          0667*      ld b,a
040BF0 7D          0668*      ld a,l
040BF1 2F          0669*      cpl
040BF2 4F          0670*      ld c,a
040BF3 E1          0671*      pop hl
040BF4 30 02       0672*      jr nc,$+4
040BF6 23          0673*      inc hl
040BF7 23          0674*      inc hl
040BF8 EB          0675*      ex de,hl
040BF9             0676*  ; Iteration 8
040BF9 29          0677*      add hl,hl
040BFA 69          0678*      ld l,c
040BFB 60          0679*      ld h,b
040BFC ED 6A       0680*      adc hl,hl
040BFE ED 6A       0681*      adc hl,hl
040C00 EB          0682*      ex de,hl
040C01 29          0683*      add hl,hl
040C02 ED 52       0684*      sbc hl,de
040C04 19          0685*      add hl,de
040C05 EB          0686*      ex de,hl
040C06 30 04       0687*      jr nc,$+6
040C08 ED 52       0688*      sbc hl,de
040C0A 13          0689*      inc de
040C0B 13          0690*      inc de
040C0C             0691*  ; Iteration 9
040C0C F1          0692*      pop af
040C0D 17          0693*      rla
040C0E ED 6A       0694*      adc hl,hl
040C10 17          0695*      rla
040C11 ED 6A       0696*      adc hl,hl
040C13 EB          0697*      ex de,hl
040C14 29          0698*      add hl,hl
040C15 ED 52       0699*      sbc hl,de
040C17 19          0700*      add hl,de
040C18 EB          0701*      ex de,hl
040C19 30 04       0702*      jr nc,$+6
040C1B ED 52       0703*      sbc hl,de
040C1D 13          0704*      inc de
040C1E 13          0705*      inc de
040C1F             0706*  ; Iteration 10
040C1F 17          0707*      rla
040C20 ED 6A       0708*      adc hl,hl
040C22 17          0709*      rla
040C23 ED 6A       0710*      adc hl,hl
040C25 EB          0711*      ex de,hl
040C26 29          0712*      add hl,hl
040C27 ED 52       0713*      sbc hl,de
040C29 19          0714*      add hl,de
040C2A EB          0715*      ex de,hl
040C2B 30 04       0716*      jr nc,$+6
040C2D ED 52       0717*      sbc hl,de
040C2F 13          0718*      inc de
040C30 13          0719*      inc de
040C31             0720*  ; Iteration 11
040C31 17          0721*      rla
040C32 ED 6A       0722*      adc hl,hl
040C34 17          0723*      rla
040C35 ED 6A       0724*      adc hl,hl
040C37 EB          0725*      ex de,hl
040C38 29          0726*      add hl,hl
040C39 ED 52       0727*      sbc hl,de
040C3B 19          0728*      add hl,de
040C3C EB          0729*      ex de,hl
040C3D 30 04       0730*      jr nc,$+6
040C3F ED 52       0731*      sbc hl,de
040C41 13          0732*      inc de
040C42 13          0733*      inc de
040C43             0734*  ; Iteration 12
040C43 17          0735*      rla
040C44 ED 6A       0736*      adc hl,hl
040C46 17          0737*      rla
040C47 ED 6A       0738*      adc hl,hl
040C49 EB          0739*      ex de,hl
040C4A 29          0740*      add hl,hl
040C4B ED 52       0741*      sbc hl,de
040C4D 19          0742*      add hl,de
040C4E EB          0743*      ex de,hl
040C4F 30 04       0744*      jr nc,$+6
040C51 ED 52       0745*      sbc hl,de
040C53 13          0746*      inc de
040C54 13          0747*      inc de
040C55 CB 1A       0748*      rr d
040C57 CB 1B       0749*      rr e
040C59 C9          0750*      ret
040C5A             0751*  
040C5A             0752*  sin_lut_168:
040C5A 00 00 00    0753*      dl 0x000000 ; 0.000 00, 0.000
040C5D 06 00 00    0754*      dl 0x000006 ; 1.406 01, 0.025
040C60 0C 00 00    0755*      dl 0x00000C ; 2.813 02, 0.049
040C63 12 00 00    0756*      dl 0x000012 ; 4.219 03, 0.074
040C66 19 00 00    0757*      dl 0x000019 ; 5.625 04, 0.098
040C69 1F 00 00    0758*      dl 0x00001F ; 7.031 05, 0.122
040C6C 25 00 00    0759*      dl 0x000025 ; 8.438 06, 0.147
040C6F 2B 00 00    0760*      dl 0x00002B ; 9.844 07, 0.171
040C72 31 00 00    0761*      dl 0x000031 ; 11.250 08, 0.195
040C75 38 00 00    0762*      dl 0x000038 ; 12.656 09, 0.219
040C78 3E 00 00    0763*      dl 0x00003E ; 14.063 0A, 0.243
040C7B 44 00 00    0764*      dl 0x000044 ; 15.469 0B, 0.267
040C7E 4A 00 00    0765*      dl 0x00004A ; 16.875 0C, 0.290
040C81 50 00 00    0766*      dl 0x000050 ; 18.281 0D, 0.314
040C84 56 00 00    0767*      dl 0x000056 ; 19.688 0E, 0.337
040C87 5C 00 00    0768*      dl 0x00005C ; 21.094 0F, 0.360
040C8A 61 00 00    0769*      dl 0x000061 ; 22.500 10, 0.383
040C8D 67 00 00    0770*      dl 0x000067 ; 23.906 11, 0.405
040C90 6D 00 00    0771*      dl 0x00006D ; 25.313 12, 0.428
040C93 73 00 00    0772*      dl 0x000073 ; 26.719 13, 0.450
040C96 78 00 00    0773*      dl 0x000078 ; 28.125 14, 0.471
040C99 7E 00 00    0774*      dl 0x00007E ; 29.531 15, 0.493
040C9C 83 00 00    0775*      dl 0x000083 ; 30.938 16, 0.514
040C9F 88 00 00    0776*      dl 0x000088 ; 32.344 17, 0.535
040CA2 8E 00 00    0777*      dl 0x00008E ; 33.750 18, 0.556
040CA5 93 00 00    0778*      dl 0x000093 ; 35.156 19, 0.576
040CA8 98 00 00    0779*      dl 0x000098 ; 36.563 1A, 0.596
040CAB 9D 00 00    0780*      dl 0x00009D ; 37.969 1B, 0.615
040CAE A2 00 00    0781*      dl 0x0000A2 ; 39.375 1C, 0.634
040CB1 A7 00 00    0782*      dl 0x0000A7 ; 40.781 1D, 0.653
040CB4 AB 00 00    0783*      dl 0x0000AB ; 42.188 1E, 0.672
040CB7 B0 00 00    0784*      dl 0x0000B0 ; 43.594 1F, 0.690
040CBA B5 00 00    0785*      dl 0x0000B5 ; 45.000 20, 0.707
040CBD B9 00 00    0786*      dl 0x0000B9 ; 46.406 21, 0.724
040CC0 BD 00 00    0787*      dl 0x0000BD ; 47.813 22, 0.741
040CC3 C1 00 00    0788*      dl 0x0000C1 ; 49.219 23, 0.757
040CC6 C5 00 00    0789*      dl 0x0000C5 ; 50.625 24, 0.773
040CC9 C9 00 00    0790*      dl 0x0000C9 ; 52.031 25, 0.788
040CCC CD 00 00    0791*      dl 0x0000CD ; 53.438 26, 0.803
040CCF D1 00 00    0792*      dl 0x0000D1 ; 54.844 27, 0.818
040CD2 D4 00 00    0793*      dl 0x0000D4 ; 56.250 28, 0.831
040CD5 D8 00 00    0794*      dl 0x0000D8 ; 57.656 29, 0.845
040CD8 DB 00 00    0795*      dl 0x0000DB ; 59.063 2A, 0.858
040CDB DE 00 00    0796*      dl 0x0000DE ; 60.469 2B, 0.870
040CDE E1 00 00    0797*      dl 0x0000E1 ; 61.875 2C, 0.882
040CE1 E4 00 00    0798*      dl 0x0000E4 ; 63.281 2D, 0.893
040CE4 E7 00 00    0799*      dl 0x0000E7 ; 64.688 2E, 0.904
040CE7 EA 00 00    0800*      dl 0x0000EA ; 66.094 2F, 0.914
040CEA EC 00 00    0801*      dl 0x0000EC ; 67.500 30, 0.924
040CED EE 00 00    0802*      dl 0x0000EE ; 68.906 31, 0.933
040CF0 F1 00 00    0803*      dl 0x0000F1 ; 70.313 32, 0.942
040CF3 F3 00 00    0804*      dl 0x0000F3 ; 71.719 33, 0.950
040CF6 F4 00 00    0805*      dl 0x0000F4 ; 73.125 34, 0.957
040CF9 F6 00 00    0806*      dl 0x0000F6 ; 74.531 35, 0.964
040CFC F8 00 00    0807*      dl 0x0000F8 ; 75.938 36, 0.970
040CFF F9 00 00    0808*      dl 0x0000F9 ; 77.344 37, 0.976
040D02 FB 00 00    0809*      dl 0x0000FB ; 78.750 38, 0.981
040D05 FC 00 00    0810*      dl 0x0000FC ; 80.156 39, 0.985
040D08 FD 00 00    0811*      dl 0x0000FD ; 81.563 3A, 0.989
040D0B FE 00 00    0812*      dl 0x0000FE ; 82.969 3B, 0.992
040D0E FE 00 00    0813*      dl 0x0000FE ; 84.375 3C, 0.995
040D11 FF 00 00    0814*      dl 0x0000FF ; 85.781 3D, 0.997
040D14 FF 00 00    0815*      dl 0x0000FF ; 87.188 3E, 0.999
040D17 FF 00 00    0816*      dl 0x0000FF ; 88.594 3F, 1.000
040D1A 00 01 00    0817*      dl 0x000100 ; 90.000 40, 1.000
040D1D FF 00 00    0818*      dl 0x0000FF ; 91.406 41, 1.000
040D20 FF 00 00    0819*      dl 0x0000FF ; 92.813 42, 0.999
040D23 FF 00 00    0820*      dl 0x0000FF ; 94.219 43, 0.997
040D26 FE 00 00    0821*      dl 0x0000FE ; 95.625 44, 0.995
040D29 FE 00 00    0822*      dl 0x0000FE ; 97.031 45, 0.992
040D2C FD 00 00    0823*      dl 0x0000FD ; 98.438 46, 0.989
040D2F FC 00 00    0824*      dl 0x0000FC ; 99.844 47, 0.985
040D32 FB 00 00    0825*      dl 0x0000FB ; 101.250 48, 0.981
040D35 F9 00 00    0826*      dl 0x0000F9 ; 102.656 49, 0.976
040D38 F8 00 00    0827*      dl 0x0000F8 ; 104.063 4A, 0.970
040D3B F6 00 00    0828*      dl 0x0000F6 ; 105.469 4B, 0.964
040D3E F4 00 00    0829*      dl 0x0000F4 ; 106.875 4C, 0.957
040D41 F3 00 00    0830*      dl 0x0000F3 ; 108.281 4D, 0.950
040D44 F1 00 00    0831*      dl 0x0000F1 ; 109.688 4E, 0.942
040D47 EE 00 00    0832*      dl 0x0000EE ; 111.094 4F, 0.933
040D4A EC 00 00    0833*      dl 0x0000EC ; 112.500 50, 0.924
040D4D EA 00 00    0834*      dl 0x0000EA ; 113.906 51, 0.914
040D50 E7 00 00    0835*      dl 0x0000E7 ; 115.313 52, 0.904
040D53 E4 00 00    0836*      dl 0x0000E4 ; 116.719 53, 0.893
040D56 E1 00 00    0837*      dl 0x0000E1 ; 118.125 54, 0.882
040D59 DE 00 00    0838*      dl 0x0000DE ; 119.531 55, 0.870
040D5C DB 00 00    0839*      dl 0x0000DB ; 120.938 56, 0.858
040D5F D8 00 00    0840*      dl 0x0000D8 ; 122.344 57, 0.845
040D62 D4 00 00    0841*      dl 0x0000D4 ; 123.750 58, 0.831
040D65 D1 00 00    0842*      dl 0x0000D1 ; 125.156 59, 0.818
040D68 CD 00 00    0843*      dl 0x0000CD ; 126.563 5A, 0.803
040D6B C9 00 00    0844*      dl 0x0000C9 ; 127.969 5B, 0.788
040D6E C5 00 00    0845*      dl 0x0000C5 ; 129.375 5C, 0.773
040D71 C1 00 00    0846*      dl 0x0000C1 ; 130.781 5D, 0.757
040D74 BD 00 00    0847*      dl 0x0000BD ; 132.188 5E, 0.741
040D77 B9 00 00    0848*      dl 0x0000B9 ; 133.594 5F, 0.724
040D7A B5 00 00    0849*      dl 0x0000B5 ; 135.000 60, 0.707
040D7D B0 00 00    0850*      dl 0x0000B0 ; 136.406 61, 0.690
040D80 AB 00 00    0851*      dl 0x0000AB ; 137.813 62, 0.672
040D83 A7 00 00    0852*      dl 0x0000A7 ; 139.219 63, 0.653
040D86 A2 00 00    0853*      dl 0x0000A2 ; 140.625 64, 0.634
040D89 9D 00 00    0854*      dl 0x00009D ; 142.031 65, 0.615
040D8C 98 00 00    0855*      dl 0x000098 ; 143.438 66, 0.596
040D8F 93 00 00    0856*      dl 0x000093 ; 144.844 67, 0.576
040D92 8E 00 00    0857*      dl 0x00008E ; 146.250 68, 0.556
040D95 88 00 00    0858*      dl 0x000088 ; 147.656 69, 0.535
040D98 83 00 00    0859*      dl 0x000083 ; 149.063 6A, 0.514
040D9B 7E 00 00    0860*      dl 0x00007E ; 150.469 6B, 0.493
040D9E 78 00 00    0861*      dl 0x000078 ; 151.875 6C, 0.471
040DA1 73 00 00    0862*      dl 0x000073 ; 153.281 6D, 0.450
040DA4 6D 00 00    0863*      dl 0x00006D ; 154.688 6E, 0.428
040DA7 67 00 00    0864*      dl 0x000067 ; 156.094 6F, 0.405
040DAA 61 00 00    0865*      dl 0x000061 ; 157.500 70, 0.383
040DAD 5C 00 00    0866*      dl 0x00005C ; 158.906 71, 0.360
040DB0 56 00 00    0867*      dl 0x000056 ; 160.313 72, 0.337
040DB3 50 00 00    0868*      dl 0x000050 ; 161.719 73, 0.314
040DB6 4A 00 00    0869*      dl 0x00004A ; 163.125 74, 0.290
040DB9 44 00 00    0870*      dl 0x000044 ; 164.531 75, 0.267
040DBC 3E 00 00    0871*      dl 0x00003E ; 165.938 76, 0.243
040DBF 38 00 00    0872*      dl 0x000038 ; 167.344 77, 0.219
040DC2 31 00 00    0873*      dl 0x000031 ; 168.750 78, 0.195
040DC5 2B 00 00    0874*      dl 0x00002B ; 170.156 79, 0.171
040DC8 25 00 00    0875*      dl 0x000025 ; 171.563 7A, 0.147
040DCB 1F 00 00    0876*      dl 0x00001F ; 172.969 7B, 0.122
040DCE 19 00 00    0877*      dl 0x000019 ; 174.375 7C, 0.098
040DD1 12 00 00    0878*      dl 0x000012 ; 175.781 7D, 0.074
040DD4 0C 00 00    0879*      dl 0x00000C ; 177.188 7E, 0.049
040DD7 06 00 00    0880*      dl 0x000006 ; 178.594 7F, 0.025
040DDA 00 00 00    0881*      dl 0x000000 ; 180.000 80, 0.000
040DDD FA FF FF    0882*      dl 0xFFFFFA ; 181.406 81, -0.025
040DE0 F4 FF FF    0883*      dl 0xFFFFF4 ; 182.813 82, -0.049
040DE3 EE FF FF    0884*      dl 0xFFFFEE ; 184.219 83, -0.074
040DE6 E7 FF FF    0885*      dl 0xFFFFE7 ; 185.625 84, -0.098
040DE9 E1 FF FF    0886*      dl 0xFFFFE1 ; 187.031 85, -0.122
040DEC DB FF FF    0887*      dl 0xFFFFDB ; 188.438 86, -0.147
040DEF D5 FF FF    0888*      dl 0xFFFFD5 ; 189.844 87, -0.171
040DF2 CF FF FF    0889*      dl 0xFFFFCF ; 191.250 88, -0.195
040DF5 C8 FF FF    0890*      dl 0xFFFFC8 ; 192.656 89, -0.219
040DF8 C2 FF FF    0891*      dl 0xFFFFC2 ; 194.063 8A, -0.243
040DFB BC FF FF    0892*      dl 0xFFFFBC ; 195.469 8B, -0.267
040DFE B6 FF FF    0893*      dl 0xFFFFB6 ; 196.875 8C, -0.290
040E01 B0 FF FF    0894*      dl 0xFFFFB0 ; 198.281 8D, -0.314
040E04 AA FF FF    0895*      dl 0xFFFFAA ; 199.688 8E, -0.337
040E07 A4 FF FF    0896*      dl 0xFFFFA4 ; 201.094 8F, -0.360
040E0A 9F FF FF    0897*      dl 0xFFFF9F ; 202.500 90, -0.383
040E0D 99 FF FF    0898*      dl 0xFFFF99 ; 203.906 91, -0.405
040E10 93 FF FF    0899*      dl 0xFFFF93 ; 205.313 92, -0.428
040E13 8D FF FF    0900*      dl 0xFFFF8D ; 206.719 93, -0.450
040E16 88 FF FF    0901*      dl 0xFFFF88 ; 208.125 94, -0.471
040E19 82 FF FF    0902*      dl 0xFFFF82 ; 209.531 95, -0.493
040E1C 7D FF FF    0903*      dl 0xFFFF7D ; 210.938 96, -0.514
040E1F 78 FF FF    0904*      dl 0xFFFF78 ; 212.344 97, -0.535
040E22 72 FF FF    0905*      dl 0xFFFF72 ; 213.750 98, -0.556
040E25 6D FF FF    0906*      dl 0xFFFF6D ; 215.156 99, -0.576
040E28 68 FF FF    0907*      dl 0xFFFF68 ; 216.563 9A, -0.596
040E2B 63 FF FF    0908*      dl 0xFFFF63 ; 217.969 9B, -0.615
040E2E 5E FF FF    0909*      dl 0xFFFF5E ; 219.375 9C, -0.634
040E31 59 FF FF    0910*      dl 0xFFFF59 ; 220.781 9D, -0.653
040E34 55 FF FF    0911*      dl 0xFFFF55 ; 222.188 9E, -0.672
040E37 50 FF FF    0912*      dl 0xFFFF50 ; 223.594 9F, -0.690
040E3A 4B FF FF    0913*      dl 0xFFFF4B ; 225.000 A0, -0.707
040E3D 47 FF FF    0914*      dl 0xFFFF47 ; 226.406 A1, -0.724
040E40 43 FF FF    0915*      dl 0xFFFF43 ; 227.813 A2, -0.741
040E43 3F FF FF    0916*      dl 0xFFFF3F ; 229.219 A3, -0.757
040E46 3B FF FF    0917*      dl 0xFFFF3B ; 230.625 A4, -0.773
040E49 37 FF FF    0918*      dl 0xFFFF37 ; 232.031 A5, -0.788
040E4C 33 FF FF    0919*      dl 0xFFFF33 ; 233.438 A6, -0.803
040E4F 2F FF FF    0920*      dl 0xFFFF2F ; 234.844 A7, -0.818
040E52 2C FF FF    0921*      dl 0xFFFF2C ; 236.250 A8, -0.831
040E55 28 FF FF    0922*      dl 0xFFFF28 ; 237.656 A9, -0.845
040E58 25 FF FF    0923*      dl 0xFFFF25 ; 239.063 AA, -0.858
040E5B 22 FF FF    0924*      dl 0xFFFF22 ; 240.469 AB, -0.870
040E5E 1F FF FF    0925*      dl 0xFFFF1F ; 241.875 AC, -0.882
040E61 1C FF FF    0926*      dl 0xFFFF1C ; 243.281 AD, -0.893
040E64 19 FF FF    0927*      dl 0xFFFF19 ; 244.688 AE, -0.904
040E67 16 FF FF    0928*      dl 0xFFFF16 ; 246.094 AF, -0.914
040E6A 14 FF FF    0929*      dl 0xFFFF14 ; 247.500 B0, -0.924
040E6D 12 FF FF    0930*      dl 0xFFFF12 ; 248.906 B1, -0.933
040E70 0F FF FF    0931*      dl 0xFFFF0F ; 250.313 B2, -0.942
040E73 0D FF FF    0932*      dl 0xFFFF0D ; 251.719 B3, -0.950
040E76 0C FF FF    0933*      dl 0xFFFF0C ; 253.125 B4, -0.957
040E79 0A FF FF    0934*      dl 0xFFFF0A ; 254.531 B5, -0.964
040E7C 08 FF FF    0935*      dl 0xFFFF08 ; 255.938 B6, -0.970
040E7F 07 FF FF    0936*      dl 0xFFFF07 ; 257.344 B7, -0.976
040E82 05 FF FF    0937*      dl 0xFFFF05 ; 258.750 B8, -0.981
040E85 04 FF FF    0938*      dl 0xFFFF04 ; 260.156 B9, -0.985
040E88 03 FF FF    0939*      dl 0xFFFF03 ; 261.563 BA, -0.989
040E8B 02 FF FF    0940*      dl 0xFFFF02 ; 262.969 BB, -0.992
040E8E 02 FF FF    0941*      dl 0xFFFF02 ; 264.375 BC, -0.995
040E91 01 FF FF    0942*      dl 0xFFFF01 ; 265.781 BD, -0.997
040E94 01 FF FF    0943*      dl 0xFFFF01 ; 267.188 BE, -0.999
040E97 01 FF FF    0944*      dl 0xFFFF01 ; 268.594 BF, -1.000
040E9A 00 FF FF    0945*      dl 0xFFFF00 ; 270.000 C0, -1.000
040E9D 01 FF FF    0946*      dl 0xFFFF01 ; 271.406 C1, -1.000
040EA0 01 FF FF    0947*      dl 0xFFFF01 ; 272.813 C2, -0.999
040EA3 01 FF FF    0948*      dl 0xFFFF01 ; 274.219 C3, -0.997
040EA6 02 FF FF    0949*      dl 0xFFFF02 ; 275.625 C4, -0.995
040EA9 02 FF FF    0950*      dl 0xFFFF02 ; 277.031 C5, -0.992
040EAC 03 FF FF    0951*      dl 0xFFFF03 ; 278.438 C6, -0.989
040EAF 04 FF FF    0952*      dl 0xFFFF04 ; 279.844 C7, -0.985
040EB2 05 FF FF    0953*      dl 0xFFFF05 ; 281.250 C8, -0.981
040EB5 07 FF FF    0954*      dl 0xFFFF07 ; 282.656 C9, -0.976
040EB8 08 FF FF    0955*      dl 0xFFFF08 ; 284.063 CA, -0.970
040EBB 0A FF FF    0956*      dl 0xFFFF0A ; 285.469 CB, -0.964
040EBE 0C FF FF    0957*      dl 0xFFFF0C ; 286.875 CC, -0.957
040EC1 0D FF FF    0958*      dl 0xFFFF0D ; 288.281 CD, -0.950
040EC4 0F FF FF    0959*      dl 0xFFFF0F ; 289.688 CE, -0.942
040EC7 12 FF FF    0960*      dl 0xFFFF12 ; 291.094 CF, -0.933
040ECA 14 FF FF    0961*      dl 0xFFFF14 ; 292.500 D0, -0.924
040ECD 16 FF FF    0962*      dl 0xFFFF16 ; 293.906 D1, -0.914
040ED0 19 FF FF    0963*      dl 0xFFFF19 ; 295.313 D2, -0.904
040ED3 1C FF FF    0964*      dl 0xFFFF1C ; 296.719 D3, -0.893
040ED6 1F FF FF    0965*      dl 0xFFFF1F ; 298.125 D4, -0.882
040ED9 22 FF FF    0966*      dl 0xFFFF22 ; 299.531 D5, -0.870
040EDC 25 FF FF    0967*      dl 0xFFFF25 ; 300.938 D6, -0.858
040EDF 28 FF FF    0968*      dl 0xFFFF28 ; 302.344 D7, -0.845
040EE2 2C FF FF    0969*      dl 0xFFFF2C ; 303.750 D8, -0.831
040EE5 2F FF FF    0970*      dl 0xFFFF2F ; 305.156 D9, -0.818
040EE8 33 FF FF    0971*      dl 0xFFFF33 ; 306.563 DA, -0.803
040EEB 37 FF FF    0972*      dl 0xFFFF37 ; 307.969 DB, -0.788
040EEE 3B FF FF    0973*      dl 0xFFFF3B ; 309.375 DC, -0.773
040EF1 3F FF FF    0974*      dl 0xFFFF3F ; 310.781 DD, -0.757
040EF4 43 FF FF    0975*      dl 0xFFFF43 ; 312.188 DE, -0.741
040EF7 47 FF FF    0976*      dl 0xFFFF47 ; 313.594 DF, -0.724
040EFA 4B FF FF    0977*      dl 0xFFFF4B ; 315.000 E0, -0.707
040EFD 50 FF FF    0978*      dl 0xFFFF50 ; 316.406 E1, -0.690
040F00 55 FF FF    0979*      dl 0xFFFF55 ; 317.813 E2, -0.672
040F03 59 FF FF    0980*      dl 0xFFFF59 ; 319.219 E3, -0.653
040F06 5E FF FF    0981*      dl 0xFFFF5E ; 320.625 E4, -0.634
040F09 63 FF FF    0982*      dl 0xFFFF63 ; 322.031 E5, -0.615
040F0C 68 FF FF    0983*      dl 0xFFFF68 ; 323.438 E6, -0.596
040F0F 6D FF FF    0984*      dl 0xFFFF6D ; 324.844 E7, -0.576
040F12 72 FF FF    0985*      dl 0xFFFF72 ; 326.250 E8, -0.556
040F15 78 FF FF    0986*      dl 0xFFFF78 ; 327.656 E9, -0.535
040F18 7D FF FF    0987*      dl 0xFFFF7D ; 329.063 EA, -0.514
040F1B 82 FF FF    0988*      dl 0xFFFF82 ; 330.469 EB, -0.493
040F1E 88 FF FF    0989*      dl 0xFFFF88 ; 331.875 EC, -0.471
040F21 8D FF FF    0990*      dl 0xFFFF8D ; 333.281 ED, -0.450
040F24 93 FF FF    0991*      dl 0xFFFF93 ; 334.688 EE, -0.428
040F27 99 FF FF    0992*      dl 0xFFFF99 ; 336.094 EF, -0.405
040F2A 9F FF FF    0993*      dl 0xFFFF9F ; 337.500 F0, -0.383
040F2D A4 FF FF    0994*      dl 0xFFFFA4 ; 338.906 F1, -0.360
040F30 AA FF FF    0995*      dl 0xFFFFAA ; 340.313 F2, -0.337
040F33 B0 FF FF    0996*      dl 0xFFFFB0 ; 341.719 F3, -0.314
040F36 B6 FF FF    0997*      dl 0xFFFFB6 ; 343.125 F4, -0.290
040F39 BC FF FF    0998*      dl 0xFFFFBC ; 344.531 F5, -0.267
040F3C C2 FF FF    0999*      dl 0xFFFFC2 ; 345.938 F6, -0.243
040F3F C8 FF FF    1000*      dl 0xFFFFC8 ; 347.344 F7, -0.219
040F42 CF FF FF    1001*      dl 0xFFFFCF ; 348.750 F8, -0.195
040F45 D5 FF FF    1002*      dl 0xFFFFD5 ; 350.156 F9, -0.171
040F48 DB FF FF    1003*      dl 0xFFFFDB ; 351.563 FA, -0.147
040F4B E1 FF FF    1004*      dl 0xFFFFE1 ; 352.969 FB, -0.122
040F4E E7 FF FF    1005*      dl 0xFFFFE7 ; 354.375 FC, -0.098
040F51 EE FF FF    1006*      dl 0xFFFFEE ; 355.781 FD, -0.074
040F54 F4 FF FF    1007*      dl 0xFFFFF4 ; 357.188 FE, -0.049
040F57 FA FF FF    1008*      dl 0xFFFFFA ; 358.594 FF, -0.025
040F5A 00 00 00    1009*      dl 0x000000 ; 0.000 00, 0.000 for interpolation
040F5D             1010*  
040F5D             1011*  atan_lut_168:
040F5D 00 00 00    1012*      dl 0x000000 ; 000000, 0.000
040F60 28 00 00    1013*      dl 0x000028 ; 000001, 0.224
040F63 51 00 00    1014*      dl 0x000051 ; 000002, 0.448
040F66 7A 00 00    1015*      dl 0x00007A ; 000003, 0.671
040F69 A2 00 00    1016*      dl 0x0000A2 ; 000004, 0.895
040F6C CB 00 00    1017*      dl 0x0000CB ; 000005, 1.119
040F6F F4 00 00    1018*      dl 0x0000F4 ; 000006, 1.343
040F72 1D 01 00    1019*      dl 0x00011D ; 000007, 1.566
040F75 45 01 00    1020*      dl 0x000145 ; 000008, 1.790
040F78 6E 01 00    1021*      dl 0x00016E ; 000009, 2.013
040F7B 97 01 00    1022*      dl 0x000197 ; 00000A, 2.237
040F7E BF 01 00    1023*      dl 0x0001BF ; 00000B, 2.460
040F81 E8 01 00    1024*      dl 0x0001E8 ; 00000C, 2.684
040F84 11 02 00    1025*      dl 0x000211 ; 00000D, 2.907
040F87 39 02 00    1026*      dl 0x000239 ; 00000E, 3.130
040F8A 62 02 00    1027*      dl 0x000262 ; 00000F, 3.353
040F8D 8B 02 00    1028*      dl 0x00028B ; 000010, 3.576
040F90 B3 02 00    1029*      dl 0x0002B3 ; 000011, 3.799
040F93 DC 02 00    1030*      dl 0x0002DC ; 000012, 4.022
040F96 04 03 00    1031*      dl 0x000304 ; 000013, 4.245
040F99 2D 03 00    1032*      dl 0x00032D ; 000014, 4.467
040F9C 55 03 00    1033*      dl 0x000355 ; 000015, 4.690
040F9F 7E 03 00    1034*      dl 0x00037E ; 000016, 4.912
040FA2 A6 03 00    1035*      dl 0x0003A6 ; 000017, 5.134
040FA5 CE 03 00    1036*      dl 0x0003CE ; 000018, 5.356
040FA8 F7 03 00    1037*      dl 0x0003F7 ; 000019, 5.578
040FAB 1F 04 00    1038*      dl 0x00041F ; 00001A, 5.799
040FAE 48 04 00    1039*      dl 0x000448 ; 00001B, 6.021
040FB1 70 04 00    1040*      dl 0x000470 ; 00001C, 6.242
040FB4 98 04 00    1041*      dl 0x000498 ; 00001D, 6.463
040FB7 C0 04 00    1042*      dl 0x0004C0 ; 00001E, 6.684
040FBA E8 04 00    1043*      dl 0x0004E8 ; 00001F, 6.905
040FBD 11 05 00    1044*      dl 0x000511 ; 000020, 7.125
040FC0 39 05 00    1045*      dl 0x000539 ; 000021, 7.345
040FC3 61 05 00    1046*      dl 0x000561 ; 000022, 7.565
040FC6 89 05 00    1047*      dl 0x000589 ; 000023, 7.785
040FC9 B1 05 00    1048*      dl 0x0005B1 ; 000024, 8.005
040FCC D9 05 00    1049*      dl 0x0005D9 ; 000025, 8.224
040FCF 01 06 00    1050*      dl 0x000601 ; 000026, 8.443
040FD2 28 06 00    1051*      dl 0x000628 ; 000027, 8.662
040FD5 50 06 00    1052*      dl 0x000650 ; 000028, 8.881
040FD8 78 06 00    1053*      dl 0x000678 ; 000029, 9.099
040FDB A0 06 00    1054*      dl 0x0006A0 ; 00002A, 9.317
040FDE C7 06 00    1055*      dl 0x0006C7 ; 00002B, 9.535
040FE1 EF 06 00    1056*      dl 0x0006EF ; 00002C, 9.752
040FE4 16 07 00    1057*      dl 0x000716 ; 00002D, 9.970
040FE7 3E 07 00    1058*      dl 0x00073E ; 00002E, 10.187
040FEA 65 07 00    1059*      dl 0x000765 ; 00002F, 10.403
040FED 8D 07 00    1060*      dl 0x00078D ; 000030, 10.620
040FF0 B4 07 00    1061*      dl 0x0007B4 ; 000031, 10.836
040FF3 DB 07 00    1062*      dl 0x0007DB ; 000032, 11.051
040FF6 03 08 00    1063*      dl 0x000803 ; 000033, 11.267
040FF9 2A 08 00    1064*      dl 0x00082A ; 000034, 11.482
040FFC 51 08 00    1065*      dl 0x000851 ; 000035, 11.697
040FFF 78 08 00    1066*      dl 0x000878 ; 000036, 11.911
041002 9F 08 00    1067*      dl 0x00089F ; 000037, 12.125
041005 C6 08 00    1068*      dl 0x0008C6 ; 000038, 12.339
041008 ED 08 00    1069*      dl 0x0008ED ; 000039, 12.553
04100B 13 09 00    1070*      dl 0x000913 ; 00003A, 12.766
04100E 3A 09 00    1071*      dl 0x00093A ; 00003B, 12.978
041011 61 09 00    1072*      dl 0x000961 ; 00003C, 13.191
041014 87 09 00    1073*      dl 0x000987 ; 00003D, 13.403
041017 AE 09 00    1074*      dl 0x0009AE ; 00003E, 13.614
04101A D4 09 00    1075*      dl 0x0009D4 ; 00003F, 13.825
04101D FB 09 00    1076*      dl 0x0009FB ; 000040, 14.036
041020 21 0A 00    1077*      dl 0x000A21 ; 000041, 14.247
041023 47 0A 00    1078*      dl 0x000A47 ; 000042, 14.457
041026 6D 0A 00    1079*      dl 0x000A6D ; 000043, 14.666
041029 94 0A 00    1080*      dl 0x000A94 ; 000044, 14.876
04102C BA 0A 00    1081*      dl 0x000ABA ; 000045, 15.085
04102F E0 0A 00    1082*      dl 0x000AE0 ; 000046, 15.293
041032 05 0B 00    1083*      dl 0x000B05 ; 000047, 15.501
041035 2B 0B 00    1084*      dl 0x000B2B ; 000048, 15.709
041038 51 0B 00    1085*      dl 0x000B51 ; 000049, 15.916
04103B 77 0B 00    1086*      dl 0x000B77 ; 00004A, 16.123
04103E 9C 0B 00    1087*      dl 0x000B9C ; 00004B, 16.329
041041 C2 0B 00    1088*      dl 0x000BC2 ; 00004C, 16.535
041044 E7 0B 00    1089*      dl 0x000BE7 ; 00004D, 16.740
041047 0C 0C 00    1090*      dl 0x000C0C ; 00004E, 16.945
04104A 32 0C 00    1091*      dl 0x000C32 ; 00004F, 17.150
04104D 57 0C 00    1092*      dl 0x000C57 ; 000050, 17.354
041050 7C 0C 00    1093*      dl 0x000C7C ; 000051, 17.558
041053 A1 0C 00    1094*      dl 0x000CA1 ; 000052, 17.761
041056 C6 0C 00    1095*      dl 0x000CC6 ; 000053, 17.964
041059 EB 0C 00    1096*      dl 0x000CEB ; 000054, 18.166
04105C 0F 0D 00    1097*      dl 0x000D0F ; 000055, 18.368
04105F 34 0D 00    1098*      dl 0x000D34 ; 000056, 18.569
041062 58 0D 00    1099*      dl 0x000D58 ; 000057, 18.770
041065 7D 0D 00    1100*      dl 0x000D7D ; 000058, 18.970
041068 A1 0D 00    1101*      dl 0x000DA1 ; 000059, 19.170
04106B C6 0D 00    1102*      dl 0x000DC6 ; 00005A, 19.370
04106E EA 0D 00    1103*      dl 0x000DEA ; 00005B, 19.569
041071 0E 0E 00    1104*      dl 0x000E0E ; 00005C, 19.767
041074 32 0E 00    1105*      dl 0x000E32 ; 00005D, 19.965
041077 56 0E 00    1106*      dl 0x000E56 ; 00005E, 20.163
04107A 7A 0E 00    1107*      dl 0x000E7A ; 00005F, 20.360
04107D 9E 0E 00    1108*      dl 0x000E9E ; 000060, 20.556
041080 C1 0E 00    1109*      dl 0x000EC1 ; 000061, 20.752
041083 E5 0E 00    1110*      dl 0x000EE5 ; 000062, 20.947
041086 08 0F 00    1111*      dl 0x000F08 ; 000063, 21.142
041089 2C 0F 00    1112*      dl 0x000F2C ; 000064, 21.337
04108C 4F 0F 00    1113*      dl 0x000F4F ; 000065, 21.531
04108F 72 0F 00    1114*      dl 0x000F72 ; 000066, 21.724
041092 95 0F 00    1115*      dl 0x000F95 ; 000067, 21.917
041095 B8 0F 00    1116*      dl 0x000FB8 ; 000068, 22.109
041098 DB 0F 00    1117*      dl 0x000FDB ; 000069, 22.301
04109B FE 0F 00    1118*      dl 0x000FFE ; 00006A, 22.493
04109E 21 10 00    1119*      dl 0x001021 ; 00006B, 22.683
0410A1 44 10 00    1120*      dl 0x001044 ; 00006C, 22.874
0410A4 66 10 00    1121*      dl 0x001066 ; 00006D, 23.063
0410A7 89 10 00    1122*      dl 0x001089 ; 00006E, 23.253
0410AA AB 10 00    1123*      dl 0x0010AB ; 00006F, 23.441
0410AD CD 10 00    1124*      dl 0x0010CD ; 000070, 23.629
0410B0 EF 10 00    1125*      dl 0x0010EF ; 000071, 23.817
0410B3 11 11 00    1126*      dl 0x001111 ; 000072, 24.004
0410B6 33 11 00    1127*      dl 0x001133 ; 000073, 24.191
0410B9 55 11 00    1128*      dl 0x001155 ; 000074, 24.376
0410BC 77 11 00    1129*      dl 0x001177 ; 000075, 24.562
0410BF 99 11 00    1130*      dl 0x001199 ; 000076, 24.747
0410C2 BA 11 00    1131*      dl 0x0011BA ; 000077, 24.931
0410C5 DC 11 00    1132*      dl 0x0011DC ; 000078, 25.115
0410C8 FD 11 00    1133*      dl 0x0011FD ; 000079, 25.298
0410CB 1E 12 00    1134*      dl 0x00121E ; 00007A, 25.481
0410CE 3F 12 00    1135*      dl 0x00123F ; 00007B, 25.663
0410D1 60 12 00    1136*      dl 0x001260 ; 00007C, 25.844
0410D4 81 12 00    1137*      dl 0x001281 ; 00007D, 26.025
0410D7 A2 12 00    1138*      dl 0x0012A2 ; 00007E, 26.206
0410DA C3 12 00    1139*      dl 0x0012C3 ; 00007F, 26.386
0410DD E4 12 00    1140*      dl 0x0012E4 ; 000080, 26.565
0410E0 04 13 00    1141*      dl 0x001304 ; 000081, 26.744
0410E3 25 13 00    1142*      dl 0x001325 ; 000082, 26.922
0410E6 45 13 00    1143*      dl 0x001345 ; 000083, 27.100
0410E9 65 13 00    1144*      dl 0x001365 ; 000084, 27.277
0410EC 85 13 00    1145*      dl 0x001385 ; 000085, 27.453
0410EF A5 13 00    1146*      dl 0x0013A5 ; 000086, 27.629
0410F2 C5 13 00    1147*      dl 0x0013C5 ; 000087, 27.805
0410F5 E5 13 00    1148*      dl 0x0013E5 ; 000088, 27.979
0410F8 05 14 00    1149*      dl 0x001405 ; 000089, 28.154
0410FB 24 14 00    1150*      dl 0x001424 ; 00008A, 28.327
0410FE 44 14 00    1151*      dl 0x001444 ; 00008B, 28.501
041101 63 14 00    1152*      dl 0x001463 ; 00008C, 28.673
041104 83 14 00    1153*      dl 0x001483 ; 00008D, 28.845
041107 A2 14 00    1154*      dl 0x0014A2 ; 00008E, 29.017
04110A C1 14 00    1155*      dl 0x0014C1 ; 00008F, 29.187
04110D E0 14 00    1156*      dl 0x0014E0 ; 000090, 29.358
041110 FF 14 00    1157*      dl 0x0014FF ; 000091, 29.527
041113 1E 15 00    1158*      dl 0x00151E ; 000092, 29.697
041116 3C 15 00    1159*      dl 0x00153C ; 000093, 29.865
041119 5B 15 00    1160*      dl 0x00155B ; 000094, 30.033
04111C 79 15 00    1161*      dl 0x001579 ; 000095, 30.201
04111F 98 15 00    1162*      dl 0x001598 ; 000096, 30.368
041122 B6 15 00    1163*      dl 0x0015B6 ; 000097, 30.534
041125 D4 15 00    1164*      dl 0x0015D4 ; 000098, 30.700
041128 F2 15 00    1165*      dl 0x0015F2 ; 000099, 30.865
04112B 10 16 00    1166*      dl 0x001610 ; 00009A, 31.030
04112E 2E 16 00    1167*      dl 0x00162E ; 00009B, 31.194
041131 4C 16 00    1168*      dl 0x00164C ; 00009C, 31.357
041134 6A 16 00    1169*      dl 0x00166A ; 00009D, 31.520
041137 87 16 00    1170*      dl 0x001687 ; 00009E, 31.682
04113A A5 16 00    1171*      dl 0x0016A5 ; 00009F, 31.844
04113D C2 16 00    1172*      dl 0x0016C2 ; 0000A0, 32.005
041140 DF 16 00    1173*      dl 0x0016DF ; 0000A1, 32.166
041143 FC 16 00    1174*      dl 0x0016FC ; 0000A2, 32.326
041146 19 17 00    1175*      dl 0x001719 ; 0000A3, 32.486
041149 36 17 00    1176*      dl 0x001736 ; 0000A4, 32.645
04114C 53 17 00    1177*      dl 0x001753 ; 0000A5, 32.803
04114F 70 17 00    1178*      dl 0x001770 ; 0000A6, 32.961
041152 8C 17 00    1179*      dl 0x00178C ; 0000A7, 33.118
041155 A9 17 00    1180*      dl 0x0017A9 ; 0000A8, 33.275
041158 C5 17 00    1181*      dl 0x0017C5 ; 0000A9, 33.431
04115B E2 17 00    1182*      dl 0x0017E2 ; 0000AA, 33.587
04115E FE 17 00    1183*      dl 0x0017FE ; 0000AB, 33.742
041161 1A 18 00    1184*      dl 0x00181A ; 0000AC, 33.896
041164 36 18 00    1185*      dl 0x001836 ; 0000AD, 34.050
041167 52 18 00    1186*      dl 0x001852 ; 0000AE, 34.203
04116A 6E 18 00    1187*      dl 0x00186E ; 0000AF, 34.356
04116D 8A 18 00    1188*      dl 0x00188A ; 0000B0, 34.509
041170 A5 18 00    1189*      dl 0x0018A5 ; 0000B1, 34.660
041173 C1 18 00    1190*      dl 0x0018C1 ; 0000B2, 34.811
041176 DC 18 00    1191*      dl 0x0018DC ; 0000B3, 34.962
041179 F7 18 00    1192*      dl 0x0018F7 ; 0000B4, 35.112
04117C 13 19 00    1193*      dl 0x001913 ; 0000B5, 35.262
04117F 2E 19 00    1194*      dl 0x00192E ; 0000B6, 35.410
041182 49 19 00    1195*      dl 0x001949 ; 0000B7, 35.559
041185 64 19 00    1196*      dl 0x001964 ; 0000B8, 35.707
041188 7F 19 00    1197*      dl 0x00197F ; 0000B9, 35.854
04118B 99 19 00    1198*      dl 0x001999 ; 0000BA, 36.001
04118E B4 19 00    1199*      dl 0x0019B4 ; 0000BB, 36.147
041191 CE 19 00    1200*      dl 0x0019CE ; 0000BC, 36.293
041194 E9 19 00    1201*      dl 0x0019E9 ; 0000BD, 36.438
041197 03 1A 00    1202*      dl 0x001A03 ; 0000BE, 36.582
04119A 1D 1A 00    1203*      dl 0x001A1D ; 0000BF, 36.726
04119D 37 1A 00    1204*      dl 0x001A37 ; 0000C0, 36.870
0411A0 51 1A 00    1205*      dl 0x001A51 ; 0000C1, 37.013
0411A3 6B 1A 00    1206*      dl 0x001A6B ; 0000C2, 37.155
0411A6 85 1A 00    1207*      dl 0x001A85 ; 0000C3, 37.297
0411A9 9F 1A 00    1208*      dl 0x001A9F ; 0000C4, 37.439
0411AC B9 1A 00    1209*      dl 0x001AB9 ; 0000C5, 37.579
0411AF D2 1A 00    1210*      dl 0x001AD2 ; 0000C6, 37.720
0411B2 EC 1A 00    1211*      dl 0x001AEC ; 0000C7, 37.859
0411B5 05 1B 00    1212*      dl 0x001B05 ; 0000C8, 37.999
0411B8 1E 1B 00    1213*      dl 0x001B1E ; 0000C9, 38.137
0411BB 37 1B 00    1214*      dl 0x001B37 ; 0000CA, 38.276
0411BE 50 1B 00    1215*      dl 0x001B50 ; 0000CB, 38.413
0411C1 69 1B 00    1216*      dl 0x001B69 ; 0000CC, 38.550
0411C4 82 1B 00    1217*      dl 0x001B82 ; 0000CD, 38.687
0411C7 9B 1B 00    1218*      dl 0x001B9B ; 0000CE, 38.823
0411CA B4 1B 00    1219*      dl 0x001BB4 ; 0000CF, 38.959
0411CD CC 1B 00    1220*      dl 0x001BCC ; 0000D0, 39.094
0411D0 E5 1B 00    1221*      dl 0x001BE5 ; 0000D1, 39.228
0411D3 FD 1B 00    1222*      dl 0x001BFD ; 0000D2, 39.362
0411D6 16 1C 00    1223*      dl 0x001C16 ; 0000D3, 39.496
0411D9 2E 1C 00    1224*      dl 0x001C2E ; 0000D4, 39.629
0411DC 46 1C 00    1225*      dl 0x001C46 ; 0000D5, 39.762
0411DF 5E 1C 00    1226*      dl 0x001C5E ; 0000D6, 39.894
0411E2 76 1C 00    1227*      dl 0x001C76 ; 0000D7, 40.025
0411E5 8E 1C 00    1228*      dl 0x001C8E ; 0000D8, 40.156
0411E8 A5 1C 00    1229*      dl 0x001CA5 ; 0000D9, 40.286
0411EB BD 1C 00    1230*      dl 0x001CBD ; 0000DA, 40.416
0411EE D5 1C 00    1231*      dl 0x001CD5 ; 0000DB, 40.546
0411F1 EC 1C 00    1232*      dl 0x001CEC ; 0000DC, 40.675
0411F4 04 1D 00    1233*      dl 0x001D04 ; 0000DD, 40.803
0411F7 1B 1D 00    1234*      dl 0x001D1B ; 0000DE, 40.931
0411FA 32 1D 00    1235*      dl 0x001D32 ; 0000DF, 41.059
0411FD 49 1D 00    1236*      dl 0x001D49 ; 0000E0, 41.186
041200 60 1D 00    1237*      dl 0x001D60 ; 0000E1, 41.312
041203 77 1D 00    1238*      dl 0x001D77 ; 0000E2, 41.438
041206 8E 1D 00    1239*      dl 0x001D8E ; 0000E3, 41.564
041209 A5 1D 00    1240*      dl 0x001DA5 ; 0000E4, 41.689
04120C BB 1D 00    1241*      dl 0x001DBB ; 0000E5, 41.814
04120F D2 1D 00    1242*      dl 0x001DD2 ; 0000E6, 41.938
041212 E9 1D 00    1243*      dl 0x001DE9 ; 0000E7, 42.061
041215 FF 1D 00    1244*      dl 0x001DFF ; 0000E8, 42.184
041218 15 1E 00    1245*      dl 0x001E15 ; 0000E9, 42.307
04121B 2C 1E 00    1246*      dl 0x001E2C ; 0000EA, 42.429
04121E 42 1E 00    1247*      dl 0x001E42 ; 0000EB, 42.551
041221 58 1E 00    1248*      dl 0x001E58 ; 0000EC, 42.672
041224 6E 1E 00    1249*      dl 0x001E6E ; 0000ED, 42.793
041227 84 1E 00    1250*      dl 0x001E84 ; 0000EE, 42.913
04122A 99 1E 00    1251*      dl 0x001E99 ; 0000EF, 43.033
04122D AF 1E 00    1252*      dl 0x001EAF ; 0000F0, 43.152
041230 C5 1E 00    1253*      dl 0x001EC5 ; 0000F1, 43.271
041233 DA 1E 00    1254*      dl 0x001EDA ; 0000F2, 43.390
041236 F0 1E 00    1255*      dl 0x001EF0 ; 0000F3, 43.508
041239 05 1F 00    1256*      dl 0x001F05 ; 0000F4, 43.625
04123C 1B 1F 00    1257*      dl 0x001F1B ; 0000F5, 43.742
04123F 30 1F 00    1258*      dl 0x001F30 ; 0000F6, 43.859
041242 45 1F 00    1259*      dl 0x001F45 ; 0000F7, 43.975
041245 5A 1F 00    1260*      dl 0x001F5A ; 0000F8, 44.091
041248 6F 1F 00    1261*      dl 0x001F6F ; 0000F9, 44.206
04124B 84 1F 00    1262*      dl 0x001F84 ; 0000FA, 44.321
04124E 99 1F 00    1263*      dl 0x001F99 ; 0000FB, 44.435
041251 AD 1F 00    1264*      dl 0x001FAD ; 0000FC, 44.549
041254 C2 1F 00    1265*      dl 0x001FC2 ; 0000FD, 44.662
041257 D7 1F 00    1266*      dl 0x001FD7 ; 0000FE, 44.775
04125A EB 1F 00    1267*      dl 0x001FEB ; 0000FF, 44.888
04125D 00 20 00    1268*      dl 0x002000 ; 000100, 45.000 only needed for interpolation
041260             0035       include "images.inc"
041260             0001*  image_type: equ 0
041260             0002*  image_width: equ image_type+3
041260             0003*  image_height: equ image_width+3
041260             0004*  image_filesize: equ image_height+3
041260             0005*  image_filename: equ image_filesize+3
041260             0006*  image_bufferId: equ image_filename+3
041260             0007*  image_record_size: equ image_bufferId+3
041260             0008*  
041260 00 00 00    0009*  cur_image_list: dl 0
041263 00 00 00    0010*  cur_file_idx: dl 0
041266 00 00 00    0011*  cur_filename: dl 0
041269 00 00 00    0012*  cur_buffer_id: dl 0
04126C             0013*  
04126C             0014*  ; load_ui_images:
04126C             0015*  ; ; initialize image loading variables
04126C             0016*  ;     ld hl,0
04126C             0017*  ;     ld (cur_file_idx),hl
04126C             0018*  ;     ld hl,ui_image_list
04126C             0019*  ;     ld (cur_image_list),hl
04126C             0020*  ; ; load images
04126C             0021*  ;     ld b,ui_num_images
04126C             0022*  ; @loop:
04126C             0023*  ;     push bc
04126C             0024*  ;     call load_next_image
04126C             0025*  ;     pop bc
04126C             0026*  ;     djnz @loop
04126C             0027*  ;     ret
04126C             0028*  
04126C             0029*  load_sprite_images:
04126C             0030*  ; initialize image loading variables
04126C 21 00 00 00 0031*      ld hl,0
041270 22 63 12 04 0032*      ld (cur_file_idx),hl
041274 21 D8 1B 04 0033*      ld hl,sprites_image_list
041278 22 60 12 04 0034*      ld (cur_image_list),hl
04127C 01 71 00 00 0035*      ld bc,sprites_num_images
041280             0036*  ; load images
041280 CD 85 12 04 0037*      call img_load_main
041284 C9          0038*      ret
041285             0039*  
041285             0040*  ; inputs: bc is the number of images to load, cur_image_list set
041285             0041*  img_load_main:
041285 AF          0042*      xor a
041286 32 63 12 04 0043*      ld (cur_file_idx),a
04128A             0044*  
04128A             0045*  img_load_main_loop:
04128A             0046*  ; back up loop counter
04128A C5          0047*      push bc
04128B             0048*  
04128B             0049*  ; load the next image
04128B CD A6 12 04 0050*      call load_next_image
04128F             0051*  
04128F             0052*  ; ; plot the background
04128F             0053*  ;     call vdu_cls
04128F             0054*  ;     ld hl,BUF_SPLASH_BG
04128F             0055*  ;     call vdu_buff_select
04128F             0056*  ;     ld bc,0
04128F             0057*  ;     ld de,0
04128F             0058*  ;     call vdu_plot_bmp
04128F             0059*  
04128F             0060*  ; ; draw the most recently loaded image
04128F             0061*  ; 	ld hl,(cur_buffer_id)
04128F             0062*  ; 	call vdu_buff_select
04128F             0063*  ; 	ld bc,0
04128F             0064*  ; 	ld de,0
04128F             0065*  ; 	call vdu_plot_bmp
04128F             0066*  
04128F             0067*  ; ; move logo
04128F             0068*  ;     call move_logo
04128F             0069*  
04128F             0070*  ; print current filename
04128F 2A 66 12 04 0071*      ld hl,(cur_filename)
041293 CD 77 00 04 0072*      call printString
041297             0073*  
041297             0074*  ; flip the framebuffer
041297             0075*      ; call vdu_flip
041297             0076*  
041297             0077*  ; decrement loop counter
041297 C1          0078*      pop bc
041298 0B          0079*      dec bc
041299 79          0080*      ld a,c
04129A B7          0081*      or a
04129B C2 8A 12 04 0082*      jp nz,img_load_main_loop
04129F 78          0083*      ld a,b
0412A0 B7          0084*      or a
0412A1 C2 8A 12 04 0085*      jp nz,img_load_main_loop
0412A5 C9          0086*      ret
0412A6             0087*  
0412A6             0088*  load_next_image:
0412A6 16 12       0089*      ld d,image_record_size
0412A8 3A 63 12 04 0090*      ld a,(cur_file_idx)
0412AC 5F          0091*      ld e,a
0412AD ED 5C       0092*      mlt de
0412AF FD 2A 60 12 0093*      ld iy,(cur_image_list)
       04          
0412B4 FD 19       0094*      add iy,de
0412B6             0095*  
0412B6 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
0412B9 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
0412BC FD 17 06    0098*      ld de,(iy+image_height) ; get image height
0412BF FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
0412C2 FD 27 0F    0100*      ld hl,(iy+image_bufferId) ; get image bufferId
0412C5 22 69 12 04 0101*      ld (cur_buffer_id),hl
0412C9 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
0412CC FD 22 66 12 0103*      ld (cur_filename),iy
       04          
0412D1 CD A6 16 04 0104*      call vdu_load_img
0412D5 FD 21 63 12 0105*      ld iy,cur_file_idx
       04          
0412DA FD 34 00    0106*      inc (iy)
0412DD C9          0107*      ret
0412DE             0108*  
0412DE             0109*  ; img_load_init:
0412DE             0110*  ; ; initialize logo's position parameters
0412DE             0111*  ;     ld hl,0
0412DE             0112*  ;     ld (logo_xvel),hl
0412DE             0113*  ;     ld (logo_xpos),hl
0412DE             0114*  ; ; begin 16.8 maths to determine logo's y position and velocity
0412DE             0115*  ;     ld hl,240-16*256 ; allow space for text at bottom of screen
0412DE             0116*  ;     ld (logo_ypos),hl
0412DE             0117*  ;     ex de,hl
0412DE             0118*  ;     ld hl,-8*256 ; 8 pixels from top of screen
0412DE             0119*  ;     add hl,de ; distance for logo to travel
0412DE             0120*  ;     ld de,-sprites_num_images*256
0412DE             0121*  ;     call sdiv168 ; ud.e = distance / num images = y velocity
0412DE             0122*  ;     ld (logo_yvel),de
0412DE             0123*  ; ; all done
0412DE             0124*  ;     ret
0412DE             0125*  
0412DE             0126*  ; move_logo:
0412DE             0127*  ; ; activate logo bitmap
0412DE             0128*  ;     ld hl, BUF_SPLASH_LOGO
0412DE             0129*  ;     call vdu_buff_select
0412DE             0130*  ; ; update position based on velocity parameters
0412DE             0131*  ;     ld hl,(logo_ypos)
0412DE             0132*  ;     ld de,(logo_yvel)
0412DE             0133*  ;     add hl,de
0412DE             0134*  ;     ld (logo_ypos),hl
0412DE             0135*  ; ; draw logo
0412DE             0136*  ;     ld bc,(logo_xpos)
0412DE             0137*  ;     ld de,(logo_ypos)
0412DE             0138*  ;     call vdu_plot_bmp168
0412DE             0139*  ;     ret
0412DE             0140*  
0412DE             0141*  ; logo_xvel: dl 0
0412DE             0142*  ; logo_xpos: dl 0
0412DE             0143*  
0412DE             0144*  ; logo_yvel: dl 0
0412DE             0145*  ; logo_ypos: dl 0
0412DE             0036       include "timer.inc"
0412DE             0001*  ; Table 32. Timer Control Registers
0412DE             0002*  ; this constant is the base address of the timer control registers
0412DE             0003*  ; each timer takes three bytes:
0412DE             0004*  ;   0: control register
0412DE             0005*  ;   1: low byte of timer reset value
0412DE             0006*  ;   2: high byte of timer reset value
0412DE             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0412DE             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0412DE             0009*  TMR_CTL:     equ 80h
0412DE             0010*  
0412DE             0011*  ; Timer Control Register Bit Definitions
0412DE             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0412DE             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0412DE             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0412DE             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0412DE             0016*                              ; the TMRx_CTL register is read.
0412DE             0017*  
0412DE             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0412DE             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0412DE             0020*  
0412DE             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0412DE             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0412DE             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0412DE             0024*                              ; written to the counter when the end-of-count value is reached.
0412DE             0025*  
0412DE             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0412DE             0027*  CLK_DIV_256:  equ %00001100 ;
0412DE             0028*  CLK_DIV_64:   equ %00001000 ;
0412DE             0029*  CLK_DIV_16:   equ %00000100 ;
0412DE             0030*  CLK_DIV_4:    equ %00000000 ;
0412DE             0031*  
0412DE             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0412DE             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0412DE             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0412DE             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0412DE             0036*                              ; programmer must ensure that this bit is set to 1 each time
0412DE             0037*                              ; SINGLE-PASS mode is used.
0412DE             0038*  
0412DE             0039*  ; disable/enable the programmable reload timer
0412DE             0040*  PRT_EN_0:     equ %00000000 ;
0412DE             0041*  PRT_EN_1:     equ %00000001 ;
0412DE             0042*  
0412DE             0043*  ; Table 37. Timer Input Source Select Register
0412DE             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0412DE             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0412DE             0046*  ;   00: System clock / CLK_DIV
0412DE             0047*  ;   01: RTC / CLK_DIV
0412DE             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0412DE             0049*  ;   10: GPIO port B pin 1.
0412DE             0050*  ;   11: GPIO port B pin 1.
0412DE             0051*  TMR_ISS:   equ 92h ; register address
0412DE             0052*  
0412DE             0053*  ; Table 51. Real-Time Clock Control Register
0412DE             0054*  RTC_CTRL: equ EDh ; register address
0412DE             0055*  
0412DE             0056*  ; alarm interrupt disable/enable
0412DE             0057*  RTC_ALARM_0:    equ %00000000
0412DE             0058*  RTC_ALARM_1:    equ %10000000
0412DE             0059*  
0412DE             0060*  ; interrupt on alarm disable/enable
0412DE             0061*  RTC_INT_ENT_0:  equ %00000000
0412DE             0062*  RTC_INT_ENT_1:  equ %01000000
0412DE             0063*  
0412DE             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0412DE             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0412DE             0066*  
0412DE             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0412DE             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0412DE             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0412DE             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0412DE             0071*  
0412DE             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0412DE             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0412DE             0074*  
0412DE             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0412DE             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0412DE             0077*  
0412DE             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0412DE             0079*                                  ; RTC counter is enabled.
0412DE             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0412DE             0081*                                  ; RTC counter is disabled.
0412DE             0082*  
0412DE             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0412DE             0084*  
0412DE             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0412DE             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0412DE 00 00 00    0087*  prt_reload: dl 0x000000
0412E1             0088*  
0412E1             0089*  ; set PRT timer
0412E1             0090*  prt_set:
0412E1 21 00 00 00 0091*      ld hl,0
0412E5 22 2F 13 04 0092*      ld (prt_irq_counter),hl
0412E9 2A DE 12 04 0093*      ld hl,(prt_reload)
0412ED ED 29 84    0094*      out0 ($84),l
0412F0 ED 21 85    0095*  	out0 ($85),h
0412F3             0096*  ; disable timer
0412F3 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0412F5 ED 39 83    0098*  	out0 ($83),a
0412F8             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0412F8 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0412FA ED 39 83    0101*  	out0 ($83),a
0412FD C9          0102*      ret
0412FE             0103*  
0412FE             0104*  ; ===============================================
0412FE             0105*  ; PRT Timer Interrupt Handling
0412FE             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0412FE             0107*  ; -----------------------------------------------
0412FE             0108*  prt_irq_init:
0412FE             0109*      ; set up interrupt vector table 2
0412FE 21 00 00 00 0110*  	ld hl,0
041302 3A 0C 01 00 0111*  	ld a,($10c)
041306 6F          0112*  	ld l,a
041307 3A 0D 01 00 0113*  	ld a,($10d)
04130B 67          0114*  	ld h,a
04130C             0115*  
04130C             0116*  	; skip over CALL ($c3)
04130C 23          0117*  	inc hl
04130D             0118*  	; load address of jump into vector table 2 (in ram)
04130D ED 27       0119*  	ld hl,(hl)
04130F             0120*  
04130F             0121*  	; write CALL prt_irq_handler to vector table 2
04130F 3E C3       0122*  	ld a,$c3
041311 77          0123*  	ld (hl),a
041312 23          0124*  	inc hl
041313 11 1A 13 04 0125*  	ld de,prt_irq_handler
041317 ED 1F       0126*  	ld (hl),de
041319             0127*  
041319 C9          0128*      ret
04131A             0129*  
04131A             0130*  prt_irq_handler:
04131A F3          0131*  	di
04131B F5          0132*  	push af
04131C E5          0133*      push hl
04131D ED 38 83    0134*  	in0 a,($83)
041320 2A 2F 13 04 0135*  	ld hl,(prt_irq_counter)
041324 23          0136*  	inc hl
041325 22 2F 13 04 0137*  	ld (prt_irq_counter),hl
041329 E1          0138*      pop hl
04132A F1          0139*  	pop af
04132B FB          0140*  	ei
04132C 5B ED 4D    0141*  	reti.l
04132F             0142*  
04132F             0143*  prt_irq_counter:
04132F 00 00 00    0144*  	.dl 0
041332             0145*  prt_irq_counter_saved:
041332 00 00 00    0146*      .dl 0
041335             0147*  
041335             0148*  prt_loop_reset:
041335 E5          0149*      push hl
041336 21 00 00 00 0150*  	ld hl,0
04133A 22 2F 13 04 0151*  	ld (prt_irq_counter),hl
04133E 22 A0 13 04 0152*      ld (prt_loop_counter),hl
041342 22 A3 13 04 0153*      ld (prt_loops),hl
041346 CD E1 12 04 0154*      call prt_set
04134A E1          0155*      pop hl
04134B C9          0156*      ret
04134C             0157*  
04134C             0158*  prt_loop_start:
04134C E5          0159*      push hl
04134D 21 00 00 00 0160*  	ld hl,0
041351 22 2F 13 04 0161*  	ld (prt_irq_counter),hl
041355 E1          0162*      pop hl
041356 C9          0163*      ret
041357             0164*  
041357             0165*  prt_loop_stop:
041357 E5          0166*      push hl
041358 D5          0167*      push de
041359 2A 2F 13 04 0168*      ld hl,(prt_irq_counter)
04135D ED 5B A0 13 0169*      ld de,(prt_loop_counter)
       04          
041362 19          0170*      add hl,de
041363 22 A0 13 04 0171*      ld (prt_loop_counter),hl
041367 21 00 00 00 0172*      ld hl,0
04136B 22 2F 13 04 0173*      ld (prt_irq_counter),hl
04136F 2A A3 13 04 0174*      ld hl,(prt_loops)
041373 23          0175*      inc hl
041374 22 A3 13 04 0176*      ld (prt_loops),hl
041378 D1          0177*      pop de
041379 E1          0178*      pop hl
04137A C9          0179*      ret
04137B             0180*  
04137B             0181*  ; inputs: bc = y,x text coordinates to print
04137B             0182*  prt_loop_print:
04137B F5          0183*      push af
04137C E5          0184*      push hl
04137D C5          0185*      push bc
04137E D5          0186*      push de
04137F DD E5       0187*      push ix
041381 FD E5       0188*      push iy
041383 CD 87 14 04 0189*      call vdu_move_cursor
041387             0190*  
041387 2A A0 13 04 0191*      ld hl,(prt_loop_counter)
04138B CD 76 01 04 0192*      call printDec
04138F             0193*  
04138F 2A A3 13 04 0194*      ld hl,(prt_loops)
041393 CD 76 01 04 0195*      call printDec
041397             0196*  
041397 FD E1       0197*      pop iy
041399 DD E1       0198*      pop ix
04139B D1          0199*      pop de
04139C C1          0200*      pop bc
04139D E1          0201*      pop hl
04139E F1          0202*      pop af
04139F C9          0203*      ret
0413A0             0204*  
0413A0             0205*  prt_loop_counter:
0413A0 00 00 00    0206*      .dl 0
0413A3             0207*  prt_loops:
0413A3 00 00 00    0208*      .dl 0
0413A6             0209*  
0413A6             0210*  ; ===============================================
0413A6             0211*  ; Timer functions
0413A6             0212*  ; -----------------------------------------------
0413A6             0213*  ; set a countdown timer
0413A6             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0413A6             0215*  ; returns: hl = current time
0413A6             0216*  tmr_set:
0413A6 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0413A9             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0413A9 3E 08       0001*M 			LD	A, function
0413AB 5B CF       0002*M 			RST.LIL	08h
0413AD DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0413B0 FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0413B3 C9          0221*      ret
0413B4             0222*  
0413B4             0223*  ; gets time remaining on a countdown timer
0413B4             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0413B4             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0413B4             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0413B4             0227*  tmr_get:
0413B4             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0413B4 3E 08       0001*M 			LD	A, function
0413B6 5B CF       0002*M 			RST.LIL	08h
0413B8 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0413BB FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0413BE AF          0231*      xor a                   ; clear carry
0413BF ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0413C1 FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0413C4 AF          0234*      xor a                   ; clear carry
0413C5 ED 5A       0235*      adc hl,de               ; hl = time remaining
0413C7             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0413C7 C9          0237*      ret
0413C8             0238*  
0413C8             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
0413CE             0240*  
0413CE 00 00 00    0241*  timestamp_now: dl 0
0413D1 00 00 00    0242*  timestamp_old: dl 0
0413D4 00 00 00    0243*  timestamp_chg: dl 0
0413D7             0244*  
0413D7             0245*  ; update the global timestamp from the system clock
0413D7             0246*  ; inputs: none
0413D7             0247*  ; returns: hl = time elapsed in 1/120ths of a second
0413D7             0248*  ;          ix = pointer to syvars table
0413D7             0249*  ; destroys: af,hl,de,ix
0413D7             0250*  timestamp_tick:
0413D7 ED 5B CE 13 0251*      ld de,(timestamp_now)   ; get previous time
       04          
0413DC ED 53 D1 13 0252*      ld (timestamp_old),de   ; save previous time
       04          
0413E1             0253*      MOSCALL mos_sysvars     ; ix points to syvars table
0413E1 3E 08       0001*M 			LD	A, function
0413E3 5B CF       0002*M 			RST.LIL	08h
0413E5 DD 27 00    0254*      ld hl,(ix+sysvar_time)  ; get current time
0413E8 22 CE 13 04 0255*      ld (timestamp_now),hl   ; save current time
0413EC AF          0256*      xor a                   ; clear carry
0413ED ED 52       0257*      sbc hl,de               ; hl = time elapsed
0413EF 22 D4 13 04 0258*      ld (timestamp_chg),hl   ; save elapsed time
0413F3 C9          0259*      ret
0413F4             0260*  
0413F4             0261*  ; set a countdown timer
0413F4             0262*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0413F4             0263*  ; requires: timestamp_tick to be called at least once before this function
0413F4             0264*  ; returns: hl = current time
0413F4             0265*  ; destroys: hl
0413F4             0266*  timestamp_tmr_set:
0413F4 FD 2F 03    0267*      ld (iy+3),hl            ; set time remaining
0413F7 2A CE 13 04 0268*      ld hl,(timestamp_now)   ; get current timestamp
0413FB FD 2F 00    0269*      ld (iy+0),hl            ; set start time
0413FE C9          0270*      ret
0413FF             0271*  
0413FF             0272*  ; gets time remaining on a countdown timer following the global timestamp
0413FF             0273*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0413FF             0274*  ; requires: timestamp_tick to be called at least once before this function
0413FF             0275*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0413FF             0276*  ;          sign flags: pos = time not expired,zero or neg = time expired
0413FF             0277*  ; destroys: af,hl,de
0413FF             0278*  timestamp_tmr_get:
0413FF ED 5B CE 13 0279*      ld de,(timestamp_now)   ; get current timestamp
       04          
041404 FD 27 00    0280*      ld hl,(iy+0)            ; get start time
041407 AF          0281*      xor a                   ; clear carry
041408 ED 52       0282*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04140A FD 17 03    0283*      ld de,(iy+3)            ; get timer set value
04140D AF          0284*      xor a                   ; clear carry
04140E ED 5A       0285*      adc hl,de               ; hl = time remaining
041410             0286*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
041410 C9          0287*      ret
041411             0288*  
041411             0289*  ; set a stopwatch
041411             0290*  ; returns: hl = start time
041411             0291*  ; destroys: hl,ix
041411             0292*  stopwatch_set:
041411             0293*      MOSCALL mos_sysvars     ; ix points to syvars table
041411 3E 08       0001*M 			LD	A, function
041413 5B CF       0002*M 			RST.LIL	08h
041415 DD 27 00    0294*      ld hl,(ix+sysvar_time)  ; get current time
041418 22 2D 14 04 0295*      ld (stopwatch_started),hl            ; set start time
04141C C9          0296*      ret
04141D             0297*  
04141D             0298*  ; gets time elapsed on a stopwatch
04141D             0299*  ; returns: hl = time elapsed in 1/120ths of a second
04141D             0300*  ; destroys: af,hl,de,ix
04141D             0301*  stopwatch_get:
04141D             0302*      MOSCALL mos_sysvars     ; ix points to syvars table
04141D 3E 08       0001*M 			LD	A, function
04141F 5B CF       0002*M 			RST.LIL	08h
041421 DD 27 00    0303*      ld hl,(ix+sysvar_time)  ; get current time
041424 ED 5B 2D 14 0304*      ld de,(stopwatch_started)            ; get start time
       04          
041429 AF          0305*      xor a                   ; clear carry
04142A ED 52       0306*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04142C C9          0307*      ret
04142D             0308*  
04142D             0309*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041430             0310*  
041430             0311*  ; ------------------
041430             0312*  ; delay routine
041430             0313*  ; Author: Richard Turrnidge
041430             0314*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
041430             0315*  ; routine waits a fixed time,then returns
041430             0316*  ; arrive with A =  the delay byte. One bit to be set only.
041430             0317*  ; eg. ld A,00000100b
041430             0318*  
041430             0319*  multiPurposeDelay:
041430 F5          0320*      push af
041431 C5          0321*      push bc
041432 DD E5       0322*      push ix
041434 47          0323*      ld b,a
041435 3E 08       0324*      ld a,$08
041437 5B CF       0325*      RST.LIL	08h                 ; get IX pointer to sysvars
041439             0326*  
041439             0327*  waitLoop:
041439             0328*  
041439 DD 7E 00    0329*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04143C             0330*  
04143C             0331*                                  ;   we check if bit set is same as last time we checked.
04143C             0332*                                  ;   bit 0 - don't use
04143C             0333*                                  ;   bit 1 - changes 64 times per second
04143C             0334*                                  ;   bit 2 - changes 32 times per second
04143C             0335*                                  ;   bit 3 - changes 16 times per second
04143C             0336*  
04143C             0337*                                  ;   bit 4 - changes 8 times per second
04143C             0338*                                  ;   bit 5 - changes 4 times per second
04143C             0339*                                  ;   bit 6 - changes 2 times per second
04143C             0340*                                  ;   bit 7 - changes 1 times per second
04143C A0          0341*      and b
04143D 4F          0342*      ld c,a
04143E 3A 4F 14 04 0343*      ld a,(oldTimeStamp)
041442 B9          0344*      cp c                        ; is A same as last value?
041443 28 F4       0345*      jr z,waitLoop              ; loop here if it is
041445 79          0346*      ld a,c
041446 32 4F 14 04 0347*      ld (oldTimeStamp),a        ; set new value
04144A             0348*  
04144A DD E1       0349*      pop ix
04144C C1          0350*      pop bc
04144D F1          0351*      pop af
04144E C9          0352*      ret
04144F             0353*  
04144F 00          0354*  oldTimeStamp:   .db 00h
041450             0037       include "vdu.inc"
041450             0001*  
041450             0002*  ; VDU 30: Home cursor
041450             0003*  vdu_home_cursor:
041450 3E 1E       0004*      ld a,30
041452 5B D7       0005*  	rst.lil $10
041454 C9          0006*  	ret
041455             0007*  
041455             0008*  vdu_cursor_on:
041455 21 60 14 04 0009*  	ld hl,@cmd
041459 01 03 00 00 0010*  	ld bc,@end-@cmd
04145D 5B DF       0011*  	rst.lil $18
04145F C9          0012*  	ret
041460             0013*  @cmd:
041460 17 01 01    0014*  	db 23,1,1
041463             0015*  @end:
041463             0016*  
041463             0017*  vdu_cursor_off:
041463 21 6E 14 04 0018*  	ld hl,@cmd
041467 01 03 00 00 0019*  	ld bc,@end-@cmd
04146B 5B DF       0020*  	rst.lil $18
04146D C9          0021*  	ret
04146E             0022*  @cmd:
04146E 17 01 00    0023*  	db 23,1,0
041471             0024*  @end:
041471             0025*  
041471             0026*  ; VDU 5: Write text at graphics cursor
041471             0027*  ; inputs: a is the character to write to the screen
041471             0028*  ; prerequisites: the graphics cursor at the intended position on screen
041471             0029*  ; outputs: see the name of the function
041471             0030*  ; destroys: a, hl, bc
041471             0031*  vdu_char_to_gfx_cursor:
041471 32 81 14 04 0032*  	ld (@arg),a
041475 21 80 14 04 0033*  	ld hl,@cmd
041479 01 02 00 00 0034*  	ld bc,@end-@cmd
04147D 5B DF       0035*  	rst.lil $18
04147F C9          0036*  	ret
041480 05          0037*  @cmd: db 5
041481 00          0038*  @arg: db 0
041482             0039*  @end:
041482             0040*  ; VDU 9: Move cursor forward one character
041482             0041*  vdu_cursor_forward:
041482 3E 09       0042*      ld a,9
041484 5B D7       0043*  	rst.lil $10
041486 C9          0044*  	ret
041487             0045*  
041487             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041487             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
041487             0048*  vdu_move_cursor:
041487 ED 43 98 14 0049*      ld (@x0),bc
       04          
04148C 21 97 14 04 0050*  	ld hl,@cmd
041490 01 03 00 00 0051*  	ld bc,@end-@cmd
041494 5B DF       0052*  	rst.lil $18
041496 C9          0053*  	ret
041497 1F          0054*  @cmd: 	db 31
041498 00          0055*  @x0:	db 0
041499 00          0056*  @y0: 	db 0
04149A 00          0057*  @end: 	db 0 ; padding
04149B             0058*  
04149B             0059*  ; VDU 12: Clear text area (CLS)
04149B             0060*  vdu_cls:
04149B 3E 0C       0061*      ld a,12
04149D 5B D7       0062*  	rst.lil $10
04149F C9          0063*  	ret
0414A0             0064*  
0414A0             0065*  vdu_flip:
0414A0 21 AB 14 04 0066*  	ld hl,@cmd
0414A4 01 03 00 00 0067*  	ld bc,@end-@cmd
0414A8 5B DF       0068*  	rst.lil $18
0414AA C9          0069*  	ret
0414AB 17 00 C3    0070*  @cmd: db 23,0,0xC3
0414AE             0071*  @end:
0414AE             0072*  
0414AE             0073*  ; VDU 16: Clear graphics area (CLG)
0414AE             0074*  vdu_clg:
0414AE 3E 10       0075*      ld a,16
0414B0 5B D7       0076*  	rst.lil $10
0414B2 C9          0077*  	ret
0414B3             0078*  
0414B3             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0414B3             0080*  ; VDU 23, 7: Scrolling
0414B3             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0414B3             0082*  ; inputs: a, extent; l, direction; h; speed
0414B3             0083*  vdu_scroll_down:
0414B3 32 C8 14 04 0084*  	ld (@extent),a
0414B7 22 C9 14 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0414BB 21 C6 14 04 0086*  	ld hl,@cmd
0414BF 01 05 00 00 0087*  	ld bc,@end-@cmd
0414C3 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
0414C5 C9          0089*  	ret
0414C6 17 07       0090*  @cmd:       db 23,7
0414C8 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
0414C9 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
0414CA 00          0093*  @speed:     db 0x00 ; pixels
0414CB 00          0094*  @end:		db 0x00 ; padding
0414CC             0095*  
0414CC             0096*  ; COLOUR MODES
0414CC             0097*  ; Mode	Effect
0414CC             0098*  ; 0	Set on-screen pixel to target colour value
0414CC             0099*  ; 1	OR value with the on-screen pixel
0414CC             0100*  ; 2	AND value with the on-screen pixel
0414CC             0101*  ; 3	XOR value with the on-screen pixel
0414CC             0102*  ; 4	Invert the on-screen pixel
0414CC             0103*  ; 5	No operation
0414CC             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0414CC             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0414CC             0106*  
0414CC             0107*  ; VDU 17, colour: Define text colour (COLOUR)
0414CC             0108*  vdu_colour_text:
0414CC 32 DC 14 04 0109*  	ld (@arg),a
0414D0 21 DB 14 04 0110*  	ld hl,@cmd
0414D4 01 02 00 00 0111*  	ld bc,@end-@cmd
0414D8 5B DF       0112*  	rst.lil $18
0414DA C9          0113*  	ret
0414DB 11          0114*  @cmd: db 17
0414DC 00          0115*  @arg: db 0
0414DD             0116*  @end:
0414DD             0117*  
0414DD             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0414DD             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0414DD             0120*  vdu_gcol:
0414DD 32 F2 14 04 0121*  	ld (@mode),a
0414E1 79          0122*      ld a,c
0414E2 32 F3 14 04 0123*      ld (@col),a
0414E6 21 F1 14 04 0124*  	ld hl,@cmd
0414EA 01 03 00 00 0125*  	ld bc,@end-@cmd
0414EE 5B DF       0126*  	rst.lil $18
0414F0 C9          0127*  	ret
0414F1 12          0128*  @cmd:  db 18
0414F2 00          0129*  @mode: db 0
0414F3 00          0130*  @col:  db 0
0414F4             0131*  @end:
0414F4             0132*  
0414F4             0133*  
0414F4             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
0414F4             0135*  ; MIND THE LITTLE-ENDIANESS
0414F4             0136*  ; inputs: c=left,b=bottom,e=right,d=top
0414F4             0137*  ; outputs; nothing
0414F4             0138*  ; destroys: a might make it out alive
0414F4             0139*  vdu_set_txt_viewport:
0414F4 ED 43 0A 15 0140*      ld (@lb),bc
       04          
0414F9 ED 53 0C 15 0141*  	ld (@rt),de
       04          
0414FE 21 09 15 04 0142*  	ld hl,@cmd
041502 01 05 00 00 0143*  	ld bc,@end-@cmd
041506 5B DF       0144*  	rst.lil $18
041508 C9          0145*  	ret
041509 1C          0146*  @cmd:   db 28 ; set text viewport command
04150A 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
04150C 00 00       0148*  @rt: 	dw 0x0000 ; set by de
04150E 00          0149*  @end:   db 0x00	  ; padding
04150F             0150*  
04150F             0151*  ; Wait for VBLANK interrupt
04150F             0152*  vdu_vblank:
04150F DD E5       0153*      PUSH 	IX
041511             0154*  	MOSCALL	mos_sysvars
041511 3E 08       0001*M 			LD	A, function
041513 5B CF       0002*M 			RST.LIL	08h
041515 DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041518             0156*  @wait:
041518 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
04151B 28 FB       0158*      JR	Z, @wait
04151D DD E1       0159*      POP	IX
04151F C9          0160*      RET
041520             0161*  
041520             0162*  ; VDU 29, x; y;: Set graphics origin
041520             0163*  ; This command sets the graphics origin.
041520             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041520             0165*  ; inputs: bc=x0,de=y0
041520             0166*  ; outputs; nothing
041520             0167*  ; destroys: a might make it out alive
041520             0168*  vdu_set_gfx_origin:
041520 ED 43 36 15 0169*      ld (@x0),bc
       04          
041525 ED 53 38 15 0170*      ld (@y0),de
       04          
04152A 21 35 15 04 0171*      ld hl,@cmd
04152E 01 05 00 00 0172*      ld bc,@end-@cmd
041532 5B DF       0173*      rst.lil $18
041534 C9          0174*      ret
041535 1D          0175*  @cmd:   db 29 ; set graphics origin command
041536 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041538 00 00       0177*  @y0: 	dw 0x0000 ; set by de
04153A 00          0178*  @end:   db 0x00	  ; padding
04153B             0179*  
04153B             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04153B             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
04153B             0182*  ; 	because we have turned off logical screen scaling
04153B             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04153B             0184*  ; outputs; nothing
04153B             0185*  ; destroys: a might make it out alive
04153B             0186*  vdu_set_gfx_viewport:
04153B ED 43 5B 15 0187*      ld (@x0),bc
       04          
041540 FD 22 5D 15 0188*      ld (@y1),iy
       04          
041545 DD 22 5F 15 0189*  	ld (@x1),ix
       04          
04154A ED 53 61 15 0190*  	ld (@y0),de
       04          
04154F 21 5A 15 04 0191*  	ld hl,@cmd
041553 01 09 00 00 0192*  	ld bc,@end-@cmd
041557 5B DF       0193*  	rst.lil $18
041559 C9          0194*  	ret
04155A 18          0195*  @cmd:   db 24 ; set graphics viewport command
04155B 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
04155D 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
04155F 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
041561 00 00       0199*  @y0: 	dw 0x0000 ; set by de
041563 00          0200*  @end:   db 0x00	  ; padding
041564             0201*  
041564             0202*  ; SCREEN MODES
041564             0203*  ; ===============================
041564             0204*  ; Mode  Horz  Vert  Cols  Refresh
041564             0205*  ; ---   ----  ----  ----  -------
041564             0206*  ; 11    320   240   2     60hz
041564             0207*  ; 139   320   240   2     60hz
041564             0208*  ; 23    512   384   2     60hz
041564             0209*  ; 151   512   384   2     60hz
041564             0210*  ; 6     640   240   2     60hz
041564             0211*  ; 134   640   240   2     60hz
041564             0212*  ; 2     640   480   2     60hz
041564             0213*  ; 130   640   480   2     60hz
041564             0214*  ; 17    800   600   2     60hz
041564             0215*  ; 145   800   600   2     60hz
041564             0216*  ; 18    1024  768   2     60hz
041564             0217*  ; 146   1024  768   2     60hz
041564             0218*  ; ---   ----  ----  ----  -------
041564             0219*  ; 10    320   240   4     60hz
041564             0220*  ; 138   320   240   4     60hz
041564             0221*  ; 22    512   384   4     60hz
041564             0222*  ; 150   512   384   4     60hz
041564             0223*  ; 5     640   240   4     60hz
041564             0224*  ; 133   640   240   4     60hz
041564             0225*  ; 1     640   480   4     60hz
041564             0226*  ; 129   640   480   4     60hz
041564             0227*  ; 16    800   600   4     60hz
041564             0228*  ; 19    1024  768   4     60hz
041564             0229*  ; ---   ----  ----  ----  -------
041564             0230*  ; 9     320   240   16    60hz
041564             0231*  ; 137   320   240   16    60hz
041564             0232*  ; 21    512   384   16    60hz
041564             0233*  ; 149   512   384   16    60hz
041564             0234*  ; 4     640   240   16    60hz
041564             0235*  ; 132   640   240   16    60hz
041564             0236*  ; 0     640   480   16    60hz
041564             0237*  ; 7     n/a   n/a   16    60hz
041564             0238*  ; ---   ----  ----  ----  -------
041564             0239*  ; 8     320   240   64    60hz
041564             0240*  ; 136   320   240   64    60hz
041564             0241*  ; 20    512   384   64    60hz
041564             0242*  ; 3     640   240   64    60hz
041564             0243*  ; ---   ----  ----  ----  -------
041564             0244*  vdu_set_screen_mode:
041564 32 74 15 04 0245*  	ld (@arg),a
041568 21 73 15 04 0246*  	ld hl,@cmd
04156C 01 02 00 00 0247*  	ld bc,@end-@cmd
041570 5B DF       0248*  	rst.lil $18
041572 C9          0249*  	ret
041573 16          0250*  @cmd: db 22 ; set screen mode
041574 00          0251*  @arg: db 0  ; screen mode parameter
041575             0252*  @end:
041575             0253*  
041575             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041575             0255*  ; inputs: a is scaling mode, 1=on, 0=off
041575             0256*  ; note: default setting on boot is scaling ON
041575             0257*  vdu_set_scaling:
041575 32 87 15 04 0258*  	ld (@arg),a
041579 21 84 15 04 0259*  	ld hl,@cmd
04157D 01 04 00 00 0260*  	ld bc,@end-@cmd
041581 5B DF       0261*  	rst.lil $18
041583 C9          0262*  	ret
041584 17 00 C0    0263*  @cmd: db 23,0,0xC0
041587 00          0264*  @arg: db 0  ; scaling on/off
041588             0265*  @end:
041588             0266*  
041588             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041588             0268*  ; inputs: hl=bufferId
041588             0269*  vdu_buff_select:
041588 22 9A 15 04 0270*  	ld (@bufferId),hl
04158C 21 97 15 04 0271*  	ld hl,@cmd
041590 01 05 00 00 0272*  	ld bc,@end-@cmd
041594 5B DF       0273*  	rst.lil $18
041596 C9          0274*  	ret
041597 17 1B 20    0275*  @cmd: db 23,27,0x20
04159A 00 00       0276*  @bufferId: dw 0x0000
04159C 00          0277*  @end: db 0x00 ; padding
04159D             0278*  
04159D             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04159D             0280*  ; inputs: a=format; bc=width; de=height
04159D             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04159D             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04159D             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
04159D             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
04159D             0285*  ; 2 	Mono/Mask (1-bit per pixel)
04159D             0286*  ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
04159D             0287*  vdu_bmp_create:
04159D ED 43 B9 15 0288*      ld (@width),bc
       04          
0415A2 ED 53 BB 15 0289*      ld (@height),de
       04          
0415A7 32 BD 15 04 0290*      ld (@fmt),a
0415AB 21 B6 15 04 0291*  	ld hl,@cmd
0415AF 01 08 00 00 0292*  	ld bc,@end-@cmd
0415B3 5B DF       0293*  	rst.lil $18
0415B5 C9          0294*  	ret
0415B6 17 1B 21    0295*  @cmd:       db 23,27,0x21
0415B9 00 00       0296*  @width:     dw 0x0000
0415BB 00 00       0297*  @height:    dw 0x0000
0415BD 00          0298*  @fmt:       db 0x00
0415BE             0299*  @end:
0415BE             0300*  
0415BE             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0415BE             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0415BE             0303*  vdu_load_img_rgba2_to_8:
0415BE             0304*  ; backup the target buffer id and image dimensions
0415BE E5          0305*      push hl
0415BF D5          0306*      push de
0415C0 C5          0307*      push bc
0415C1             0308*  ; load the rgba2 image to working buffer 65534
0415C1 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
0415C5 CD C8 16 04 0310*  	call vdu_load_buffer_from_file
0415C9             0311*  ; restore the image dimensions and target buffer id
0415C9 C1          0312*      pop bc
0415CA D1          0313*      pop de
0415CB E1          0314*      pop hl
0415CC             0315*  ; fall through to vdu_rgba2_to_8
0415CC             0316*  
0415CC             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0415CC             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0415CC             0319*  ; the "expand bitmap" command is:
0415CC             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0415CC             0321*  ; and then to reverse the byte order to fix endian-ness:
0415CC             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0415CC             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0415CC             0324*  ; VDU 23,27,&20,targetBufferID%;
0415CC             0325*  ; VDU 23,27,&21,width%;height%;0
0415CC             0326*  ; -------------------------------------------------------------------
0415CC             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
0415CC             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0415CC             0329*  vdu_rgba2_to_8:
0415CC             0330*  ; load the image dimensions and buffer id parameters
0415CC ED 43 28 16 0331*      ld (@width),bc
       04          
0415D1 ED 53 2A 16 0332*      ld (@height),de
       04          
0415D6 22 0D 16 04 0333*      ld (@bufferId0),hl
0415DA 22 1A 16 04 0334*      ld (@bufferId2),hl
0415DE 22 23 16 04 0335*      ld (@bufferId1),hl
0415E2             0336*  ; clean up bytes that got stomped on by the ID loads
0415E2 3E 48       0337*      ld a,0x48
0415E4 32 0F 16 04 0338*      ld (@bufferId0+2),a
0415E8 3E 17       0339*      ld a,23
0415EA 32 25 16 04 0340*      ld (@bufferId1+2),a
0415EE 3E 18       0341*      ld a,24
0415F0 32 1C 16 04 0342*      ld (@bufferId2+2),a
0415F4 AF          0343*      xor a
0415F5 32 2C 16 04 0344*      ld (@height+2),a
0415F9             0345*  ; send the vdu command strings
0415F9 21 04 16 04 0346*      ld hl,@beg
0415FD 01 29 00 00 0347*      ld bc,@end-@beg
041601 5B DF       0348*      rst.lil $18
041603 C9          0349*      ret
041604             0350*  @beg:
041604             0351*  ; Command 14: Consolidate blocks in a buffer
041604             0352*  ; VDU 23, 0, &A0, bufferId; 14
041604 17 00 A0    0353*      db 23,0,0xA0
041607 FE FF       0354*      dw 65534 ; workingBufferId
041609 0E          0355*      db 14 ; consolidate blocks
04160A             0356*  ; the "expand bitmap" command is:
04160A             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04160A 17 00 A0    0358*      db 23,0,0xA0
04160D 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
04160F 48          0360*      db 0x48 ; given as decimal command 72 in the docs
041610 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041611 FE FF       0362*      dw 65534 ; sourceBufferId
041613 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041617             0364*  ; reverse the byte order to fix endian-ness:
041617             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041617             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041617             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041617 17 00 A0    0368*      db 23,0,0xA0
04161A 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
04161C 18          0370*      db 24 ; reverse byte order
04161D 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04161E 04 00       0372*      dw 4 ; size (4 bytes)
041620             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041620             0374*  ; VDU 23,27,&20,targetBufferID%;
041620 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
041623 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
041625             0377*  ; VDU 23,27,&21,width%;height%;0
041625 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041628 00 00       0379*  @width: dw 0x0000
04162A 00 00       0380*  @height: dw 0x0000
04162C 00          0381*      db 0x00 ; rgba8888 format
04162D             0382*  @end:
04162D             0383*  
04162D             0384*  ; scratch variables
04162D 00 00 00    0385*  bufferId0: dl 0x000000
041630 00 00 00    0386*  bufferId1: dl 0x000000
041633             0387*  
041633             0388*  ; load a vdu buffer from local memory
041633             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041633             0390*  vdu_load_buffer:
041633 ED 43 5C 16 0391*      ld (@length),bc
       04          
041638 D5          0392*      push de ; save data pointer
041639             0393*  ; send the vdu command string
041639 7D          0394*      ld a,l
04163A 32 59 16 04 0395*      ld (@bufferId),a
04163E 7C          0396*      ld a,h
04163F 32 5A 16 04 0397*      ld (@bufferId+1),a
041643 21 56 16 04 0398*      ld hl,@cmd
041647 01 08 00 00 0399*      ld bc,@end-@cmd
04164B 5B DF       0400*      rst.lil $18
04164D             0401*  ; send the buffer data
04164D E1          0402*      pop hl ; pointer to data
04164E ED 4B 5C 16 0403*      ld bc,(@length)
       04          
041653 5B DF       0404*      rst.lil $18 ; send it
041655 C9          0405*      ret
041656             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041656 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041659 00 00       0408*  @bufferId:	dw 0x0000
04165B 00          0409*  		    db 0 ; load buffer
04165C 00 00       0410*  @length:	dw 0x0000
04165E 00          0411*  @end: db 0 ; padding
04165F             0412*  
04165F             0413*  ; clear a buffer
04165F             0414*  ; inputs: hl = bufferId
04165F             0415*  vdu_clear_buffer:
04165F 7D          0416*      ld a,l
041660 32 77 16 04 0417*      ld (@bufferId),a
041664 7C          0418*      ld a,h
041665 32 78 16 04 0419*      ld (@bufferId+1),a
041669 21 74 16 04 0420*      ld hl,@cmd
04166D 01 06 00 00 0421*      ld bc,@end-@cmd
041671 5B DF       0422*      rst.lil $18
041673 C9          0423*      ret
041674 17 00 A0    0424*  @cmd:       db 23,0,0xA0
041677 00 00       0425*  @bufferId:	dw 0x0000
041679 02          0426*  		    db 2 ; clear buffer
04167A             0427*  @end:
04167A             0428*  
04167A             0429*  vdu_clear_all_buffers:
04167A             0430*  ; clear all buffers
04167A 21 85 16 04 0431*      ld hl,@beg
04167E 01 06 00 00 0432*      ld bc,@end-@beg
041682 5B DF       0433*      rst.lil $18
041684 C9          0434*      ret
041685 17 00 A0    0435*  @beg: db 23,0,$A0
041688 FF FF       0436*        dw -1 ; clear all buffers
04168A 02          0437*        db 2  ; command 2: clear a buffer
04168B             0438*  @end:
04168B             0439*  
04168B             0440*  ; Command 14: Consolidate blocks in a buffer
04168B             0441*  vdu_consolidate_buffer:
04168B             0442*  ; set parameters for vdu call
04168B 7D          0443*      ld a,l
04168C 32 A3 16 04 0444*      ld (@bufferId),a
041690 7C          0445*      ld a,h
041691 32 A4 16 04 0446*      ld (@bufferId+1),a
041695 21 A0 16 04 0447*      ld hl,@beg
041699 01 06 00 00 0448*      ld bc,@end-@beg
04169D 5B DF       0449*      rst.lil $18
04169F C9          0450*      ret
0416A0             0451*  ; VDU 23, 0, &A0, bufferId; 14
0416A0 17 00 A0    0452*  @beg: db 23,0,0xA0
0416A3 00 00       0453*  @bufferId: dw 0x0000
0416A5 0E          0454*             db 14
0416A6             0455*  @end:
0416A6             0456*  
0416A6             0457*  ; load an image file to a buffer and make it a bitmap
0416A6             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0416A6             0459*  vdu_load_img:
0416A6             0460*  ; back up image type and dimension parameters
0416A6 22 2D 16 04 0461*      ld (bufferId0),hl
0416AA F5          0462*      push af
0416AB C5          0463*  	push bc
0416AC D5          0464*  	push de
0416AD             0465*  ; load the image
0416AD CD C8 16 04 0466*  	call vdu_load_buffer_from_file
0416B1             0467*  ; now make it a bitmap
0416B1 2A 2D 16 04 0468*      ld hl,(bufferId0)
0416B5 CD 8B 16 04 0469*      call vdu_consolidate_buffer
0416B9 2A 2D 16 04 0470*      ld hl,(bufferId0)
0416BD CD 88 15 04 0471*      call vdu_buff_select
0416C1 D1          0472*  	pop de ; image height
0416C2 C1          0473*  	pop bc ; image width
0416C3 F1          0474*  	pop af ; image type
0416C4 C3 9D 15 04 0475*  	jp vdu_bmp_create ; will return to caller from there
0416C8             0476*  
0416C8             0477*  ; inputs: hl = bufferId; iy = pointer to filename
0416C8             0478*  vdu_load_buffer_from_file:
0416C8 22 2D 16 04 0479*      ld (bufferId0),hl
0416CC             0480*  
0416CC             0481*  ; clear target buffer
0416CC CD 5F 16 04 0482*      call vdu_clear_buffer
0416D0             0483*  
0416D0             0484*  ; open the file in read mode
0416D0             0485*  ; Open a file
0416D0             0486*  ; HLU: Filename
0416D0             0487*  ;   C: Mode
0416D0             0488*  ; Returns:
0416D0             0489*  ;   A: Filehandle, or 0 if couldn't open
0416D0 FD E5       0490*  	push iy ; pointer to filename
0416D2 E1          0491*  	pop hl
0416D3 0E 01       0492*  	ld c,fa_read
0416D5             0493*      MOSCALL mos_fopen
0416D5 3E 0A       0001*M 			LD	A, function
0416D7 5B CF       0002*M 			RST.LIL	08h
0416D9 32 14 17 04 0494*      ld (@filehandle),a
0416DD             0495*  
0416DD             0496*  @read_file:
0416DD             0497*  ; Read a block of data from a file
0416DD             0498*  ;   C: Filehandle
0416DD             0499*  ; HLU: Pointer to where to write the data to
0416DD             0500*  ; DEU: Number of bytes to read
0416DD             0501*  ; Returns:
0416DD             0502*  ; DEU: Number of bytes read
0416DD 3A 14 17 04 0503*      ld a,(@filehandle)
0416E1 4F          0504*      ld c,a
0416E2 21 00 E0 B7 0505*      ld hl,filedata
0416E6 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
0416EA             0507*      MOSCALL mos_fread
0416EA 3E 1A       0001*M 			LD	A, function
0416EC 5B CF       0002*M 			RST.LIL	08h
0416EE             0508*  
0416EE             0509*  ; test de for zero bytes read
0416EE 21 00 00 00 0510*      ld hl,0
0416F2 AF          0511*      xor a ; clear carry
0416F3 ED 52       0512*      sbc hl,de
0416F5 CA 0B 17 04 0513*      jp z,@close_file
0416F9             0514*  
0416F9             0515*  ; load a vdu buffer from local memory
0416F9             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0416F9 2A 2D 16 04 0517*      ld hl,(bufferId0)
0416FD D5          0518*      push de ; chunksize
0416FE C1          0519*      pop bc
0416FF 11 00 E0 B7 0520*      ld de,filedata
041703 CD 33 16 04 0521*      call vdu_load_buffer
041707             0522*  
041707             0523*  ; read the next block
041707 C3 DD 16 04 0524*      jp @read_file
04170B             0525*  
04170B             0526*  ; close the file
04170B             0527*  @close_file:
04170B 3A 14 17 04 0528*      ld a,(@filehandle)
04170F             0529*      MOSCALL mos_fclose
04170F 3E 0B       0001*M 			LD	A, function
041711 5B CF       0002*M 			RST.LIL	08h
041713 C9          0530*      ret ; vdu_load_buffer_from_file
041714             0531*  
041714 00          0532*  @filehandle: db 0 ; file handle
041715 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
041718             0534*  
041718 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
04171B             0536*  
04171B             0537*  ; File information structure (FILINFO)
04171B             0538*  @filinfo:
04171B 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
04171F 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041721 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041723 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041724 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041731 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041831             0038       include "vdu_fonts.inc"
041831             0001*  ; select font
041831             0002*  ; inputs: hl = bufferId, a = font flags
041831             0003*  ; Flags:
041831             0004*  ; Bit	Description
041831             0005*  ; 0	Adjust cursor position to ensure text baseline is aligned
041831             0006*  ;   0: Do not adjust cursor position (best for changing font on a new line)
041831             0007*  ;   1: Adjust cursor position (best for changing font in the middle of a line)
041831             0008*  ; 1-7	Reserved for future use
041831             0009*  ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041831             0010*  vdu_font_select:
041831 22 48 18 04 0011*      ld (@bufferId),hl
041835 32 4A 18 04 0012*      ld (@flags),a
041839 21 44 18 04 0013*      ld hl,@cmd
04183D 01 07 00 00 0014*      ld bc,@end-@cmd
041841 5B DF       0015*      rst.lil $18
041843 C9          0016*      ret
041844 17 00 95 00 0017*  @cmd: db 23, 0, 0x95, 0
041848 00 00       0018*  @bufferId: dw 0x0000
04184A 00          0019*  @flags: db 0x00
04184B             0020*  @end:
04184B             0021*  
04184B             0022*  ; create font from buffer
04184B             0023*  ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
04184B             0024*  ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
04184B             0025*  vdu_font_create:
04184B 22 70 18 04 0026*      ld (@bufferId),hl
04184F ED 53 72 18 0027*      ld (@width),de ; also loads height
       04          
041854 32 75 18 04 0028*      ld (@flags),a
041858 7A          0029*      ld a,d ; height
041859 32 74 18 04 0030*      ld (@ascent),a ; ascent = height
04185D             0031*  ; consolidate buffer
04185D CD 8B 16 04 0032*      call vdu_consolidate_buffer
041861             0033*  ; create font
041861 21 6C 18 04 0034*      ld hl,@cmd
041865 01 0A 00 00 0035*      ld bc,@end-@cmd
041869 5B DF       0036*      rst.lil $18
04186B C9          0037*      ret
04186C 17 00 95 01 0038*  @cmd: db 23, 0, 0x95, 1
041870 00 00       0039*  @bufferId: dw 0x0000
041872 00          0040*  @width: db 0x00
041873 00          0041*  @height: db 0x00
041874 00          0042*  @ascent: db 0x00
041875 00          0043*  @flags: db 0x00
041876             0044*  @end:
041876             0045*  
041876             0046*  ; set or adjust font property
041876             0047*  ; inputs: hl = bufferId, a = field, de = value
041876             0048*  ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041876             0049*  vdu_font_property:
041876 22 92 18 04 0050*      ld (@bufferId),hl
04187A 32 94 18 04 0051*      ld (@field),a
04187E ED 53 95 18 0052*      ld (@value),de
       04          
041883 21 8E 18 04 0053*      ld hl,@cmd
041887 01 09 00 00 0054*      ld bc,@end-@cmd
04188B 5B DF       0055*      rst.lil $18
04188D C9          0056*      ret
04188E 17 00 95 02 0057*  @cmd: db 23, 0, 0x95, 2
041892 00 00       0058*  @bufferId: dw 0x0000
041894 00          0059*  @field: db 0x00
041895 00 00       0060*  @value: dw 0x0000
041897 00          0061*  @end: db 0x00 ; padding
041898             0062*  
041898             0063*  ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041898             0064*  
041898             0065*  ; Clear/Delete font
041898             0066*  ; inputs: hl = bufferId
041898             0067*  ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041898             0068*  vdu_font_clear:
041898 22 AB 18 04 0069*      ld (@bufferId),hl
04189C 21 A7 18 04 0070*      ld hl,@cmd
0418A0 01 06 00 00 0071*      ld bc,@end-@cmd
0418A4 5B DF       0072*      rst.lil $18
0418A6 C9          0073*      ret
0418A7 17 00 95 04 0074*  @cmd: db 23, 0, 0x95, 4
0418AB 00 00       0075*  @bufferId: dw 0x0000
0418AD 00          0076*  @end: db 0x00 ; padding
0418AE             0077*  
0418AE             0078*  ; Copy system font to buffer
0418AE             0079*  ; inputs: hl = bufferId
0418AE             0080*  ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
0418AE             0081*  vdu_font_copy_system:
0418AE 22 C1 18 04 0082*      ld (@bufferId),hl
0418B2 21 BD 18 04 0083*      ld hl,@cmd
0418B6 01 06 00 00 0084*      ld bc,@end-@cmd
0418BA 5B DF       0085*      rst.lil $18
0418BC C9          0086*      ret
0418BD 17 00 95 05 0087*  @cmd: db 23, 0, 0x95, 5
0418C1 00 00       0088*  @bufferId: dw 0x0000
0418C3 00          0089*  @end: db 0x00 ; padding
0418C4             0039       include "vdu_plot.inc"
0418C4             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0418C4             0002*  ; PLOT code 	(Decimal) 	Effect
0418C4             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0418C4             0004*  plot_sl_both: equ 0x00
0418C4             0005*  
0418C4             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0418C4             0007*  plot_sl_first: equ 0x08
0418C4             0008*  
0418C4             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0418C4             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0418C4             0011*  
0418C4             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0418C4             0013*  plot_sl_last: equ 0x20
0418C4             0014*  
0418C4             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0418C4             0016*  plot_sl_none: equ 0x28
0418C4             0017*  
0418C4             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0418C4             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0418C4             0020*  
0418C4             0021*  ; &40-&47 	64-71 	Point plot
0418C4             0022*  plot_pt: equ 0x40
0418C4             0023*  
0418C4             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
0418C4             0025*  plot_lf_lr_non_bg: equ 0x48
0418C4             0026*  
0418C4             0027*  ; &50-&57 	80-87 	Triangle fill
0418C4             0028*  plot_tf: equ 0x50
0418C4             0029*  
0418C4             0030*  ; &58-&5F 	88-95 	Line fill right to background Â§Â§
0418C4             0031*  plot_lf_r_bg: equ 0x58
0418C4             0032*  
0418C4             0033*  ; &60-&67 	96-103 	Rectangle fill
0418C4             0034*  plot_rf: equ 0x60
0418C4             0035*  
0418C4             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
0418C4             0037*  plot_lf_lr_fg: equ 0x60
0418C4             0038*  
0418C4             0039*  ; &70-&77 	112-119 	Parallelogram fill
0418C4             0040*  plot_pf: equ 0x70
0418C4             0041*  
0418C4             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
0418C4             0043*  plot_lf_r_non_fg: equ 0x78
0418C4             0044*  
0418C4             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0418C4             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0418C4             0047*  
0418C4             0048*  ; &90-&97 	144-151 	Circle outline
0418C4             0049*  plot_co: equ 0x90
0418C4             0050*  
0418C4             0051*  ; &98-&9F 	152-159 	Circle fill
0418C4             0052*  plot_cf: equ 0x98
0418C4             0053*  
0418C4             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0418C4             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0418C4             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0418C4             0057*  
0418C4             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0418C4             0059*  plot_rcm: equ 0xB8
0418C4             0060*  
0418C4             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0418C4             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0418C4             0063*  ; &D0-&D7 	208-215 	Not defined
0418C4             0064*  ; &D8-&DF 	216-223 	Not defined
0418C4             0065*  ; &E0-&E7 	224-231 	Not defined
0418C4             0066*  
0418C4             0067*  ; &E8-&EF 	232-239 	Bitmap plot Â§
0418C4             0068*  plot_bmp: equ 0xE8
0418C4             0069*  
0418C4             0070*  ; &F0-&F7 	240-247 	Not defined
0418C4             0071*  ; &F8-&FF 	248-255 	Not defined
0418C4             0072*  
0418C4             0073*  ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
0418C4             0074*  ; Agon Console8 VDP 2.2.0
0418C4             0075*  
0418C4             0076*  ; Within each group of eight plot codes, the effects are as follows:
0418C4             0077*  ; Plot code 	Effect
0418C4             0078*  ; 0 	Move relative
0418C4             0079*  mv_rel: equ 0
0418C4             0080*  
0418C4             0081*  ; 1 	Plot relative in current foreground colour
0418C4             0082*  dr_rel_fg: equ 1
0418C4             0083*  
0418C4             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0418C4             0085*  ; 3 	Plot relative in current background colour
0418C4             0086*  dr_rel_bg: equ 3
0418C4             0087*  
0418C4             0088*  ; 4 	Move absolute
0418C4             0089*  mv_abs: equ 4
0418C4             0090*  
0418C4             0091*  ; 5 	Plot absolute in current foreground colour
0418C4             0092*  dr_abs_fg: equ 5
0418C4             0093*  
0418C4             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0418C4             0095*  ; 7 	Plot absolute in current background colour
0418C4             0096*  dr_abs_bg: equ 7
0418C4             0097*  
0418C4             0098*  ; Codes 0-3 use the position data provided as part of the command
0418C4             0099*  ; as a relative position, adding the position given to the current
0418C4             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0418C4             0101*  ; as part of the command as an absolute position, setting the current
0418C4             0102*  ; graphical cursor position to the position given.
0418C4             0103*  
0418C4             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0418C4             0105*  ; current pixel colour. These operations cannot currently be supported
0418C4             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0418C4             0107*  ; supported. Support for these codes may be added in a future version
0418C4             0108*  ; of the VDP firmware.
0418C4             0109*  
0418C4             0110*  ; 16 colour palette constants
0418C4             0111*  c_black: equ 0
0418C4             0112*  c_red_dk: equ 1
0418C4             0113*  c_green_dk: equ 2
0418C4             0114*  c_yellow_dk: equ 3
0418C4             0115*  c_blue_dk: equ 4
0418C4             0116*  c_magenta_dk: equ 5
0418C4             0117*  c_cyan_dk: equ 6
0418C4             0118*  c_grey: equ 7
0418C4             0119*  c_grey_dk: equ 8
0418C4             0120*  c_red: equ 9
0418C4             0121*  c_green: equ 10
0418C4             0122*  c_yellow: equ 11
0418C4             0123*  c_blue: equ 12
0418C4             0124*  c_magenta: equ 13
0418C4             0125*  c_cyan: equ 14
0418C4             0126*  c_white: equ 15
0418C4             0127*  
0418C4             0128*  ; VDU 25, mode, x; y;: PLOT command
0418C4             0129*  ; inputs: a=mode, bc=x0, de=y0
0418C4             0130*  vdu_plot:
0418C4 32 DE 18 04 0131*      ld (@mode),a
0418C8 ED 43 DF 18 0132*      ld (@x0),bc
       04          
0418CD ED 53 E1 18 0133*      ld (@y0),de
       04          
0418D2 21 DD 18 04 0134*  	ld hl,@cmd
0418D6 01 06 00 00 0135*  	ld bc,@end-@cmd
0418DA 5B DF       0136*  	rst.lil $18
0418DC C9          0137*  	ret
0418DD 19          0138*  @cmd:   db 25
0418DE 00          0139*  @mode:  db 0
0418DF 00 00       0140*  @x0: 	dw 0
0418E1 00 00       0141*  @y0: 	dw 0
0418E3 00          0142*  @end:   db 0 ; extra byte to soak up deu
0418E4             0143*  
0418E4             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0418E4             0145*  ; &E8-&EF 	232-239 	Bitmap plot Â§
0418E4             0146*  ; VDU 25, mode, x; y;: PLOT command
0418E4             0147*  ; inputs: bc=x0, de=y0
0418E4             0148*  ; prerequisites: vdu_buff_select
0418E4             0149*  vdu_plot_bmp:
0418E4 ED 43 FB 18 0150*      ld (@x0),bc
       04          
0418E9 ED 53 FD 18 0151*      ld (@y0),de
       04          
0418EE 21 F9 18 04 0152*  	ld hl,@cmd
0418F2 01 06 00 00 0153*  	ld bc,@end-@cmd
0418F6 5B DF       0154*  	rst.lil $18
0418F8 C9          0155*  	ret
0418F9 19          0156*  @cmd:   db 25
0418FA ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0418FB 00 00       0158*  @x0: 	dw 0x0000
0418FD 00 00       0159*  @y0: 	dw 0x0000
0418FF 00          0160*  @end:   db 0x00 ; padding
041900             0161*  
041900             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041900             0163*  ; &E8-&EF 	232-239 	Bitmap plot Â§
041900             0164*  ; VDU 25, mode, x; y;: PLOT command
041900             0165*  ; inputs: bc=x0, de=y0
041900             0166*  ; USING 16.8 FIXED POINT COORDINATES
041900             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041900             0168*  ;   the fractional portiion of the inputs are truncated
041900             0169*  ;   leaving only the 16-bit integer portion
041900             0170*  ; prerequisites: vdu_buff_select
041900             0171*  vdu_plot_bmp168:
041900             0172*  ; populate in the reverse of normal to keep the
041900             0173*  ; inputs from stomping on each other
041900 ED 53 1E 19 0174*      ld (@y0-1),de
       04          
041905 ED 43 1C 19 0175*      ld (@x0-1),bc
       04          
04190A 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
04190C 32 1C 19 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
041910 21 1B 19 04 0178*  	ld hl,@cmd
041914 01 06 00 00 0179*  	ld bc,@end-@cmd
041918 5B DF       0180*  	rst.lil $18
04191A C9          0181*  	ret
04191B 19          0182*  @cmd:   db 25
04191C ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
04191D 00 00       0184*  @x0: 	dw 0x0000
04191F 00 00       0185*  @y0: 	dw 0x0000
041921             0186*  @end:  ; no padding required b/c we shifted de right
041921             0187*  
041921             0188*  ; draw a filled rectangle
041921             0189*  vdu_plot_rf:
041921 ED 43 48 19 0190*      ld (@x0),bc
       04          
041926 ED 53 4A 19 0191*      ld (@y0),de
       04          
04192B DD 22 4E 19 0192*      ld (@x1),ix
       04          
041930 FD 22 50 19 0193*      ld (@y1),iy
       04          
041935 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041937 32 4C 19 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04193B 21 46 19 04 0196*  	ld hl,@cmd0
04193F 01 0C 00 00 0197*  	ld bc,@end-@cmd0
041943 5B DF       0198*  	rst.lil $18
041945 C9          0199*      ret
041946 19          0200*  @cmd0:  db 25 ; plot
041947 04          0201*  @arg0:  db plot_sl_both+mv_abs
041948 00 00       0202*  @x0:    dw 0x0000
04194A 00 00       0203*  @y0:    dw 0x0000
04194C 19          0204*  @cmd1:  db 25 ; plot
04194D 65          0205*  @arg1:  db plot_rf+dr_abs_fg
04194E 00 00       0206*  @x1:    dw 0x0000
041950 00 00       0207*  @y1:    dw 0x0000
041952 00          0208*  @end:   db 0x00 ; padding
041953             0209*  
041953             0210*  ; draw a filled circle
041953             0211*  vdu_plot_cf:
041953 ED 43 7A 19 0212*      ld (@x0),bc
       04          
041958 ED 53 7C 19 0213*      ld (@y0),de
       04          
04195D DD 22 80 19 0214*      ld (@x1),ix
       04          
041962 FD 22 82 19 0215*      ld (@y1),iy
       04          
041967 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
041969 32 7E 19 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
04196D 21 78 19 04 0218*  	ld hl,@cmd0
041971 01 0C 00 00 0219*  	ld bc,@end-@cmd0
041975 5B DF       0220*  	rst.lil $18
041977 C9          0221*      ret
041978 19          0222*  @cmd0:  db 25 ; plot
041979 04          0223*  @arg0:  db plot_sl_both+mv_abs
04197A 00 00       0224*  @x0:    dw 0x0000
04197C 00 00       0225*  @y0:    dw 0x0000
04197E 19          0226*  @cmd1:  db 25 ; plot
04197F 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
041980 00 00       0228*  @x1:    dw 0x0000
041982 00 00       0229*  @y1:    dw 0x0000
041984 00          0230*  @end:   db 0x00 ; padding
041985             0040       include "vdu_sprites.inc"
041985             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
041985             0002*  ; the VDP can support up to 256 sprites. They must be defined
041985             0003*  ; contiguously, and so the first sprite is sprite 0.
041985             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
041985             0005*  ; Once a selection of sprites have been defined, you can activate
041985             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
041985             0007*  ; of sprites to activate. This will activate the first n sprites,
041985             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
041985             0009*  
041985             0010*  ; A single sprite can have multiple "frames", referring to
041985             0011*  ; different bitmaps.
041985             0012*  ; (These bitmaps do not need to be the same size.)
041985             0013*  ; This allows a sprite to include an animation sequence,
041985             0014*  ; which can be stepped through one frame at a time, or picked
041985             0015*  ; in any order.
041985             0016*  
041985             0017*  ; Any format of bitmap can be used as a sprite frame. It should
041985             0018*  ; be noted however that "native" format bitmaps are not
041985             0019*  ; recommended for use as sprite frames, as they cannot get
041985             0020*  ; erased from the screen. (As noted above, the "native" bitmap
041985             0021*  ; format is not really intended for general use.) This is part
041985             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
041985             0023*  ; screen are now stored in RGBA2222 format.
041985             0024*  
041985             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
041985             0026*  ; and then later shown again.
041985             0027*  
041985             0028*  ; Moving sprites around the screen is done by changing the
041985             0029*  ; position of the sprite. This can be done either by setting
041985             0030*  ; the absolute position of the sprite, or by moving the sprite
041985             0031*  ; by a given number of pixels. (Sprites are positioned using
041985             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
041985             0033*  ; In the current sprite system, sprites will not update their
041985             0034*  ; position on-screen until either another drawing operation is
041985             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
041985             0036*  
041985             0037*  ; VDU 23, 27, 4, n: Select sprite n
041985             0038*  ; inputs: a is the 8-bit sprite id
041985             0039*  vdu_sprite_select:
041985 32 97 19 04 0040*      ld (@sprite),a
041989 21 94 19 04 0041*      ld hl,@cmd
04198D 01 04 00 00 0042*      ld bc,@end-@cmd
041991 5B DF       0043*      rst.lil $18
041993 C9          0044*      ret
041994 17 1B 04    0045*  @cmd:    db 23,27,4
041997 00          0046*  @sprite: db 0x00
041998             0047*  @end:
041998             0048*  
041998             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
041998             0050*  ; inputs: none
041998             0051*  ; prerequisites: vdu_sprite_select
041998             0052*  vdu_sprite_clear_frames:
041998 21 A3 19 04 0053*      ld hl,@cmd
04199C 01 03 00 00 0054*      ld bc,@end-@cmd
0419A0 5B DF       0055*      rst.lil $18
0419A2 C9          0056*      ret
0419A3 17 1B 05    0057*  @cmd: db 23,27,5
0419A6             0058*  @end:
0419A6             0059*  
0419A6             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0419A6             0061*  ; inputs: a is the 8-bit bitmap number
0419A6             0062*  ; prerequisites: vdu_sprite_select
0419A6             0063*  vdu_sprite_add_bmp:
0419A6 32 B8 19 04 0064*      ld (@bmp),a
0419AA 21 B5 19 04 0065*      ld hl,@cmd
0419AE 01 04 00 00 0066*      ld bc,@end-@cmd
0419B2 5B DF       0067*      rst.lil $18
0419B4 C9          0068*      ret
0419B5 17 1B 06    0069*  @cmd: db 23,27,6
0419B8 00          0070*  @bmp: db 0x00
0419B9             0071*  @end:
0419B9             0072*  
0419B9             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0419B9             0074*  ; inputs: a is the number of sprites to activate
0419B9             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0419B9             0076*  vdu_sprite_activate:
0419B9 32 CB 19 04 0077*      ld (@num),a
0419BD 21 C8 19 04 0078*      ld hl,@cmd
0419C1 01 04 00 00 0079*      ld bc,@end-@cmd
0419C5 5B DF       0080*      rst.lil $18
0419C7 C9          0081*      ret
0419C8 17 1B 07    0082*  @cmd: db 23,27,7
0419CB 00          0083*  @num: db 0x00
0419CC             0084*  @end:
0419CC             0085*  
0419CC             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
0419CC             0087*  ; inputs: none
0419CC             0088*  ; prerequisites: vdu_sprite_select
0419CC             0089*  vdu_sprite_next_frame:
0419CC 21 D7 19 04 0090*      ld hl,@cmd
0419D0 01 03 00 00 0091*      ld bc,@end-@cmd
0419D4 5B DF       0092*      rst.lil $18
0419D6 C9          0093*      ret
0419D7 17 1B 08    0094*  @cmd: db 23,27,8
0419DA             0095*  @end:
0419DA             0096*  
0419DA             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
0419DA             0098*  ; inputs: none
0419DA             0099*  ; prerequisites: vdu_sprite_select
0419DA             0100*  vdu_sprite_prev_frame:
0419DA 21 E5 19 04 0101*      ld hl,@cmd
0419DE 01 03 00 00 0102*      ld bc,@end-@cmd
0419E2 5B DF       0103*      rst.lil $18
0419E4 C9          0104*      ret
0419E5 17 1B 09    0105*  @cmd: db 23,27,9
0419E8             0106*  @end:
0419E8             0107*  
0419E8             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
0419E8             0109*  ; inputs: a is frame number to select
0419E8             0110*  ; prerequisites: vdu_sprite_select
0419E8             0111*  vdu_sprite_select_frame:
0419E8 32 FA 19 04 0112*      ld (@frame),a
0419EC 21 F7 19 04 0113*      ld hl,@cmd
0419F0 01 04 00 00 0114*      ld bc,@end-@cmd
0419F4 5B DF       0115*      rst.lil $18
0419F6 C9          0116*      ret
0419F7 17 1B 0A    0117*  @cmd:    db 23,27,10
0419FA 00          0118*  @frame:  db 0x00
0419FB             0119*  @end:
0419FB             0120*  
0419FB             0121*  ; VDU 23, 27, 11: Show current sprite
0419FB             0122*  ; inputs: none
0419FB             0123*  ; prerequisites: vdu_sprite_select
0419FB             0124*  vdu_sprite_show:
0419FB 21 06 1A 04 0125*      ld hl,@cmd
0419FF 01 03 00 00 0126*      ld bc,@end-@cmd
041A03 5B DF       0127*      rst.lil $18
041A05 C9          0128*      ret
041A06 17 1B 0B    0129*  @cmd: db 23,27,11
041A09             0130*  @end:
041A09             0131*  
041A09             0132*  ; VDU 23, 27, 12: Hide current sprite
041A09             0133*  ; inputs: none
041A09             0134*  ; prerequisites: vdu_sprite_select
041A09             0135*  vdu_sprite_hide:
041A09 21 14 1A 04 0136*      ld hl,@cmd
041A0D 01 03 00 00 0137*      ld bc,@end-@cmd
041A11 5B DF       0138*      rst.lil $18
041A13 C9          0139*      ret
041A14 17 1B 0C    0140*  @cmd: db 23,27,12
041A17             0141*  @end:
041A17             0142*  
041A17             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
041A17             0144*  ; inputs: bc is x coordinate, de is y coordinate
041A17             0145*  ; prerequisites: vdu_sprite_select
041A17             0146*  vdu_sprite_move_abs:
041A17 ED 43 2F 1A 0147*      ld (@xpos),bc
       04          
041A1C ED 53 31 1A 0148*      ld (@ypos),de
       04          
041A21 21 2C 1A 04 0149*      ld hl,@cmd
041A25 01 07 00 00 0150*      ld bc,@end-@cmd
041A29 5B DF       0151*      rst.lil $18
041A2B C9          0152*      ret
041A2C 17 1B 0D    0153*  @cmd:  db 23,27,13
041A2F 00 00       0154*  @xpos: dw 0x0000
041A31 00 00       0155*  @ypos: dw 0x0000
041A33 00          0156*  @end:  db 0x00 ; padding
041A34             0157*  
041A34             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
041A34             0159*  ; inputs: bc is x coordinate, de is y coordinate
041A34             0160*  ; prerequisites: vdu_sprite_select
041A34             0161*  vdu_sprite_move_rel:
041A34 ED 43 4C 1A 0162*      ld (@dx),bc
       04          
041A39 ED 53 4E 1A 0163*      ld (@dy),de
       04          
041A3E 21 49 1A 04 0164*      ld hl,@cmd
041A42 01 07 00 00 0165*      ld bc,@end-@cmd
041A46 5B DF       0166*      rst.lil $18
041A48 C9          0167*      ret
041A49 17 1B 0E    0168*  @cmd: db 23,27,14
041A4C 00 00       0169*  @dx:  dw 0x0000
041A4E 00 00       0170*  @dy:  dw 0x0000
041A50 00          0171*  @end: db 0x00 ; padding
041A51             0172*  
041A51             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
041A51             0174*  ; USING 16.8 FIXED POINT COORDINATES
041A51             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
041A51             0176*  ;   the fractional portiion of the inputs are truncated
041A51             0177*  ;   leaving only the 16-bit integer portion
041A51             0178*  ; prerequisites: vdu_sprite_select
041A51             0179*  vdu_sprite_move_abs168:
041A51             0180*  ; offset inputs by the gfx origin
041A51             0181*  ; y coordinate
041A51 21 00 00 00 0182*      ld hl,origin_top*256
041A55 19          0183*      add hl,de
041A56 22 78 1A 04 0184*      ld (@ypos-1),hl
041A5A             0185*  ; x coordinate
041A5A 21 00 80 00 0186*      ld hl,origin_left*256
041A5E 09          0187*      add hl,bc
041A5F 22 76 1A 04 0188*      ld (@xpos-1),hl
041A63             0189*  ; prepare vdu command
041A63 3E 0D       0190*      ld a,13       ; restore the final byte of the command
041A65 32 76 1A 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
041A69 21 74 1A 04 0192*      ld hl,@cmd
041A6D 01 07 00 00 0193*      ld bc,@end-@cmd
041A71 5B DF       0194*      rst.lil $18
041A73 C9          0195*      ret
041A74 17 1B 0D    0196*  @cmd:  db 23,27,13
041A77 00 00       0197*  @xpos: dw 0x0000
041A79 00 00       0198*  @ypos: dw 0x0000
041A7B             0199*  @end:  ; no padding required b/c we shifted de right
041A7B             0200*  
041A7B             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
041A7B             0202*  ; USING 16.8 FIXED POINT COORDINATES
041A7B             0203*  ; inputs: ub.c is dx, ud.e is dy
041A7B             0204*  ;   the fractional portiion of the inputs are truncated
041A7B             0205*  ;   leaving only the 16-bit integer portion
041A7B             0206*  ; prerequisites: vdu_sprite_select
041A7B             0207*  vdu_sprite_move_rel168:
041A7B             0208*  ; populate in the reverse of normal to keep the
041A7B             0209*  ; inputs from stomping on each other
041A7B ED 53 9A 1A 0210*      ld (@dy-1),de
       04          
041A80 ED 43 98 1A 0211*      ld (@dx-1),bc
       04          
041A85 3E 0E       0212*      ld a,14       ; restore the final byte of the command
041A87 32 98 1A 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
041A8B 21 96 1A 04 0214*      ld hl,@cmd
041A8F 01 07 00 00 0215*      ld bc,@end-@cmd
041A93 5B DF       0216*      rst.lil $18
041A95 C9          0217*      ret
041A96 17 1B 0E    0218*  @cmd:  db 23,27,14
041A99 00 00       0219*  @dx: dw 0x0000
041A9B 00 00       0220*  @dy: dw 0x0000
041A9D             0221*  @end:  ; no padding required b/c we shifted de right
041A9D             0222*  
041A9D             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
041A9D             0224*  ; inputs: none
041A9D             0225*  vdu_sprite_update:
041A9D 21 A8 1A 04 0226*      ld hl,@cmd
041AA1 01 03 00 00 0227*      ld bc,@end-@cmd
041AA5 5B DF       0228*      rst.lil $18
041AA7 C9          0229*      ret
041AA8 17 1B 0F    0230*  @cmd: db 23,27,15
041AAB             0231*  @end:
041AAB             0232*  
041AAB             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
041AAB             0234*  ; inputs: none
041AAB             0235*  vdu_sprite_bmp_reset:
041AAB 21 B6 1A 04 0236*      ld hl,@cmd
041AAF 01 03 00 00 0237*      ld bc,@end-@cmd
041AB3 5B DF       0238*      rst.lil $18
041AB5 C9          0239*      ret
041AB6 17 1B 10    0240*  @cmd: db 23,27,16
041AB9             0241*  @end:
041AB9             0242*  
041AB9             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
041AB9             0244*  ; inputs: none
041AB9             0245*  vdu_sprite_reset:
041AB9 21 C4 1A 04 0246*      ld hl,@cmd
041ABD 01 03 00 00 0247*      ld bc,@end-@cmd
041AC1 5B DF       0248*      rst.lil $18
041AC3 C9          0249*      ret
041AC4 17 1B 11    0250*  @cmd: db 23,27,17
041AC7             0251*  @end:
041AC7             0252*  
041AC7             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
041AC7             0254*  ; inputs: a is the GCOL paint mode
041AC7             0255*  ; prerequisites: vdu_sprite_select
041AC7             0256*  vdu_sprite_set_gcol:
041AC7 32 D9 1A 04 0257*      ld (@mode),a
041ACB 21 D6 1A 04 0258*      ld hl,@cmd
041ACF 01 04 00 00 0259*      ld bc,@end-@cmd
041AD3 5B DF       0260*      rst.lil $18
041AD5 C9          0261*      ret
041AD6 17 1B 12    0262*  @cmd:  db 23,27,18
041AD9 00          0263*  @mode: db 0x00
041ADA             0264*  @end:
041ADA             0265*  
041ADA             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
041ADA             0267*  ; inputs: hl=bufferId
041ADA             0268*  ; prerequisites: vdu_sprite_select
041ADA             0269*  vdu_sprite_add_buff:
041ADA 22 EC 1A 04 0270*      ld (@bufferId),hl
041ADE 21 E9 1A 04 0271*      ld hl,@cmd
041AE2 01 05 00 00 0272*      ld bc,@end-@cmd
041AE6 5B DF       0273*      rst.lil $18
041AE8 C9          0274*      ret
041AE9 17 1B 26    0275*  @cmd:      db 23,27,0x26
041AEC 00 00       0276*  @bufferId: dw 0x0000
041AEE 00          0277*  @end:      db 0x00 ; padding
041AEF             0041   
041AEF             0042   ; APPLICATION INCLUDES
041AEF             0043       include "collisions.inc"
041AEF             0001*  ; ====== COLLISION DETECTION ======
041AEF             0002*  ; --- constants ---
041AEF             0003*  ; sprite_collisions flags
041AEF             0004*  collides_with_player: equ 0
041AEF             0005*  collides_with_laser: equ 1
041AEF             0006*  sprite_alive: equ 6 ; set when sprite is alive
041AEF             0007*  sprite_just_died: equ 7 ; set when sprite just died
041AEF             0008*  
041AEF             0009*  ; TODO: make these bit numbers instead of masks
041AEF             0010*  collide_top: equ %00001000
041AEF             0011*  collide_bottom: equ %00000100
041AEF             0012*  collide_left: equ %00000010
041AEF             0013*  collide_right: equ %00000001
041AEF             0014*  ; END TODO
041AEF             0015*  
041AEF             0016*  ; this routine detects collisions between two collidable objects,
041AEF             0017*  ; which can include sprites, active tiles, or any screen coordinate
041AEF             0018*  ; which has been set up with a sprite table structure that includes dim_x
041AEF             0019*  ; representing the radius of the collidable object
041AEF             0020*  ; inputs: ix and iy point to the colliding objects' sprite table records
041AEF             0021*  ; outputs: uh.l = distance - sum of radii
041AEF             0022*  ;          zero flag set or sign flag negative if collision detected
041AEF             0023*  ;          dx168 and dy168 are also populated with the signed displacements
041AEF             0024*  ; destroys: everything except indexes
041AEF             0025*  check_collision:
041AEF             0026*  ; compute dx = x1-x0
041AEF DD 27 0B    0027*      ld hl,(ix+sprite_x)
041AF2 FD 17 0B    0028*      ld de,(iy+sprite_x)
041AF5 AF          0029*      xor a ; clear carry
041AF6 ED 52       0030*      sbc hl,de
041AF8 22 68 0A 04 0031*      ld (dx168),hl ; dx to scratch
041AFC             0032*  ; compute dy = y1-y0
041AFC DD 27 0E    0033*      ld hl,(ix+sprite_y)
041AFF FD 17 0E    0034*      ld de,(iy+sprite_y)
041B02 AF          0035*      xor a ; clear carry
041B03 ED 52       0036*      sbc hl,de ; hl = dy
041B05 22 6E 0A 04 0037*      ld (dy168),hl ; dy to scratch
041B09             0038*  ; compute euclidean distance between centers
041B09 CD 74 0A 04 0039*      call distance168 ; uh.l = distance
041B0D             0040*  ; check for overlap by summing half the radii
041B0D DD 7E 09    0041*      ld a,(ix+sprite_dim_x)
041B10 CB 3F       0042*      srl a ; divide by 2
041B12 FD 5E 09    0043*      ld e,(iy+sprite_dim_x)
041B15 CB 3B       0044*      srl e ; divide by 2
041B17 83          0045*      add a,e
041B18 11 00 00 00 0046*      ld de,0 ; clear deu and e
041B1C 57          0047*      ld d,a ; ud.e = sum of radii
041B1D B7          0048*      or a ; clear carry
041B1E ED 52       0049*      sbc hl,de ; uh.l = distance - sum of radii
041B20 C9          0050*      ret
041B21             0051*  ; end check_collision
041B21             0044       include "enemies.inc"
041B21 04          0001*  max_enemy_sprites: db 4
041B22             0002*  
041B22             0003*  ; sprite_type
041B22             0004*  enemy_dead: equ 0
041B22             0005*  enemy_seeker: equ 1
041B22             0006*  enemy_medium: equ 2
041B22             0007*  enemy_large: equ 3
041B22             0008*  landing_pad: equ 4
041B22             0009*  laser_turret: equ 5
041B22             0010*  fireballs: equ 6
041B22             0011*  explosion: equ 7
041B22             0012*  
041B22             0013*  move_enemies:
041B22             0014*  ; are there any active enemies or explosions?
041B22 3A F9 40 04 0015*      ld a,(table_active_sprites)
041B26 A7          0016*      and a ; will be zero if no alive enemies or explosions
041B27 C2 34 1B 04 0017*      jp nz,@they_live
041B2B 21 33 43 04 0018*      ld hl,enemies_dead
041B2F 22 30 43 04 0019*      ld (enemies_state),hl
041B33 C9          0020*      ret
041B34             0021*  @they_live:
041B34             0022*  ; initialize pointers and loop counter
041B34 FD 21 96 3E 0023*      ld iy,table_base ; set iy to first record in table
       04          
041B39 06 10       0024*      ld b,table_max_records ; loop counter
041B3B             0025*  @move_loop:
041B3B FD 22 F6 40 0026*      ld (table_pointer),iy ; update table pointer
       04          
041B40 C5          0027*      push bc ; backup loop counter
041B41             0028*  ; check sprite_type to see if sprite is active
041B41 FD 7E 01    0029*      ld a,(iy+sprite_type)
041B44 A7          0030*      and a ; if zero, sprite is dead
041B45 CA 78 1B 04 0031*      jp z,@next_record ; ... and we skip to next record
041B49             0032*  ; otherwise we prepare to move the sprite
041B49 FD 7E 00    0033*      ld a,(iy+sprite_id) ; get spriteId
041B4C CD 85 19 04 0034*      call vdu_sprite_select ; select sprite
041B50 FD 27 05    0035*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
041B53             0036*      callHL
041B53 01 59 1B 04 0001*M     ld bc,@F ; Address of first instruction after the jump
041B57 C5          0002*M     push bc ; which constitutes the return address
041B58 E9          0003*M     jp (hl) ; Jump to the address in HL
041B59             0004*M @@:
041B59             0037*  ; move_enemies_loop_return: return from behavior subroutines
041B59 FD 2A F6 40 0038*      ld iy,(table_pointer) ; get back table pointer
       04          
041B5E             0039*  ; now we check results of all the moves
041B5E FD CB 08 7E 0040*      bit sprite_just_died,(iy+sprite_collisions)
041B62 CA 6E 1B 04 0041*      jp z,@draw_sprite ; if not dead, draw sprite
041B66 CD 42 41 04 0042*      call table_deactivate_sprite
041B6A C3 78 1B 04 0043*      jp @next_record ; and to the next record
041B6E             0044*  @draw_sprite:
041B6E FD 07 0B    0045*      ld bc,(iy+sprite_x)
041B71 FD 17 0E    0046*      ld de,(iy+sprite_y)
041B74 CD 51 1A 04 0047*      call vdu_sprite_move_abs168
041B78             0048*  ; fall through to @next_record
041B78             0049*  @next_record:
041B78 ED 33 26    0050*      lea iy,iy+table_bytes_per_record
041B7B AF          0051*      xor a ; clears carry flag
041B7C 32 FA 40 04 0052*      ld (sprite_screen_edge),a ; clear screen edge collision flag
041B80 C1          0053*      pop bc ; get back our loop counter
041B81 10 B8       0054*      djnz @move_loop ; loop until we've checked all the records
041B83 C9          0055*      ret ; and we're out
041B84             0056*  
041B84             0057*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
041B84             0058*  ; ; each sprite in the table must have one of these defined
041B84             0059*  ; ; but they need not be unique to a particular sprite
041B84             0060*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
041B84             0061*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
041B84             0062*  ; ; but they can call anything they want between those two endpoints
041B84             0063*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
041B84             0064*  
041B84             0065*  check_enemy_player_collisions:
041B84             0066*  ; check for collisions with player
041B84 DD 21 06 3D 0067*      ld ix,player_start_variables
       04          
041B89 DD CB 08 76 0068*      bit sprite_alive,(ix+sprite_collisions)
041B8D C8          0069*      ret z ; player dead, no collision
041B8E CD EF 1A 04 0070*      call check_collision
041B92 F0          0071*      ret p ; no collision
041B93 C3 BE 1B 04 0072*      jp enemy_kill
041B97             0073*  ; end move_enemy_seeker
041B97             0074*  orientation_to_player:
041B97 FD 2A F6 40 0075*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
041B9C FD 07 0B    0076*      ld bc,(iy+sprite_x)
041B9F FD 17 0E    0077*      ld de,(iy+sprite_y)
041BA2 DD 2A 11 3D 0078*      ld ix,(player_x)
       04          
041BA7 FD 2A 14 3D 0079*      ld iy,(player_y)
       04          
041BAC CD 4D 0A 04 0080*      call dxy168
041BB0 C5          0081*      push bc
041BB1 D5          0082*      push de
041BB2 CD A9 0A 04 0083*      call atan2_168fast
041BB6 D1          0084*      pop de
041BB7 C1          0085*      pop bc
041BB8 FD 2A F6 40 0086*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
041BBD C9          0087*      ret
041BBE             0088*  
041BBE             0089*  ; this routine vanquishes the enemy sprite
041BBE             0090*  ; inputs: table_pointer set to sprite record
041BBE             0091*  ; destroys: everything except index registers
041BBE             0092*  ; returns: an incandescent ball of debris and gas
041BBE             0093*  enemy_kill:
041BBE FD 2A F6 40 0094*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
041BC3             0095*  ; tally up points
041BC3 2A 02 3D 04 0096*      ld hl,(player_score)
041BC7 01 00 00 00 0097*      ld bc,0 ; clear bcu
041BCB FD 4E 24    0098*      ld c,(iy+sprite_points)
041BCE 09          0099*      add hl,bc
041BCF 22 02 3D 04 0100*      ld (player_score),hl
041BD3 FD CB 08 FE 0101*      set sprite_just_died,(iy+sprite_collisions)
041BD7 C9          0102*      ret
041BD8             0103*  ; end enemy_kill
041BD8             0045       include "images_sprites.inc"
041BD8             0001*  ; Generated by beegee747/build/scripts/build_99_asm_img_load.py
041BD8             0002*  
041BD8             0003*  sprites_num_images: equ 113
041BD8             0004*  
041BD8             0005*  ; buffer_ids:
041BD8             0006*  BUF_BLINKY_0: equ 256
041BD8             0007*  BUF_BLINKY_1: equ 257
041BD8             0008*  BUF_BLINKY_2: equ 258
041BD8             0009*  BUF_BLINKY_3: equ 259
041BD8             0010*  BUF_BLINKY_4: equ 260
041BD8             0011*  BUF_BLINKY_5: equ 261
041BD8             0012*  BUF_BLINKY_6: equ 262
041BD8             0013*  BUF_BLINKY_7: equ 263
041BD8             0014*  BUF_CLYDE_0: equ 264
041BD8             0015*  BUF_CLYDE_1: equ 265
041BD8             0016*  BUF_CLYDE_2: equ 266
041BD8             0017*  BUF_CLYDE_3: equ 267
041BD8             0018*  BUF_CLYDE_4: equ 268
041BD8             0019*  BUF_CLYDE_5: equ 269
041BD8             0020*  BUF_CLYDE_6: equ 270
041BD8             0021*  BUF_CLYDE_7: equ 271
041BD8             0022*  BUF_FRUIT_0: equ 272
041BD8             0023*  BUF_FRUIT_1: equ 273
041BD8             0024*  BUF_FRUIT_2: equ 274
041BD8             0025*  BUF_FRUIT_3: equ 275
041BD8             0026*  BUF_FRUIT_4: equ 276
041BD8             0027*  BUF_FRUIT_5: equ 277
041BD8             0028*  BUF_FRUIT_6: equ 278
041BD8             0029*  BUF_FRUIT_7: equ 279
041BD8             0030*  BUF_INKY_0: equ 280
041BD8             0031*  BUF_INKY_1: equ 281
041BD8             0032*  BUF_INKY_2: equ 282
041BD8             0033*  BUF_INKY_3: equ 283
041BD8             0034*  BUF_INKY_4: equ 284
041BD8             0035*  BUF_INKY_5: equ 285
041BD8             0036*  BUF_INKY_6: equ 286
041BD8             0037*  BUF_INKY_7: equ 287
041BD8             0038*  BUF_MAZE_PELLETS_00: equ 288
041BD8             0039*  BUF_MAZE_PELLETS_01: equ 289
041BD8             0040*  BUF_MAZE_PELLETS_02: equ 290
041BD8             0041*  BUF_PAC_BIG_00_00: equ 291
041BD8             0042*  BUF_PAC_BIG_00_01: equ 292
041BD8             0043*  BUF_PAC_BIG_00_02: equ 293
041BD8             0044*  BUF_PAC_DED_00_00: equ 294
041BD8             0045*  BUF_PAC_DED_00_01: equ 295
041BD8             0046*  BUF_PAC_DED_00_02: equ 296
041BD8             0047*  BUF_PAC_DED_00_03: equ 297
041BD8             0048*  BUF_PAC_DED_00_04: equ 298
041BD8             0049*  BUF_PAC_DED_00_05: equ 299
041BD8             0050*  BUF_PAC_DED_00_06: equ 300
041BD8             0051*  BUF_PAC_DED_00_07: equ 301
041BD8             0052*  BUF_PAC_DED_00_08: equ 302
041BD8             0053*  BUF_PAC_DED_00_09: equ 303
041BD8             0054*  BUF_PAC_DED_00_10: equ 304
041BD8             0055*  BUF_PAC_LIV_00_00: equ 305
041BD8             0056*  BUF_PAC_MAN_00_00: equ 306
041BD8             0057*  BUF_PAC_MAN_00_01: equ 307
041BD8             0058*  BUF_PAC_MAN_00_02: equ 308
041BD8             0059*  BUF_PAC_MAN_01_00: equ 309
041BD8             0060*  BUF_PAC_MAN_01_01: equ 310
041BD8             0061*  BUF_PAC_MAN_01_02: equ 311
041BD8             0062*  BUF_PAC_MAN_02_00: equ 312
041BD8             0063*  BUF_PAC_MAN_02_01: equ 313
041BD8             0064*  BUF_PAC_MAN_02_02: equ 314
041BD8             0065*  BUF_PAC_MAN_03_00: equ 315
041BD8             0066*  BUF_PAC_MAN_03_01: equ 316
041BD8             0067*  BUF_PAC_MAN_03_02: equ 317
041BD8             0068*  BUF_PINKY_0: equ 318
041BD8             0069*  BUF_PINKY_1: equ 319
041BD8             0070*  BUF_PINKY_2: equ 320
041BD8             0071*  BUF_PINKY_3: equ 321
041BD8             0072*  BUF_PINKY_4: equ 322
041BD8             0073*  BUF_PINKY_5: equ 323
041BD8             0074*  BUF_PINKY_6: equ 324
041BD8             0075*  BUF_PINKY_7: equ 325
041BD8             0076*  BUF_REVERSE_0: equ 326
041BD8             0077*  BUF_REVERSE_1: equ 327
041BD8             0078*  BUF_REVERSE_2: equ 328
041BD8             0079*  BUF_REVERSE_3: equ 329
041BD8             0080*  BUF_REVERSE_4: equ 330
041BD8             0081*  BUF_REVERSE_5: equ 331
041BD8             0082*  BUF_REVERSE_6: equ 332
041BD8             0083*  BUF_REVERSE_7: equ 333
041BD8             0084*  BUF_TILE_00: equ 334
041BD8             0085*  BUF_TILE_01: equ 335
041BD8             0086*  BUF_TILE_02: equ 336
041BD8             0087*  BUF_TILE_03: equ 337
041BD8             0088*  BUF_TILE_04: equ 338
041BD8             0089*  BUF_TILE_05: equ 339
041BD8             0090*  BUF_TILE_06: equ 340
041BD8             0091*  BUF_TILE_07: equ 341
041BD8             0092*  BUF_TILE_08: equ 342
041BD8             0093*  BUF_TILE_09: equ 343
041BD8             0094*  BUF_TILE_10: equ 344
041BD8             0095*  BUF_TILE_11: equ 345
041BD8             0096*  BUF_TILE_12: equ 346
041BD8             0097*  BUF_TILE_13: equ 347
041BD8             0098*  BUF_TILE_14: equ 348
041BD8             0099*  BUF_TILE_15: equ 349
041BD8             0100*  BUF_TILE_16: equ 350
041BD8             0101*  BUF_TILE_17: equ 351
041BD8             0102*  BUF_TILE_18: equ 352
041BD8             0103*  BUF_TILE_19: equ 353
041BD8             0104*  BUF_TILE_20: equ 354
041BD8             0105*  BUF_TILE_21: equ 355
041BD8             0106*  BUF_TILE_22: equ 356
041BD8             0107*  BUF_TILE_23: equ 357
041BD8             0108*  BUF_TILE_24: equ 358
041BD8             0109*  BUF_TILE_25: equ 359
041BD8             0110*  BUF_TILE_26: equ 360
041BD8             0111*  BUF_TILE_27: equ 361
041BD8             0112*  BUF_TILE_28: equ 362
041BD8             0113*  BUF_TILE_29: equ 363
041BD8             0114*  BUF_TILE_30: equ 364
041BD8             0115*  BUF_TILE_31: equ 365
041BD8             0116*  BUF_TILE_32: equ 366
041BD8             0117*  BUF_TILE_33: equ 367
041BD8             0118*  BUF_TILE_34: equ 368
041BD8             0119*  
041BD8             0120*  sprites_image_list: ; type; width; height; filename; bufferId:
041BD8 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_blinky_0, 256
       00 00 10 00 
       00 00 01 00 
       CA 23 04 00 
       01 00       
041BEA 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_blinky_1, 257
       00 00 10 00 
       00 00 01 00 
       E1 23 04 01 
       01 00       
041BFC 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_blinky_2, 258
       00 00 10 00 
       00 00 01 00 
       F8 23 04 02 
       01 00       
041C0E 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_blinky_3, 259
       00 00 10 00 
       00 00 01 00 
       0F 24 04 03 
       01 00       
041C20 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_blinky_4, 260
       00 00 10 00 
       00 00 01 00 
       26 24 04 04 
       01 00       
041C32 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_blinky_5, 261
       00 00 10 00 
       00 00 01 00 
       3D 24 04 05 
       01 00       
041C44 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_blinky_6, 262
       00 00 10 00 
       00 00 01 00 
       54 24 04 06 
       01 00       
041C56 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_blinky_7, 263
       00 00 10 00 
       00 00 01 00 
       6B 24 04 07 
       01 00       
041C68 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_clyde_0, 264
       00 00 10 00 
       00 00 01 00 
       82 24 04 08 
       01 00       
041C7A 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_clyde_1, 265
       00 00 10 00 
       00 00 01 00 
       98 24 04 09 
       01 00       
041C8C 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_clyde_2, 266
       00 00 10 00 
       00 00 01 00 
       AE 24 04 0A 
       01 00       
041C9E 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_clyde_3, 267
       00 00 10 00 
       00 00 01 00 
       C4 24 04 0B 
       01 00       
041CB0 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_clyde_4, 268
       00 00 10 00 
       00 00 01 00 
       DA 24 04 0C 
       01 00       
041CC2 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_clyde_5, 269
       00 00 10 00 
       00 00 01 00 
       F0 24 04 0D 
       01 00       
041CD4 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_clyde_6, 270
       00 00 10 00 
       00 00 01 00 
       06 25 04 0E 
       01 00       
041CE6 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_clyde_7, 271
       00 00 10 00 
       00 00 01 00 
       1C 25 04 0F 
       01 00       
041CF8 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_fruit_0, 272
       00 00 10 00 
       00 00 01 00 
       32 25 04 10 
       01 00       
041D0A 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_fruit_1, 273
       00 00 10 00 
       00 00 01 00 
       48 25 04 11 
       01 00       
041D1C 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_fruit_2, 274
       00 00 10 00 
       00 00 01 00 
       5E 25 04 12 
       01 00       
041D2E 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_fruit_3, 275
       00 00 10 00 
       00 00 01 00 
       74 25 04 13 
       01 00       
041D40 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_fruit_4, 276
       00 00 10 00 
       00 00 01 00 
       8A 25 04 14 
       01 00       
041D52 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_fruit_5, 277
       00 00 10 00 
       00 00 01 00 
       A0 25 04 15 
       01 00       
041D64 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_fruit_6, 278
       00 00 10 00 
       00 00 01 00 
       B6 25 04 16 
       01 00       
041D76 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_fruit_7, 279
       00 00 10 00 
       00 00 01 00 
       CC 25 04 17 
       01 00       
041D88 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_inky_0, 280
       00 00 10 00 
       00 00 01 00 
       E2 25 04 18 
       01 00       
041D9A 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_inky_1, 281
       00 00 10 00 
       00 00 01 00 
       F7 25 04 19 
       01 00       
041DAC 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_inky_2, 282
       00 00 10 00 
       00 00 01 00 
       0C 26 04 1A 
       01 00       
041DBE 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_inky_3, 283
       00 00 10 00 
       00 00 01 00 
       21 26 04 1B 
       01 00       
041DD0 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_inky_4, 284
       00 00 10 00 
       00 00 01 00 
       36 26 04 1C 
       01 00       
041DE2 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_inky_5, 285
       00 00 10 00 
       00 00 01 00 
       4B 26 04 1D 
       01 00       
041DF4 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_inky_6, 286
       00 00 10 00 
       00 00 01 00 
       60 26 04 1E 
       01 00       
041E06 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_inky_7, 287
       00 00 10 00 
       00 00 01 00 
       75 26 04 1F 
       01 00       
041E18 01 00 00 08 0153*  	dl 1, 8, 8, 64, fn_maze_pellets_00, 288
       00 00 08 00 
       00 40 00 00 
       8A 26 04 20 
       01 00       
041E2A 01 00 00 08 0154*  	dl 1, 8, 8, 64, fn_maze_pellets_01, 289
       00 00 08 00 
       00 40 00 00 
       A8 26 04 21 
       01 00       
041E3C 01 00 00 08 0155*  	dl 1, 8, 8, 64, fn_maze_pellets_02, 290
       00 00 08 00 
       00 40 00 00 
       C6 26 04 22 
       01 00       
041E4E 01 00 00 20 0156*  	dl 1, 32, 32, 1024, fn_pac_big_00_00, 291
       00 00 20 00 
       00 00 04 00 
       E4 26 04 23 
       01 00       
041E60 01 00 00 20 0157*  	dl 1, 32, 32, 1024, fn_pac_big_00_01, 292
       00 00 20 00 
       00 00 04 00 
       00 27 04 24 
       01 00       
041E72 01 00 00 20 0158*  	dl 1, 32, 32, 1024, fn_pac_big_00_02, 293
       00 00 20 00 
       00 00 04 00 
       1C 27 04 25 
       01 00       
041E84 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_pac_ded_00_00, 294
       00 00 10 00 
       00 00 01 00 
       38 27 04 26 
       01 00       
041E96 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_pac_ded_00_01, 295
       00 00 10 00 
       00 00 01 00 
       54 27 04 27 
       01 00       
041EA8 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_pac_ded_00_02, 296
       00 00 10 00 
       00 00 01 00 
       70 27 04 28 
       01 00       
041EBA 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_pac_ded_00_03, 297
       00 00 10 00 
       00 00 01 00 
       8C 27 04 29 
       01 00       
041ECC 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_pac_ded_00_04, 298
       00 00 10 00 
       00 00 01 00 
       A8 27 04 2A 
       01 00       
041EDE 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_pac_ded_00_05, 299
       00 00 10 00 
       00 00 01 00 
       C4 27 04 2B 
       01 00       
041EF0 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_pac_ded_00_06, 300
       00 00 10 00 
       00 00 01 00 
       E0 27 04 2C 
       01 00       
041F02 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_pac_ded_00_07, 301
       00 00 10 00 
       00 00 01 00 
       FC 27 04 2D 
       01 00       
041F14 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_pac_ded_00_08, 302
       00 00 10 00 
       00 00 01 00 
       18 28 04 2E 
       01 00       
041F26 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_pac_ded_00_09, 303
       00 00 10 00 
       00 00 01 00 
       34 28 04 2F 
       01 00       
041F38 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_pac_ded_00_10, 304
       00 00 10 00 
       00 00 01 00 
       50 28 04 30 
       01 00       
041F4A 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_pac_liv_00_00, 305
       00 00 10 00 
       00 00 01 00 
       6C 28 04 31 
       01 00       
041F5C 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_pac_man_00_00, 306
       00 00 10 00 
       00 00 01 00 
       88 28 04 32 
       01 00       
041F6E 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_pac_man_00_01, 307
       00 00 10 00 
       00 00 01 00 
       A4 28 04 33 
       01 00       
041F80 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_pac_man_00_02, 308
       00 00 10 00 
       00 00 01 00 
       C0 28 04 34 
       01 00       
041F92 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_pac_man_01_00, 309
       00 00 10 00 
       00 00 01 00 
       DC 28 04 35 
       01 00       
041FA4 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_pac_man_01_01, 310
       00 00 10 00 
       00 00 01 00 
       F8 28 04 36 
       01 00       
041FB6 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_pac_man_01_02, 311
       00 00 10 00 
       00 00 01 00 
       14 29 04 37 
       01 00       
041FC8 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_pac_man_02_00, 312
       00 00 10 00 
       00 00 01 00 
       30 29 04 38 
       01 00       
041FDA 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_pac_man_02_01, 313
       00 00 10 00 
       00 00 01 00 
       4C 29 04 39 
       01 00       
041FEC 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_pac_man_02_02, 314
       00 00 10 00 
       00 00 01 00 
       68 29 04 3A 
       01 00       
041FFE 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_pac_man_03_00, 315
       00 00 10 00 
       00 00 01 00 
       84 29 04 3B 
       01 00       
042010 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_pac_man_03_01, 316
       00 00 10 00 
       00 00 01 00 
       A0 29 04 3C 
       01 00       
042022 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_pac_man_03_02, 317
       00 00 10 00 
       00 00 01 00 
       BC 29 04 3D 
       01 00       
042034 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_pinky_0, 318
       00 00 10 00 
       00 00 01 00 
       D8 29 04 3E 
       01 00       
042046 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_pinky_1, 319
       00 00 10 00 
       00 00 01 00 
       EE 29 04 3F 
       01 00       
042058 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_pinky_2, 320
       00 00 10 00 
       00 00 01 00 
       04 2A 04 40 
       01 00       
04206A 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_pinky_3, 321
       00 00 10 00 
       00 00 01 00 
       1A 2A 04 41 
       01 00       
04207C 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_pinky_4, 322
       00 00 10 00 
       00 00 01 00 
       30 2A 04 42 
       01 00       
04208E 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_pinky_5, 323
       00 00 10 00 
       00 00 01 00 
       46 2A 04 43 
       01 00       
0420A0 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_pinky_6, 324
       00 00 10 00 
       00 00 01 00 
       5C 2A 04 44 
       01 00       
0420B2 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_pinky_7, 325
       00 00 10 00 
       00 00 01 00 
       72 2A 04 45 
       01 00       
0420C4 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_reverse_0, 326
       00 00 10 00 
       00 00 01 00 
       88 2A 04 46 
       01 00       
0420D6 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_reverse_1, 327
       00 00 10 00 
       00 00 01 00 
       A0 2A 04 47 
       01 00       
0420E8 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_reverse_2, 328
       00 00 10 00 
       00 00 01 00 
       B8 2A 04 48 
       01 00       
0420FA 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_reverse_3, 329
       00 00 10 00 
       00 00 01 00 
       D0 2A 04 49 
       01 00       
04210C 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_reverse_4, 330
       00 00 10 00 
       00 00 01 00 
       E8 2A 04 4A 
       01 00       
04211E 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_reverse_5, 331
       00 00 10 00 
       00 00 01 00 
       00 2B 04 4B 
       01 00       
042130 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_reverse_6, 332
       00 00 10 00 
       00 00 01 00 
       18 2B 04 4C 
       01 00       
042142 01 00 00 10 0198*  	dl 1, 16, 16, 256, fn_reverse_7, 333
       00 00 10 00 
       00 00 01 00 
       30 2B 04 4D 
       01 00       
042154 01 00 00 08 0199*  	dl 1, 8, 8, 64, fn_tile_00, 334
       00 00 08 00 
       00 40 00 00 
       48 2B 04 4E 
       01 00       
042166 01 00 00 08 0200*  	dl 1, 8, 8, 64, fn_tile_01, 335
       00 00 08 00 
       00 40 00 00 
       5E 2B 04 4F 
       01 00       
042178 01 00 00 08 0201*  	dl 1, 8, 8, 64, fn_tile_02, 336
       00 00 08 00 
       00 40 00 00 
       74 2B 04 50 
       01 00       
04218A 01 00 00 08 0202*  	dl 1, 8, 8, 64, fn_tile_03, 337
       00 00 08 00 
       00 40 00 00 
       8A 2B 04 51 
       01 00       
04219C 01 00 00 08 0203*  	dl 1, 8, 8, 64, fn_tile_04, 338
       00 00 08 00 
       00 40 00 00 
       A0 2B 04 52 
       01 00       
0421AE 01 00 00 08 0204*  	dl 1, 8, 8, 64, fn_tile_05, 339
       00 00 08 00 
       00 40 00 00 
       B6 2B 04 53 
       01 00       
0421C0 01 00 00 08 0205*  	dl 1, 8, 8, 64, fn_tile_06, 340
       00 00 08 00 
       00 40 00 00 
       CC 2B 04 54 
       01 00       
0421D2 01 00 00 08 0206*  	dl 1, 8, 8, 64, fn_tile_07, 341
       00 00 08 00 
       00 40 00 00 
       E2 2B 04 55 
       01 00       
0421E4 01 00 00 08 0207*  	dl 1, 8, 8, 64, fn_tile_08, 342
       00 00 08 00 
       00 40 00 00 
       F8 2B 04 56 
       01 00       
0421F6 01 00 00 08 0208*  	dl 1, 8, 8, 64, fn_tile_09, 343
       00 00 08 00 
       00 40 00 00 
       0E 2C 04 57 
       01 00       
042208 01 00 00 08 0209*  	dl 1, 8, 8, 64, fn_tile_10, 344
       00 00 08 00 
       00 40 00 00 
       24 2C 04 58 
       01 00       
04221A 01 00 00 08 0210*  	dl 1, 8, 8, 64, fn_tile_11, 345
       00 00 08 00 
       00 40 00 00 
       3A 2C 04 59 
       01 00       
04222C 01 00 00 08 0211*  	dl 1, 8, 8, 64, fn_tile_12, 346
       00 00 08 00 
       00 40 00 00 
       50 2C 04 5A 
       01 00       
04223E 01 00 00 08 0212*  	dl 1, 8, 8, 64, fn_tile_13, 347
       00 00 08 00 
       00 40 00 00 
       66 2C 04 5B 
       01 00       
042250 01 00 00 08 0213*  	dl 1, 8, 8, 64, fn_tile_14, 348
       00 00 08 00 
       00 40 00 00 
       7C 2C 04 5C 
       01 00       
042262 01 00 00 08 0214*  	dl 1, 8, 8, 64, fn_tile_15, 349
       00 00 08 00 
       00 40 00 00 
       92 2C 04 5D 
       01 00       
042274 01 00 00 08 0215*  	dl 1, 8, 8, 64, fn_tile_16, 350
       00 00 08 00 
       00 40 00 00 
       A8 2C 04 5E 
       01 00       
042286 01 00 00 08 0216*  	dl 1, 8, 8, 64, fn_tile_17, 351
       00 00 08 00 
       00 40 00 00 
       BE 2C 04 5F 
       01 00       
042298 01 00 00 08 0217*  	dl 1, 8, 8, 64, fn_tile_18, 352
       00 00 08 00 
       00 40 00 00 
       D4 2C 04 60 
       01 00       
0422AA 01 00 00 08 0218*  	dl 1, 8, 8, 64, fn_tile_19, 353
       00 00 08 00 
       00 40 00 00 
       EA 2C 04 61 
       01 00       
0422BC 01 00 00 08 0219*  	dl 1, 8, 8, 64, fn_tile_20, 354
       00 00 08 00 
       00 40 00 00 
       00 2D 04 62 
       01 00       
0422CE 01 00 00 08 0220*  	dl 1, 8, 8, 64, fn_tile_21, 355
       00 00 08 00 
       00 40 00 00 
       16 2D 04 63 
       01 00       
0422E0 01 00 00 08 0221*  	dl 1, 8, 8, 64, fn_tile_22, 356
       00 00 08 00 
       00 40 00 00 
       2C 2D 04 64 
       01 00       
0422F2 01 00 00 08 0222*  	dl 1, 8, 8, 64, fn_tile_23, 357
       00 00 08 00 
       00 40 00 00 
       42 2D 04 65 
       01 00       
042304 01 00 00 08 0223*  	dl 1, 8, 8, 64, fn_tile_24, 358
       00 00 08 00 
       00 40 00 00 
       58 2D 04 66 
       01 00       
042316 01 00 00 08 0224*  	dl 1, 8, 8, 64, fn_tile_25, 359
       00 00 08 00 
       00 40 00 00 
       6E 2D 04 67 
       01 00       
042328 01 00 00 08 0225*  	dl 1, 8, 8, 64, fn_tile_26, 360
       00 00 08 00 
       00 40 00 00 
       84 2D 04 68 
       01 00       
04233A 01 00 00 08 0226*  	dl 1, 8, 8, 64, fn_tile_27, 361
       00 00 08 00 
       00 40 00 00 
       9A 2D 04 69 
       01 00       
04234C 01 00 00 08 0227*  	dl 1, 8, 8, 64, fn_tile_28, 362
       00 00 08 00 
       00 40 00 00 
       B0 2D 04 6A 
       01 00       
04235E 01 00 00 08 0228*  	dl 1, 8, 8, 64, fn_tile_29, 363
       00 00 08 00 
       00 40 00 00 
       C6 2D 04 6B 
       01 00       
042370 01 00 00 08 0229*  	dl 1, 8, 8, 64, fn_tile_30, 364
       00 00 08 00 
       00 40 00 00 
       DC 2D 04 6C 
       01 00       
042382 01 00 00 08 0230*  	dl 1, 8, 8, 64, fn_tile_31, 365
       00 00 08 00 
       00 40 00 00 
       F2 2D 04 6D 
       01 00       
042394 01 00 00 08 0231*  	dl 1, 8, 8, 64, fn_tile_32, 366
       00 00 08 00 
       00 40 00 00 
       08 2E 04 6E 
       01 00       
0423A6 01 00 00 08 0232*  	dl 1, 8, 8, 64, fn_tile_33, 367
       00 00 08 00 
       00 40 00 00 
       1E 2E 04 6F 
       01 00       
0423B8 01 00 00 08 0233*  	dl 1, 8, 8, 64, fn_tile_34, 368
       00 00 08 00 
       00 40 00 00 
       34 2E 04 70 
       01 00       
0423CA             0234*  
0423CA             0235*  ; files_list: ; filename:
0423CA 73 70 72 69 0236*  fn_blinky_0: db "sprites/blinky_0.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 30 
       2E 72 67 62 
       61 32 00    
0423E1 73 70 72 69 0237*  fn_blinky_1: db "sprites/blinky_1.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 31 
       2E 72 67 62 
       61 32 00    
0423F8 73 70 72 69 0238*  fn_blinky_2: db "sprites/blinky_2.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 32 
       2E 72 67 62 
       61 32 00    
04240F 73 70 72 69 0239*  fn_blinky_3: db "sprites/blinky_3.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 33 
       2E 72 67 62 
       61 32 00    
042426 73 70 72 69 0240*  fn_blinky_4: db "sprites/blinky_4.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 34 
       2E 72 67 62 
       61 32 00    
04243D 73 70 72 69 0241*  fn_blinky_5: db "sprites/blinky_5.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 35 
       2E 72 67 62 
       61 32 00    
042454 73 70 72 69 0242*  fn_blinky_6: db "sprites/blinky_6.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 36 
       2E 72 67 62 
       61 32 00    
04246B 73 70 72 69 0243*  fn_blinky_7: db "sprites/blinky_7.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 37 
       2E 72 67 62 
       61 32 00    
042482 73 70 72 69 0244*  fn_clyde_0: db "sprites/clyde_0.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 30 2E 
       72 67 62 61 
       32 00       
042498 73 70 72 69 0245*  fn_clyde_1: db "sprites/clyde_1.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 31 2E 
       72 67 62 61 
       32 00       
0424AE 73 70 72 69 0246*  fn_clyde_2: db "sprites/clyde_2.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 32 2E 
       72 67 62 61 
       32 00       
0424C4 73 70 72 69 0247*  fn_clyde_3: db "sprites/clyde_3.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 33 2E 
       72 67 62 61 
       32 00       
0424DA 73 70 72 69 0248*  fn_clyde_4: db "sprites/clyde_4.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 34 2E 
       72 67 62 61 
       32 00       
0424F0 73 70 72 69 0249*  fn_clyde_5: db "sprites/clyde_5.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 35 2E 
       72 67 62 61 
       32 00       
042506 73 70 72 69 0250*  fn_clyde_6: db "sprites/clyde_6.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 36 2E 
       72 67 62 61 
       32 00       
04251C 73 70 72 69 0251*  fn_clyde_7: db "sprites/clyde_7.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 37 2E 
       72 67 62 61 
       32 00       
042532 73 70 72 69 0252*  fn_fruit_0: db "sprites/fruit_0.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 30 2E 
       72 67 62 61 
       32 00       
042548 73 70 72 69 0253*  fn_fruit_1: db "sprites/fruit_1.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 31 2E 
       72 67 62 61 
       32 00       
04255E 73 70 72 69 0254*  fn_fruit_2: db "sprites/fruit_2.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 32 2E 
       72 67 62 61 
       32 00       
042574 73 70 72 69 0255*  fn_fruit_3: db "sprites/fruit_3.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 33 2E 
       72 67 62 61 
       32 00       
04258A 73 70 72 69 0256*  fn_fruit_4: db "sprites/fruit_4.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 34 2E 
       72 67 62 61 
       32 00       
0425A0 73 70 72 69 0257*  fn_fruit_5: db "sprites/fruit_5.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 35 2E 
       72 67 62 61 
       32 00       
0425B6 73 70 72 69 0258*  fn_fruit_6: db "sprites/fruit_6.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 36 2E 
       72 67 62 61 
       32 00       
0425CC 73 70 72 69 0259*  fn_fruit_7: db "sprites/fruit_7.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 37 2E 
       72 67 62 61 
       32 00       
0425E2 73 70 72 69 0260*  fn_inky_0: db "sprites/inky_0.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 30 2E 72 
       67 62 61 32 
       00          
0425F7 73 70 72 69 0261*  fn_inky_1: db "sprites/inky_1.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 31 2E 72 
       67 62 61 32 
       00          
04260C 73 70 72 69 0262*  fn_inky_2: db "sprites/inky_2.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 32 2E 72 
       67 62 61 32 
       00          
042621 73 70 72 69 0263*  fn_inky_3: db "sprites/inky_3.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 33 2E 72 
       67 62 61 32 
       00          
042636 73 70 72 69 0264*  fn_inky_4: db "sprites/inky_4.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 34 2E 72 
       67 62 61 32 
       00          
04264B 73 70 72 69 0265*  fn_inky_5: db "sprites/inky_5.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 35 2E 72 
       67 62 61 32 
       00          
042660 73 70 72 69 0266*  fn_inky_6: db "sprites/inky_6.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 36 2E 72 
       67 62 61 32 
       00          
042675 73 70 72 69 0267*  fn_inky_7: db "sprites/inky_7.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 37 2E 72 
       67 62 61 32 
       00          
04268A 73 70 72 69 0268*  fn_maze_pellets_00: db "sprites/maze_pellets_00.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 30 2E 
       72 67 62 61 
       32 00       
0426A8 73 70 72 69 0269*  fn_maze_pellets_01: db "sprites/maze_pellets_01.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 31 2E 
       72 67 62 61 
       32 00       
0426C6 73 70 72 69 0270*  fn_maze_pellets_02: db "sprites/maze_pellets_02.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 32 2E 
       72 67 62 61 
       32 00       
0426E4 73 70 72 69 0271*  fn_pac_big_00_00: db "sprites/pac_big_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
042700 73 70 72 69 0272*  fn_pac_big_00_01: db "sprites/pac_big_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
04271C 73 70 72 69 0273*  fn_pac_big_00_02: db "sprites/pac_big_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
042738 73 70 72 69 0274*  fn_pac_ded_00_00: db "sprites/pac_ded_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
042754 73 70 72 69 0275*  fn_pac_ded_00_01: db "sprites/pac_ded_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
042770 73 70 72 69 0276*  fn_pac_ded_00_02: db "sprites/pac_ded_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
04278C 73 70 72 69 0277*  fn_pac_ded_00_03: db "sprites/pac_ded_00_03.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       33 2E 72 67 
       62 61 32 00 
0427A8 73 70 72 69 0278*  fn_pac_ded_00_04: db "sprites/pac_ded_00_04.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       34 2E 72 67 
       62 61 32 00 
0427C4 73 70 72 69 0279*  fn_pac_ded_00_05: db "sprites/pac_ded_00_05.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       35 2E 72 67 
       62 61 32 00 
0427E0 73 70 72 69 0280*  fn_pac_ded_00_06: db "sprites/pac_ded_00_06.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       36 2E 72 67 
       62 61 32 00 
0427FC 73 70 72 69 0281*  fn_pac_ded_00_07: db "sprites/pac_ded_00_07.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       37 2E 72 67 
       62 61 32 00 
042818 73 70 72 69 0282*  fn_pac_ded_00_08: db "sprites/pac_ded_00_08.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       38 2E 72 67 
       62 61 32 00 
042834 73 70 72 69 0283*  fn_pac_ded_00_09: db "sprites/pac_ded_00_09.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       39 2E 72 67 
       62 61 32 00 
042850 73 70 72 69 0284*  fn_pac_ded_00_10: db "sprites/pac_ded_00_10.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 31 
       30 2E 72 67 
       62 61 32 00 
04286C 73 70 72 69 0285*  fn_pac_liv_00_00: db "sprites/pac_liv_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6C 69 76 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
042888 73 70 72 69 0286*  fn_pac_man_00_00: db "sprites/pac_man_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
0428A4 73 70 72 69 0287*  fn_pac_man_00_01: db "sprites/pac_man_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
0428C0 73 70 72 69 0288*  fn_pac_man_00_02: db "sprites/pac_man_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
0428DC 73 70 72 69 0289*  fn_pac_man_01_00: db "sprites/pac_man_01_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       30 2E 72 67 
       62 61 32 00 
0428F8 73 70 72 69 0290*  fn_pac_man_01_01: db "sprites/pac_man_01_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       31 2E 72 67 
       62 61 32 00 
042914 73 70 72 69 0291*  fn_pac_man_01_02: db "sprites/pac_man_01_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       32 2E 72 67 
       62 61 32 00 
042930 73 70 72 69 0292*  fn_pac_man_02_00: db "sprites/pac_man_02_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       30 2E 72 67 
       62 61 32 00 
04294C 73 70 72 69 0293*  fn_pac_man_02_01: db "sprites/pac_man_02_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       31 2E 72 67 
       62 61 32 00 
042968 73 70 72 69 0294*  fn_pac_man_02_02: db "sprites/pac_man_02_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       32 2E 72 67 
       62 61 32 00 
042984 73 70 72 69 0295*  fn_pac_man_03_00: db "sprites/pac_man_03_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       30 2E 72 67 
       62 61 32 00 
0429A0 73 70 72 69 0296*  fn_pac_man_03_01: db "sprites/pac_man_03_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       31 2E 72 67 
       62 61 32 00 
0429BC 73 70 72 69 0297*  fn_pac_man_03_02: db "sprites/pac_man_03_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       32 2E 72 67 
       62 61 32 00 
0429D8 73 70 72 69 0298*  fn_pinky_0: db "sprites/pinky_0.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 30 2E 
       72 67 62 61 
       32 00       
0429EE 73 70 72 69 0299*  fn_pinky_1: db "sprites/pinky_1.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 31 2E 
       72 67 62 61 
       32 00       
042A04 73 70 72 69 0300*  fn_pinky_2: db "sprites/pinky_2.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 32 2E 
       72 67 62 61 
       32 00       
042A1A 73 70 72 69 0301*  fn_pinky_3: db "sprites/pinky_3.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 33 2E 
       72 67 62 61 
       32 00       
042A30 73 70 72 69 0302*  fn_pinky_4: db "sprites/pinky_4.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 34 2E 
       72 67 62 61 
       32 00       
042A46 73 70 72 69 0303*  fn_pinky_5: db "sprites/pinky_5.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 35 2E 
       72 67 62 61 
       32 00       
042A5C 73 70 72 69 0304*  fn_pinky_6: db "sprites/pinky_6.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 36 2E 
       72 67 62 61 
       32 00       
042A72 73 70 72 69 0305*  fn_pinky_7: db "sprites/pinky_7.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 37 2E 
       72 67 62 61 
       32 00       
042A88 73 70 72 69 0306*  fn_reverse_0: db "sprites/reverse_0.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       30 2E 72 67 
       62 61 32 00 
042AA0 73 70 72 69 0307*  fn_reverse_1: db "sprites/reverse_1.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       31 2E 72 67 
       62 61 32 00 
042AB8 73 70 72 69 0308*  fn_reverse_2: db "sprites/reverse_2.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       32 2E 72 67 
       62 61 32 00 
042AD0 73 70 72 69 0309*  fn_reverse_3: db "sprites/reverse_3.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       33 2E 72 67 
       62 61 32 00 
042AE8 73 70 72 69 0310*  fn_reverse_4: db "sprites/reverse_4.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       34 2E 72 67 
       62 61 32 00 
042B00 73 70 72 69 0311*  fn_reverse_5: db "sprites/reverse_5.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       35 2E 72 67 
       62 61 32 00 
042B18 73 70 72 69 0312*  fn_reverse_6: db "sprites/reverse_6.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       36 2E 72 67 
       62 61 32 00 
042B30 73 70 72 69 0313*  fn_reverse_7: db "sprites/reverse_7.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       37 2E 72 67 
       62 61 32 00 
042B48 73 70 72 69 0314*  fn_tile_00: db "sprites/tile_00.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 30 2E 
       72 67 62 61 
       32 00       
042B5E 73 70 72 69 0315*  fn_tile_01: db "sprites/tile_01.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 31 2E 
       72 67 62 61 
       32 00       
042B74 73 70 72 69 0316*  fn_tile_02: db "sprites/tile_02.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 32 2E 
       72 67 62 61 
       32 00       
042B8A 73 70 72 69 0317*  fn_tile_03: db "sprites/tile_03.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 33 2E 
       72 67 62 61 
       32 00       
042BA0 73 70 72 69 0318*  fn_tile_04: db "sprites/tile_04.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 34 2E 
       72 67 62 61 
       32 00       
042BB6 73 70 72 69 0319*  fn_tile_05: db "sprites/tile_05.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 35 2E 
       72 67 62 61 
       32 00       
042BCC 73 70 72 69 0320*  fn_tile_06: db "sprites/tile_06.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 36 2E 
       72 67 62 61 
       32 00       
042BE2 73 70 72 69 0321*  fn_tile_07: db "sprites/tile_07.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 37 2E 
       72 67 62 61 
       32 00       
042BF8 73 70 72 69 0322*  fn_tile_08: db "sprites/tile_08.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 38 2E 
       72 67 62 61 
       32 00       
042C0E 73 70 72 69 0323*  fn_tile_09: db "sprites/tile_09.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 39 2E 
       72 67 62 61 
       32 00       
042C24 73 70 72 69 0324*  fn_tile_10: db "sprites/tile_10.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 30 2E 
       72 67 62 61 
       32 00       
042C3A 73 70 72 69 0325*  fn_tile_11: db "sprites/tile_11.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 31 2E 
       72 67 62 61 
       32 00       
042C50 73 70 72 69 0326*  fn_tile_12: db "sprites/tile_12.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 32 2E 
       72 67 62 61 
       32 00       
042C66 73 70 72 69 0327*  fn_tile_13: db "sprites/tile_13.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 33 2E 
       72 67 62 61 
       32 00       
042C7C 73 70 72 69 0328*  fn_tile_14: db "sprites/tile_14.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 34 2E 
       72 67 62 61 
       32 00       
042C92 73 70 72 69 0329*  fn_tile_15: db "sprites/tile_15.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 35 2E 
       72 67 62 61 
       32 00       
042CA8 73 70 72 69 0330*  fn_tile_16: db "sprites/tile_16.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 36 2E 
       72 67 62 61 
       32 00       
042CBE 73 70 72 69 0331*  fn_tile_17: db "sprites/tile_17.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 37 2E 
       72 67 62 61 
       32 00       
042CD4 73 70 72 69 0332*  fn_tile_18: db "sprites/tile_18.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 38 2E 
       72 67 62 61 
       32 00       
042CEA 73 70 72 69 0333*  fn_tile_19: db "sprites/tile_19.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 39 2E 
       72 67 62 61 
       32 00       
042D00 73 70 72 69 0334*  fn_tile_20: db "sprites/tile_20.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 30 2E 
       72 67 62 61 
       32 00       
042D16 73 70 72 69 0335*  fn_tile_21: db "sprites/tile_21.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 31 2E 
       72 67 62 61 
       32 00       
042D2C 73 70 72 69 0336*  fn_tile_22: db "sprites/tile_22.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 32 2E 
       72 67 62 61 
       32 00       
042D42 73 70 72 69 0337*  fn_tile_23: db "sprites/tile_23.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 33 2E 
       72 67 62 61 
       32 00       
042D58 73 70 72 69 0338*  fn_tile_24: db "sprites/tile_24.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 34 2E 
       72 67 62 61 
       32 00       
042D6E 73 70 72 69 0339*  fn_tile_25: db "sprites/tile_25.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 35 2E 
       72 67 62 61 
       32 00       
042D84 73 70 72 69 0340*  fn_tile_26: db "sprites/tile_26.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 36 2E 
       72 67 62 61 
       32 00       
042D9A 73 70 72 69 0341*  fn_tile_27: db "sprites/tile_27.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 37 2E 
       72 67 62 61 
       32 00       
042DB0 73 70 72 69 0342*  fn_tile_28: db "sprites/tile_28.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 38 2E 
       72 67 62 61 
       32 00       
042DC6 73 70 72 69 0343*  fn_tile_29: db "sprites/tile_29.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 39 2E 
       72 67 62 61 
       32 00       
042DDC 73 70 72 69 0344*  fn_tile_30: db "sprites/tile_30.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 30 2E 
       72 67 62 61 
       32 00       
042DF2 73 70 72 69 0345*  fn_tile_31: db "sprites/tile_31.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 31 2E 
       72 67 62 61 
       32 00       
042E08 73 70 72 69 0346*  fn_tile_32: db "sprites/tile_32.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 32 2E 
       72 67 62 61 
       32 00       
042E1E 73 70 72 69 0347*  fn_tile_33: db "sprites/tile_33.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 33 2E 
       72 67 62 61 
       32 00       
042E34 73 70 72 69 0348*  fn_tile_34: db "sprites/tile_34.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 34 2E 
       72 67 62 61 
       32 00       
042E4A             0046       include "maze.inc"
042E4A             0001*  maze_cols: equ 0
042E4A             0002*  maze_rows: equ 3
042E4A             0003*  maze_tile_size: equ 6
042E4A             0004*  maze_null_tile: equ 9
042E4A             0005*  maze_x: equ 12
042E4A             0006*  maze_y: equ 15
042E4A             0007*  maze_base_bufferId: equ 18
042E4A             0008*  orient_up: equ 2
042E4A             0009*  orient_left: equ 1
042E4A             0010*  orient_down: equ 3
042E4A             0011*  orient_right: equ 0
042E4A             0012*  
042E4A             0013*  ; draw a maze based on a maze definition table
042E4A             0014*  ; inputs: ix = pointer to maze definition table
042E4A             0015*  ; outputs: pretty pixels
042E4A             0016*  ; destroys: all the things
042E4A             0017*  ; TODO: this could be significantly simplified if the null tile number
042E4A             0018*  ;       and low byte of the base bufferId are both 0
042E4A             0019*  draw_maze:
042E4A             0020*  ; initialize variables
042E4A DD E5       0021*      push ix
042E4C FD E1       0022*      pop iy
042E4E ED 32 15    0023*      lea ix,ix+maze_base_bufferId+3 ; point to the first cell of the maze data
042E51 21 00 00 00 0024*      ld hl,0
042E55 FD 2F 0C    0025*      ld (iy+maze_x),hl
042E58 FD 2F 0F    0026*      ld (iy+maze_y),hl
042E5B FD 6E 00    0027*      ld l,(iy+maze_cols)
042E5E FD 66 03    0028*      ld h,(iy+maze_rows)
042E61             0029*  @loop:
042E61 E5          0030*      push hl ; row/col loop counter
042E62 DD 7E 00    0031*      ld a,(ix) ; tile number
042E65 FD BE 09    0032*      cp (iy+maze_null_tile) ; is it the null tile?
042E68 28 19       0033*      jr z,@next_tile ; yes, so don't draw anything
042E6A FD 27 12    0034*      ld hl,(iy+maze_base_bufferId) ; base bufferId
042E6D 11 00 00 00 0035*      ld de,0 ; clear deu and d
042E71 DD 5E 00    0036*      ld e,(ix) ; tile number
042E74 19          0037*      add hl,de ; hl = tile bufferId
042E75 CD 88 15 04 0038*      call vdu_buff_select
042E79 FD 07 0C    0039*      ld bc,(iy+maze_x) ; x-coordinate
042E7C FD 17 0F    0040*      ld de,(iy+maze_y) ; y-coordinate
042E7F CD E4 18 04 0041*      call vdu_plot_bmp
042E83             0042*  @next_tile:
042E83 FD 27 0C    0043*      ld hl,(iy+maze_x) ; x-coordinate
042E86 FD 17 06    0044*      ld de,(iy+maze_tile_size) ; tile size
042E89 19          0045*      add hl,de ; x-coordinate + tile size
042E8A FD 2F 0C    0046*      ld (iy+maze_x),hl ; x-coordinate = x-coordinate + tile size
042E8D DD 23       0047*      inc ix ; bump pointer to next tile
042E8F E1          0048*      pop hl ; row/col loop counter
042E90 2D          0049*      dec l
042E91 C2 61 2E 04 0050*      jp nz,@loop
042E95 25          0051*      dec h
042E96 C8          0052*      ret z ; done
042E97 FD 6E 00    0053*      ld l,(iy+maze_cols) ; number of columns
042E9A E5          0054*      push hl
042E9B FD 27 0F    0055*      ld hl,(iy+maze_y) ; y-coordinate
042E9E FD 17 06    0056*      ld de,(iy+maze_tile_size) ; tile size
042EA1 19          0057*      add hl,de ; y-coordinate + tile size
042EA2 FD 2F 0F    0058*      ld (iy+maze_y),hl ; y-coordinate = y-coordinate + tile size
042EA5 21 00 00 00 0059*      ld hl,0 ; x-coordinate
042EA9 FD 2F 0C    0060*      ld (iy+maze_x),hl ; x-coordinate = 0
042EAC E1          0061*      pop hl
042EAD C3 61 2E 04 0062*      jp @loop
042EB1             0063*  
042EB1             0064*  ; converts screen coordinates to map cell coordinates
042EB1             0065*  ; inputs: ix = pointer to map defintion, ub.c = x-coordinate, ud.e = y-coordinate in 16.8 fixed point format
042EB1             0066*  ; outputs: bc,de = row,col, hl = cell index, ix = pointer to cell data
042EB1             0067*  ; destroys: a, hl, ix
042EB1             0068*  ; notes: map and screen coordinates assume inverted y-axis with origin at top left
042EB1             0069*  ;        tile size must be a power of two
042EB1             0070*  ;        screen coordinates are treated as unsigned with no checks to the contrary
042EB1             0071*  screen_to_map:
042EB1             0072*  ; get the x-coordinate
042EB1 C5          0073*      push bc
042EB2 E1          0074*      pop hl
042EB3 CD E5 07 04 0075*      call hlu_udiv256 ; hl = int(x)
042EB7 DD 7E 06    0076*      ld a,(ix+maze_tile_size)
042EBA CD 4C 07 04 0077*      call shr_hlu_log2a ; hl = int(int(x) / tile size) = col
042EBE EB          0078*      ex de,hl ; uh.l = y-coordinate, de = col
042EBF             0079*  ; get the y-coordinate
042EBF CD E5 07 04 0080*      call hlu_udiv256 ; hl = int(y)
042EC3 DD 7E 06    0081*      ld a,(ix+maze_tile_size)
042EC6 CD 4C 07 04 0082*      call shr_hlu_log2a ; hl = int(int(y) / tile size) = row
042ECA E5          0083*      push hl ; save row
042ECB             0084*  ; compute cell index = row * cols + col
042ECB             0085*  ; at this point hl = row, de = col
042ECB DD 66 00    0086*      ld h,(ix+maze_cols)
042ECE ED 6C       0087*      mlt hl ; hl = row * cols
042ED0 19          0088*      add hl,de ; hl = row * cols + col = cell index
042ED1 EB          0089*      ex de,hl ; de = cell index, hl = col
042ED2             0090*  ; point to cell data
042ED2 ED 32 15    0091*      lea ix,ix+maze_base_bufferId+3
042ED5 DD 19       0092*      add ix,de
042ED7             0093*  ; return results
042ED7 EB          0094*      ex de,hl ; de = col, hl = cell index
042ED8 D5          0095*      push de
042ED9 C1          0096*      pop bc ; bc = col
042EDA D1          0097*      pop de ; de = row
042EDB             0098*  
042EDB C9          0099*      ret
042EDC             0100*  
042EDC             0101*  ; converts map cell coordinates to screen coordinates
042EDC             0102*  ; inputs: ix = pointer to map definition, ub.c = col, ud.e = row in 16.8 fixed point format
042EDC             0103*  ; outputs: bc,de = x,y as 24-bit integers
042EDC             0104*  ; destroys: a, hl, bc, de
042EDC             0105*  map_to_screen:
042EDC             0106*  ; get the x-coordinate
042EDC C5          0107*      push bc
042EDD E1          0108*      pop hl ; uh.l = col
042EDE DD 7E 06    0109*      ld a,(ix+maze_tile_size)
042EE1 CD 62 07 04 0110*      call shl_hlu_log2a ; uh.l = col * tile size
042EE5 E5          0111*      push hl ; save x-coordinate
042EE6             0112*  ; get the y-coordinate
042EE6 EB          0113*      ex de,hl ; uh.l = row
042EE7 DD 7E 06    0114*      ld a,(ix+maze_tile_size)
042EEA CD 62 07 04 0115*      call shl_hlu_log2a ; uh.l = row * tile size
042EEE             0116*  ; return results
042EEE EB          0117*      ex de,hl ; de = y-coordinate
042EEF C1          0118*      pop bc ; bc = x-coordinate
042EF0 C9          0119*      ret
042EF1             0120*  
042EF1             0121*  ; get a pointer to a map cell from col and row input
042EF1             0122*  ; by computing cell index = row * cols + col
042EF1             0123*  ; inputs: ix = pointer to map definition, ub.c = col, ud.e = row in 16.8 fixed point format
042EF1             0124*  ; returns: ix = pointer to cell data, hl = cell index, a = cell value
042EF1             0125*  ; destroys: a, hl, ix
042EF1             0126*  map_get_cell:
042EF1 6A          0127*      ld l,d ; int(row)
042EF2 DD 66 00    0128*      ld h,(ix+maze_cols)
042EF5 ED 6C       0129*      mlt hl ; row * cols
042EF7 78          0130*      ld a,b ; int(col)
042EF8 85          0131*      add a,l
042EF9 6F          0132*      ld l,a
042EFA 3E 00       0133*      ld a,0 ; we need carry
042EFC 8C          0134*      adc a,h
042EFD 67          0135*      ld h,a ; hl = cell index
042EFE EB          0136*      ex de,hl ; can't add ix,hl
042EFF ED 32 15    0137*      lea ix,ix+maze_base_bufferId+3 ; point to cell 0
042F02 DD 19       0138*      add ix,de ; point to cell data
042F04 DD 7E 00    0139*      ld a,(ix) ; cell value
042F07 EB          0140*      ex de,hl ; restore de, hl = cell index
042F08 C9          0141*      ret
042F09             0142*  ; end map_get_cell
042F09             0143*  
042F09             0144*  ; snap row and or col values to the nearest integer
042F09             0145*  ; based on the path mask of the current cell
042F09             0146*  ; inputs: ix = pointer to map cell, ub.c = col, ud.e = row in 16.8 fixed point format
042F09             0147*  ; outputs: ub.c = col, ud.e = row adjusted as required
042F09             0148*  snap_to_path:
042F09 DD CB 00 56 0149*      bit orient_up,(ix)
042F0D CC 1D 2F 04 0150*      call z,@up
042F11 CB 5F       0151*      bit orient_down,a
042F13 28 08       0152*      jr z,@down
042F15 CB 4F       0153*      bit orient_left,a
042F17 28 04       0154*      jr z,@left
042F19 CB 47       0155*      bit orient_right,a
042F1B 28 00       0156*      jr z,@right
042F1D             0157*  
042F1D             0158*  @up:
042F1D             0159*  @down:
042F1D             0160*  @left:
042F1D             0161*  @right:
042F1D             0162*  
042F1D C9          0163*      ret
042F1E             0164*  ; end snap_to_path
042F1E             0047       include "maze_index.inc" ; DEBUG
042F1E             0001*  ; for easy verification that screen_to_map and other maze lookup functions work correctly
042F1E             0002*  
042F1E             0003*  maze_index:
042F1E 1C 00 00    0004*  maze_index_num_cols: dl 28
042F21 1F 00 00    0005*  maze_index_num_rows: dl 31
042F24 08 00 00    0006*  maze_index_tile_size: dl 8
042F27 00 00 00    0007*  maze_index_null_tile: dl 0 ; not used for maze index definitions.
042F2A 00 00 00    0008*  maze_index_x: dl 0
042F2D 00 00 00    0009*  maze_index_y: dl 0
042F30 00 00 00    0010*  maze_index_base_bufferId: dl 0 ; not used for maze index definitions.
042F33             0011*  
042F33             0012*  maze_index_map:
042F33 00 01 02 03 0013*      db 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
       10 11 12 13 
       14 15 16 17 
       18 19 1A 1B 
042F4F 1C 1D 1E 1F 0014*      db 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
       2C 2D 2E 2F 
       30 31 32 33 
       34 35 36 37 
042F6B 38 39 3A 3B 0015*      db 56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
       48 49 4A 4B 
       4C 4D 4E 4F 
       50 51 52 53 
042F87 54 55 56 57 0016*      db 84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
       64 65 66 67 
       68 69 6A 6B 
       6C 6D 6E 6F 
042FA3 70 71 72 73 0017*      db 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139
       74 75 76 77 
       78 79 7A 7B 
       7C 7D 7E 7F 
       80 81 82 83 
       84 85 86 87 
       88 89 8A 8B 
042FBF 8C 8D 8E 8F 0018*      db 140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167
       90 91 92 93 
       94 95 96 97 
       98 99 9A 9B 
       9C 9D 9E 9F 
       A0 A1 A2 A3 
       A4 A5 A6 A7 
042FDB A8 A9 AA AB 0019*      db 168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195
       AC AD AE AF 
       B0 B1 B2 B3 
       B4 B5 B6 B7 
       B8 B9 BA BB 
       BC BD BE BF 
       C0 C1 C2 C3 
042FF7 C4 C5 C6 C7 0020*      db 196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
       C8 C9 CA CB 
       CC CD CE CF 
       D0 D1 D2 D3 
       D4 D5 D6 D7 
       D8 D9 DA DB 
       DC DD DE DF 
043013 E0 E1 E2 E3 0021*      db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251
       E4 E5 E6 E7 
       E8 E9 EA EB 
       EC ED EE EF 
       F0 F1 F2 F3 
       F4 F5 F6 F7 
       F8 F9 FA FB 
04302F FC FD FE FF 0022*      db 252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23
       00 01 02 03 
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
       10 11 12 13 
       14 15 16 17 
04304B 18 19 1A 1B 0023*      db 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51
       1C 1D 1E 1F 
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
       2C 2D 2E 2F 
       30 31 32 33 
043067 34 35 36 37 0024*      db 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
       38 39 3A 3B 
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
       48 49 4A 4B 
       4C 4D 4E 4F 
043083 50 51 52 53 0025*      db 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107
       54 55 56 57 
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
       64 65 66 67 
       68 69 6A 6B 
04309F 6C 6D 6E 6F 0026*      db 108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135
       70 71 72 73 
       74 75 76 77 
       78 79 7A 7B 
       7C 7D 7E 7F 
       80 81 82 83 
       84 85 86 87 
0430BB 88 89 8A 8B 0027*      db 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163
       8C 8D 8E 8F 
       90 91 92 93 
       94 95 96 97 
       98 99 9A 9B 
       9C 9D 9E 9F 
       A0 A1 A2 A3 
0430D7 A4 A5 A6 A7 0028*      db 164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
       A8 A9 AA AB 
       AC AD AE AF 
       B0 B1 B2 B3 
       B4 B5 B6 B7 
       B8 B9 BA BB 
       BC BD BE BF 
0430F3 C0 C1 C2 C3 0029*      db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219
       C4 C5 C6 C7 
       C8 C9 CA CB 
       CC CD CE CF 
       D0 D1 D2 D3 
       D4 D5 D6 D7 
       D8 D9 DA DB 
04310F DC DD DE DF 0030*      db 220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247
       E0 E1 E2 E3 
       E4 E5 E6 E7 
       E8 E9 EA EB 
       EC ED EE EF 
       F0 F1 F2 F3 
       F4 F5 F6 F7 
04312B F8 F9 FA FB 0031*      db 248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
       FC FD FE FF 
       00 01 02 03 
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
       10 11 12 13 
043147 14 15 16 17 0032*      db 20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47
       18 19 1A 1B 
       1C 1D 1E 1F 
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
       2C 2D 2E 2F 
043163 30 31 32 33 0033*      db 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75
       34 35 36 37 
       38 39 3A 3B 
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
       48 49 4A 4B 
04317F 4C 4D 4E 4F 0034*      db 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103
       50 51 52 53 
       54 55 56 57 
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
       64 65 66 67 
04319B 68 69 6A 6B 0035*      db 104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131
       6C 6D 6E 6F 
       70 71 72 73 
       74 75 76 77 
       78 79 7A 7B 
       7C 7D 7E 7F 
       80 81 82 83 
0431B7 84 85 86 87 0036*      db 132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
       88 89 8A 8B 
       8C 8D 8E 8F 
       90 91 92 93 
       94 95 96 97 
       98 99 9A 9B 
       9C 9D 9E 9F 
0431D3 A0 A1 A2 A3 0037*      db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187
       A4 A5 A6 A7 
       A8 A9 AA AB 
       AC AD AE AF 
       B0 B1 B2 B3 
       B4 B5 B6 B7 
       B8 B9 BA BB 
0431EF BC BD BE BF 0038*      db 188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215
       C0 C1 C2 C3 
       C4 C5 C6 C7 
       C8 C9 CA CB 
       CC CD CE CF 
       D0 D1 D2 D3 
       D4 D5 D6 D7 
04320B D8 D9 DA DB 0039*      db 216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243
       DC DD DE DF 
       E0 E1 E2 E3 
       E4 E5 E6 E7 
       E8 E9 EA EB 
       EC ED EE EF 
       F0 F1 F2 F3 
043227 F4 F5 F6 F7 0040*      db 244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
       F8 F9 FA FB 
       FC FD FE FF 
       00 01 02 03 
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
043243 10 11 12 13 0041*      db 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43
       14 15 16 17 
       18 19 1A 1B 
       1C 1D 1E 1F 
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
04325F 2C 2D 2E 2F 0042*      db 44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71
       30 31 32 33 
       34 35 36 37 
       38 39 3A 3B 
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
04327B 48 49 4A 4B 0043*      db 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99
       4C 4D 4E 4F 
       50 51 52 53 
       54 55 56 57 
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
043297             0048       include "maze_walls.inc"
043297             0001*  ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
043297             0002*  
043297             0003*  maze_walls:
043297 1C 00 00    0004*  maze_walls_num_cols: dl 28
04329A 1F 00 00    0005*  maze_walls_num_rows: dl 31
04329D 08 00 00    0006*  maze_walls_tile_size: dl 8
0432A0 06 00 00    0007*  maze_walls_null_tile: dl 6
0432A3 00 00 00    0008*  maze_walls_x: dl 0
0432A6 00 00 00    0009*  maze_walls_y: dl 0
0432A9 4E 01 00    0010*  maze_walls_base_bufferId: dl BUF_TILE_00
0432AC             0011*  
0432AC             0012*  maze_walls_map:
0432AC 00 01 01 01 0013*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,02,03,01,01,01,01,01,01,01,01,01,01,01,01,04
       01 01 01 01 
       01 01 01 01 
       01 02 03 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 04 
0432C8 05 06 06 06 0014*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 07 08 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
0432E4 05 06 0A 0B 0015*      db 05,06,10,11,11,12,06,10,11,11,11,12,06,07,08,06,10,11,11,11,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0B 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 0B 
       0C 06 0A 0B 
       0B 0C 06 09 
043300 05 06 07 06 0016*      db 05,06,07,06,06,08,06,07,06,06,06,08,06,07,08,06,07,06,06,06,08,06,07,06,06,08,06,09
       06 08 06 07 
       06 06 06 08 
       06 07 08 06 
       07 06 06 06 
       08 06 07 06 
       06 08 06 09 
04331C 05 06 0D 0E 0017*      db 05,06,13,14,14,15,06,13,14,14,14,15,06,13,15,06,13,14,14,14,15,06,13,14,14,15,06,09
       0E 0F 06 0D 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0F 06 0D 0E 
       0E 0F 06 09 
043338 05 06 06 06 0018*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
043354 05 06 0A 0B 0019*      db 05,06,10,11,11,12,06,10,12,06,10,11,11,11,11,11,11,12,06,10,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0C 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 0A 
       0C 06 0A 0B 
       0B 0C 06 09 
043370 05 06 0D 0E 0020*      db 05,06,13,14,14,15,06,07,08,06,13,14,14,16,17,14,14,15,06,07,08,06,13,14,14,15,06,09
       0E 0F 06 07 
       08 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 07 
       08 06 0D 0E 
       0E 0F 06 09 
04338C 05 06 06 06 0021*      db 05,06,06,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,06,06,09
       06 06 06 07 
       08 06 06 06 
       06 07 08 06 
       06 06 06 07 
       08 06 06 06 
       06 06 06 09 
0433A8 12 13 13 13 0022*      db 18,19,19,19,19,12,06,07,20,11,11,12,06,07,08,06,10,11,11,21,08,06,10,19,19,19,19,22
       13 0C 06 07 
       14 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 15 
       08 06 0A 13 
       13 13 13 16 
0433C4 06 06 06 06 0023*      db 06,06,06,06,06,05,06,07,17,14,14,15,06,13,15,06,13,14,14,16,08,06,09,06,06,06,06,06
       06 05 06 07 
       11 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 10 
       08 06 09 06 
       06 06 06 06 
0433E0 06 06 06 06 0024*      db 06,06,06,06,06,05,06,07,08,06,06,06,06,06,06,06,06,06,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 06 06 
       06 06 06 06 
       06 06 06 07 
       08 06 09 06 
       06 06 06 06 
0433FC 06 06 06 06 0025*      db 06,06,06,06,06,05,06,07,08,06,23,19,24,06,06,25,19,26,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 17 13 
       18 06 06 19 
       13 1A 06 07 
       08 06 09 06 
       06 06 06 06 
043418 01 01 01 01 0026*      db 01,01,01,01,01,15,06,13,15,06,09,06,06,06,06,06,06,05,06,13,15,06,13,01,01,01,01,01
       01 0F 06 0D 
       0F 06 09 06 
       06 06 06 06 
       06 05 06 0D 
       0F 06 0D 01 
       01 01 01 01 
043434 06 06 06 06 0027*      db 06,06,06,06,06,06,06,06,06,06,09,06,06,06,06,06,06,05,06,06,06,06,06,06,06,06,06,06
       06 06 06 06 
       06 06 09 06 
       06 06 06 06 
       06 05 06 06 
       06 06 06 06 
       06 06 06 06 
043450 13 13 13 13 0028*      db 19,19,19,19,19,12,06,10,12,06,09,06,06,06,06,06,06,05,06,10,12,06,10,19,19,19,19,19
       13 0C 06 0A 
       0C 06 09 06 
       06 06 06 06 
       06 05 06 0A 
       0C 06 0A 13 
       13 13 13 13 
04346C 06 06 06 06 0029*      db 06,06,06,06,06,05,06,07,08,06,27,01,01,01,01,01,01,28,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 1B 01 
       01 01 01 01 
       01 1C 06 07 
       08 06 09 06 
       06 06 06 06 
043488 06 06 06 06 0030*      db 06,06,06,06,06,05,06,07,08,06,06,06,06,06,06,06,06,06,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 06 06 
       06 06 06 06 
       06 06 06 07 
       08 06 09 06 
       06 06 06 06 
0434A4 06 06 06 06 0031*      db 06,06,06,06,06,05,06,07,08,06,10,11,11,11,11,11,11,12,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 07 
       08 06 09 06 
       06 06 06 06 
0434C0 00 01 01 01 0032*      db 00,01,01,01,01,15,06,13,15,06,13,14,14,16,17,14,14,15,06,13,15,06,13,01,01,01,01,29
       01 0F 06 0D 
       0F 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 0D 
       0F 06 0D 01 
       01 01 01 1D 
0434DC 05 06 06 06 0033*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 07 08 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
0434F8 05 06 0A 0B 0034*      db 05,06,10,11,11,12,06,10,11,11,11,12,06,07,08,06,10,11,11,11,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0B 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 0B 
       0C 06 0A 0B 
       0B 0C 06 09 
043514 05 06 0D 0E 0035*      db 05,06,13,14,16,08,06,13,14,14,14,15,06,13,15,06,13,14,14,14,15,06,07,17,14,15,06,09
       10 08 06 0D 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0F 06 07 11 
       0E 0F 06 09 
043530 05 06 06 06 0036*      db 05,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,09
       07 08 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 07 08 
       06 06 06 09 
04354C 1E 0B 0C 06 0037*      db 30,11,12,06,07,08,06,10,12,06,10,11,11,11,11,11,11,12,06,10,12,06,07,08,06,10,11,31
       07 08 06 0A 
       0C 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 0A 
       0C 06 07 08 
       06 0A 0B 1F 
043568 20 0E 0F 06 0038*      db 32,14,15,06,13,15,06,07,08,06,13,14,14,16,17,14,14,15,06,07,08,06,13,15,06,13,14,33
       0D 0F 06 07 
       08 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 07 
       08 06 0D 0F 
       06 0D 0E 21 
043584 05 06 06 06 0039*      db 05,06,06,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,06,06,09
       06 06 06 07 
       08 06 06 06 
       06 07 08 06 
       06 06 06 07 
       08 06 06 06 
       06 06 06 09 
0435A0 05 06 0A 0B 0040*      db 05,06,10,11,11,11,11,21,20,11,11,12,06,07,08,06,10,11,11,21,20,11,11,11,11,12,06,09
       0B 0B 0B 15 
       14 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 15 
       14 0B 0B 0B 
       0B 0C 06 09 
0435BC 05 06 0D 0E 0041*      db 05,06,13,14,14,14,14,14,14,14,14,15,06,13,15,06,13,14,14,14,14,14,14,14,14,15,06,09
       0E 0E 0E 0E 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0E 0E 0E 0E 
       0E 0F 06 09 
0435D8 05 06 06 06 0042*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
0435F4 12 13 13 13 0043*      db 18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,34
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 22 
043610             0049       include "maze_path.inc"
043610             0001*  ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
043610             0002*  ; Source file: beegee747/src/assets/design/sprites/maze_path/maze_path.csv
043610             0003*  
043610             0004*  maze_path:
043610 1C 00 00    0005*  maze_path_num_cols: dl 28
043613 1F 00 00    0006*  maze_path_num_rows: dl 31
043616 08 00 00    0007*  maze_path_tile_size: dl 8
043619 00 00 00    0008*  maze_path_null_tile: dl 0 ; not used for maze path definitions.
04361C 00 00 00    0009*  maze_path_x: dl 0
04361F 00 00 00    0010*  maze_path_y: dl 0
043622 00 00 00    0011*  maze_path_base_bufferId: dl 0 ; now used for maze path definitions.
043625             0012*  
043625             0013*  maze_path_map:
043625 00 00 00 00 0014*      db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043641 00 09 03 03 0015*      db 00,09,03,03,03,03,11,03,03,03,03,03,10,00,00,09,03,03,03,03,03,11,03,03,03,03,10,00
       03 03 0B 03 
       03 03 03 03 
       0A 00 00 09 
       03 03 03 03 
       03 0B 03 03 
       03 03 0A 00 
04365D 00 0C 00 00 0016*      db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
043679 00 0C 00 00 0017*      db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
043695 00 0C 00 00 0018*      db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
0436B1 00 0D 03 03 0019*      db 00,13,03,03,03,03,15,03,03,11,03,03,07,03,03,07,03,03,11,03,03,15,03,03,03,03,14,00
       03 03 0F 03 
       03 0B 03 03 
       07 03 03 07 
       03 03 0B 03 
       03 0F 03 03 
       03 03 0E 00 
0436CD 00 0C 00 00 0020*      db 00,12,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 0C 00 
0436E9 00 0C 00 00 0021*      db 00,12,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 0C 00 
043705 00 05 03 03 0022*      db 00,05,03,03,03,03,14,00,00,05,03,03,10,00,00,09,03,03,06,00,00,13,03,03,03,03,06,00
       03 03 0E 00 
       00 05 03 03 
       0A 00 00 09 
       03 03 06 00 
       00 0D 03 03 
       03 03 06 00 
043721 00 00 00 00 0023*      db 00,00,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 00 00 
04373D 00 00 00 00 0024*      db 00,00,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 00 00 
043759 00 00 00 00 0025*      db 00,00,00,00,00,00,12,00,00,09,03,03,07,03,03,07,03,03,10,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 09 03 03 
       07 03 03 07 
       03 03 0A 00 
       00 0C 00 00 
       00 00 00 00 
043775 00 00 00 00 0026*      db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
043791 00 00 00 00 0027*      db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
0437AD 03 03 03 03 0028*      db 03,03,03,03,03,03,15,03,03,14,00,00,00,00,00,00,00,00,13,03,03,15,03,03,03,03,03,03
       03 03 0F 03 
       03 0E 00 00 
       00 00 00 00 
       00 00 0D 03 
       03 0F 03 03 
       03 03 03 03 
0437C9 00 00 00 00 0029*      db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
0437E5 00 00 00 00 0030*      db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
043801 00 00 00 00 0031*      db 00,00,00,00,00,00,12,00,00,13,03,03,03,03,03,03,03,03,14,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0D 03 03 
       03 03 03 03 
       03 03 0E 00 
       00 0C 00 00 
       00 00 00 00 
04381D 00 00 00 00 0032*      db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
043839 00 00 00 00 0033*      db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
043855 00 09 03 03 0034*      db 00,09,03,03,03,03,15,03,03,07,03,03,10,00,00,09,03,03,07,03,03,15,03,03,03,03,10,00
       03 03 0F 03 
       03 07 03 03 
       0A 00 00 09 
       03 03 07 03 
       03 0F 03 03 
       03 03 0A 00 
043871 00 0C 00 00 0035*      db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
04388D 00 0C 00 00 0036*      db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
0438A9 00 05 03 0A 0037*      db 00,05,03,10,00,00,13,03,03,11,03,03,07,03,03,07,03,03,11,03,03,14,00,00,09,03,06,00
       00 00 0D 03 
       03 0B 03 03 
       07 03 03 07 
       03 03 0B 03 
       03 0E 00 00 
       09 03 06 00 
0438C5 00 00 00 0C 0038*      db 00,00,00,12,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,12,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       0C 00 00 00 
0438E1 00 00 00 0C 0039*      db 00,00,00,12,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,12,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       0C 00 00 00 
0438FD 00 09 03 07 0040*      db 00,09,03,07,03,03,06,00,00,05,03,03,10,00,00,09,03,03,06,00,00,05,03,03,07,03,10,00
       03 03 06 00 
       00 05 03 03 
       0A 00 00 09 
       03 03 06 00 
       00 05 03 03 
       07 03 0A 00 
043919 00 0C 00 00 0041*      db 00,12,00,00,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,00,00,12,00
       00 00 00 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 00 00 00 
       00 00 0C 00 
043935 00 0C 00 00 0042*      db 00,12,00,00,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,00,00,12,00
       00 00 00 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 00 00 00 
       00 00 0C 00 
043951 00 05 03 03 0043*      db 00,05,03,03,03,03,03,03,03,03,03,03,07,03,03,07,03,03,03,03,03,03,03,03,03,03,06,00
       03 03 03 03 
       03 03 03 03 
       07 03 03 07 
       03 03 03 03 
       03 03 03 03 
       03 03 06 00 
04396D 00 00 00 00 0044*      db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043989             0050       include "maze_pellets.inc"
043989             0001*  ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
043989             0002*  
043989             0003*  maze_pellets:
043989 1C 00 00    0004*  maze_pellets_num_cols: dl 28
04398C 1F 00 00    0005*  maze_pellets_num_rows: dl 31
04398F 08 00 00    0006*  maze_pellets_tile_size: dl 8
043992 00 00 00    0007*  maze_pellets_null_tile: dl 0
043995 00 00 00    0008*  maze_pellets_x: dl 0
043998 00 00 00    0009*  maze_pellets_y: dl 0
04399B 20 01 00    0010*  maze_pellets_base_bufferId: dl BUF_MAZE_PELLETS_00
04399E             0011*  
04399E             0012*  maze_pellets_map:
04399E 00 00 00 00 0013*      db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0439BA 00 01 01 01 0014*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 00 00 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
0439D6 00 01 00 00 0015*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
0439F2 00 02 00 00 0016*      db 00,02,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,02,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 02 00 
043A0E 00 01 00 00 0017*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
043A2A 00 01 01 01 0018*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043A46 00 01 00 00 0019*      db 00,01,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 01 00 
043A62 00 01 00 00 0020*      db 00,01,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 01 00 
043A7E 00 01 01 01 0021*      db 00,01,01,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,01,01,00
       01 01 01 00 
       00 01 01 01 
       01 00 00 01 
       01 01 01 00 
       00 01 01 01 
       01 01 01 00 
043A9A 00 00 00 00 0022*      db 00,00,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 00 00 
043AB6 00 00 00 00 0023*      db 00,00,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 00 00 
043AD2 00 00 00 00 0024*      db 00,00,00,00,00,00,01,00,00,01,01,01,01,01,01,01,01,01,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 01 01 
       01 01 01 01 
       01 01 01 00 
       00 01 00 00 
       00 00 00 00 
043AEE 00 00 00 00 0025*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B0A 00 00 00 00 0026*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B26 01 01 01 01 0027*      db 01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,00,00,00,01,01,01,01,01,01,01,01,01,01
       01 01 01 01 
       01 01 00 00 
       00 00 00 00 
       00 00 01 01 
       01 01 01 01 
       01 01 01 01 
043B42 00 00 00 00 0028*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B5E 00 00 00 00 0029*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B7A 00 00 00 00 0030*      db 00,00,00,00,00,00,01,00,00,01,01,01,01,01,01,01,01,01,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 01 01 
       01 01 01 01 
       01 01 01 00 
       00 01 00 00 
       00 00 00 00 
043B96 00 00 00 00 0031*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043BB2 00 00 00 00 0032*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043BCE 00 01 01 01 0033*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 00 00 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043BEA 00 01 00 00 0034*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
043C06 00 01 00 00 0035*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
043C22 00 02 01 01 0036*      db 00,02,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,02,00
       00 00 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 00 00 
       01 01 02 00 
043C3E 00 00 00 01 0037*      db 00,00,00,01,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,01,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       01 00 00 00 
043C5A 00 00 00 01 0038*      db 00,00,00,01,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,01,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       01 00 00 00 
043C76 00 01 01 01 0039*      db 00,01,01,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,01,01,00
       01 01 01 00 
       00 01 01 01 
       01 00 00 01 
       01 01 01 00 
       00 01 01 01 
       01 01 01 00 
043C92 00 01 00 00 0040*      db 00,01,00,00,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,00,00,01,00
       00 00 00 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 00 00 00 
       00 00 01 00 
043CAE 00 01 00 00 0041*      db 00,01,00,00,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,00,00,01,00
       00 00 00 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 00 00 00 
       00 00 01 00 
043CCA 00 01 01 01 0042*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043CE6 00 00 00 00 0043*      db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043D02             0051       include "player.inc"
043D02             0001*  ; ######## GAME STATE VARIABLES #######
043D02 00 00 00    0002*  player_score: dl 0 ; integer
043D05 03          0003*  player_lives: db 3 ; integer
043D06             0004*  speed_player: equ 0x000020 ; 0.125 map units per frame 16.8 fixed
043D06             0005*  
043D06             0006*  ; ######### PLAYER SPRITE PARAMETERS ##########
043D06             0007*  ; uses the same offsets from its table base as the main sprite table:
043D06             0008*  player_start_variables: ; label marking beginning of table
043D06 0F          0009*  player_id:               db table_max_records-1
043D07 00          0010*  player_type:             db     0x00 ; 1 bytes currently not used
043D08 32 01 00    0011*  player_base_bufferId:    dl BUF_PAC_MAN_00_00 ; 3 bytes bitmap bufferId
043D0B 00 00 00    0012*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
043D0E 00          0013*  player_collisions:       db     0x00 ; 1 bytes uses sprite_alive and sprite_just_died flags
043D0F 00          0014*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043D10 00          0015*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043D11 00 0D 00    0016*  player_x:                dl 0x000D00 ; 13 ; 3 bytes 16.8 fractional x position in pixels
043D14 00 17 00    0017*  player_y:                dl 0x001700 ; 23 ; 3 bytes 16.8 fractional y position in pixels
043D17 00 00 00    0018*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043D1A 00 00 00    0019*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043D1D 00 00 00    0020*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
043D20 00 00 00    0021*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043D23 01 00 00    0022*  player_orientation:      dl 1 ; 3 bytes, low four bits are direction mask, bit 0 = right
043D26 00          0023*  player_animation:        db     0x00 ; 1 bytes current animation index, zero-based
043D27 08          0024*  player_animation_timer:  db     8 ; 1 bytes
043D28 00          0025*  player_move_timer:       db     0x00 ; 1 bytes not currently used
043D29 00          0026*  player_move_step:        db     0x00 ; 1 bytes not currently used
043D2A 00          0027*  player_points:           db     0x00 ; 1 bytes not currently used
043D2B 00          0028*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
043D2C             0029*  player_end_variables: ; for when we want to traverse this table in reverse
043D2C             0030*  
043D2C             0031*  ; set initial player position
043D2C             0032*  ; inputs: none,everything is hardcoded
043D2C             0033*  ; outputs: player_x/y set to bottom-left corner of screen
043D2C             0034*  ; destroys: a
043D2C             0035*  player_init:
043D2C 3A 06 3D 04 0036*  	ld a,(player_id)
043D30 CD 85 19 04 0037*  	call vdu_sprite_select
043D34 CD 98 19 04 0038*      call vdu_sprite_clear_frames
043D38 21 32 01 00 0039*      ld hl,BUF_PAC_MAN_00_00
043D3C 06 0C       0040*      ld b,12 ; number of frames in the sprite
043D3E             0041*  @loop:
043D3E C5          0042*      push bc ; backup loop counter
043D3F E5          0043*      push hl
043D40 CD DA 1A 04 0044*      call vdu_sprite_add_buff
043D44 E1          0045*      pop hl
043D45 23          0046*      inc hl
043D46 C1          0047*      pop bc
043D47 10 F5       0048*      djnz @loop
043D49             0049*  ; initialize player position
043D49 01 00 0D 00 0050*      ld bc,0x000D00 ; 13
043D4D 11 00 17 00 0051*      ld de,0x001700 ; 23
043D51 DD 21 10 36 0052*      ld ix,maze_path
       04          
043D56 CD DC 2E 04 0053*      call map_to_screen
043D5A CD 51 1A 04 0054*      call vdu_sprite_move_abs168
043D5E CD FB 19 04 0055*      call vdu_sprite_show
043D62 21 1F 43 04 0056*      ld hl,player_alive
043D66 22 11 43 04 0057*      ld (player_state),hl
043D6A 21 0E 3D 04 0058*      ld hl,player_collisions
043D6E CB F6       0059*      set sprite_alive,(hl)
043D70             0060*  
043D70             0061*  ; ; DEBUG
043D70             0062*  ;     ld hl,speed_player
043D70             0063*  ;     ld (player_xvel),hl
043D70             0064*  ; ; END DEBUG
043D70 C9          0065*      ret
043D71             0066*  
043D71             0067*  ; process player keyboard input, set player bitmap
043D71             0068*  ; velocities and draw player bitmap at updated coordinates
043D71             0069*  ; Inputs: player_x/y set at desired position
043D71             0070*  ; Returns: player bitmap drawn at updated position
043D71             0071*  ; Destroys: probably everything except maybe iy
043D71             0072*  ; NOTE: in mode 9 we draw the player as a sprite, not a bitmap
043D71             0073*  ; TODO: requires sprite implementation
043D71             0074*  player_input:
043D71             0075*  ; set player as the active sprite
043D71 FD 21 06 3D 0076*      ld iy,player_start_variables
       04          
043D76 FD 22 F6 40 0077*      ld (table_pointer),iy
       04          
043D7B FD 7E 00    0078*      ld a,(iy+sprite_id)
043D7E CD 85 19 04 0079*      call vdu_sprite_select
043D82             0080*  ; DEBUG
043D82 CD 50 14 04 0081*      call vdu_home_cursor
043D86             0082*  ; END DEBUG
043D86             0083*  ; did we die last frame?
043D86 FD 7E 08    0084*      ld a,(iy+sprite_collisions)
043D89 E6 02       0085*      and %00000010 ; zero flag will be set if not dead
043D8B 28 05       0086*      jr z,player_not_dead
043D8D             0087*  ; yes we died
043D8D CD 71 3E 04 0088*      call kill_player
043D91 C9          0089*      ret ; done
043D92             0090*  player_not_dead: ; yay we didn't die
043D92             0091*  ; check for keypresses and branch accordingly
043D92             0092*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043D92             0093*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043D92 3E 1E       0001*M 			LD	A, function
043D94 5B CF       0002*M 			RST.LIL	08h
043D96             0094*  ; we test all four arrow keys and add/subract velocities accordingly
043D96             0095*  ; this handles the case where two opposing movement keys
043D96             0096*  ; are down simultaneously (velocities will net to zero)
043D96 AF          0097*      xor a ; reset orientation bits
043D97             0098*  ; 26 Left: move player left
043D97 DD CB 03 4E 0099*      bit 1,(ix+3)
043D9B CA A1 3D 04 0100*      jp z,@F
043D9F CB CF       0101*      set orient_left,a
043DA1             0102*  @@:
043DA1             0103*  ; 122 Right: move player right
043DA1 DD CB 0F 4E 0104*      bit 1,(ix+15)
043DA5 CA AB 3D 04 0105*  	jp z,@F
043DA9 CB C7       0106*      set orient_right,a
043DAB             0107*  @@:
043DAB             0108*  ; 58 Up: move player up
043DAB DD CB 07 4E 0109*      bit 1,(ix+7)
043DAF CA B5 3D 04 0110*  	jp z,@F
043DB3 CB D7       0111*      set orient_up,a
043DB5             0112*  @@:
043DB5             0113*  ; 42 Down: move player down
043DB5 DD CB 05 4E 0114*      bit 1,(ix+5)
043DB9 CA BF 3D 04 0115*  	jp z,@F
043DBD CB DF       0116*      set orient_down,a
043DBF             0117*  @@:
043DBF             0118*  ; test for no keyboard input
043DBF A7          0119*      and a
043DC0 C2 CB 3D 04 0120*      jp nz,@F ; we have input
043DC4 FD 7E 1D    0121*      ld a,(iy+sprite_orientation) ; use last orientation
043DC7 C3 D6 3D 04 0122*      jp @animation_timer
043DCB             0123*  @@:
043DCB             0124*  ; test for more than one input key pressed
043DCB 47          0125*      ld b,a
043DCC 3D          0126*      dec a
043DCD A0          0127*      and a,b
043DCE 78          0128*      ld a,b
043DCF             0129*  ; zero means only one key pressed
043DCF             0130*  ; (or none, if we had not done the zero check above)
043DCF CA D6 3D 04 0131*      jp z,@animation_timer
043DD3 FD 7E 1D    0132*      ld a,(iy+sprite_orientation) ; use last orientation
043DD6             0133*      ; fall through to @animation_timer
043DD6             0134*  @animation_timer:
043DD6 FD 77 1D    0135*      ld (iy+sprite_orientation),a
043DD9             0136*  ; time to bump the animation frame?
043DD9 FD 35 21    0137*      dec (iy+sprite_animation_timer)
043DDC C2 F5 3D 04 0138*      jp nz,@select_frame ; not time yet
043DE0             0139*  ; reset animation timer
043DE0 3E 08       0140*      ld a,8
043DE2 FD 77 21    0141*      ld (iy+sprite_animation_timer),a
043DE5             0142*  ; bump the animation frame
043DE5 FD 34 20    0143*      inc (iy+sprite_animation)
043DE8             0144*  ; time to wrap around to first frame?
043DE8 3E 03       0145*      ld a,3
043DEA FD BE 20    0146*      cp a,(iy+sprite_animation)
043DED C2 F5 3D 04 0147*      jp nz,@select_frame ; not time yet
043DF1             0148*  ; reset animation frame
043DF1 AF          0149*      xor a
043DF2 FD 77 20    0150*      ld (iy+sprite_animation),a
043DF5             0151*      ; fall through to @select_frame
043DF5             0152*  @select_frame:
043DF5 FD 7E 1D    0153*      ld a,(iy+sprite_orientation)
043DF8             0154*  ; find which bit is set in orientation
043DF8 2E 00       0155*      ld l,0 ; bit counter
043DFA             0156*  @find_bit:
043DFA 0F          0157*      rrca ; bit 0 to carry
043DFB DA 04 3E 04 0158*      jp c,@found_bit
043DFF 2C          0159*      inc l ; next bit
043E00 C3 FA 3D 04 0160*      jp @find_bit
043E04             0161*  @found_bit:
043E04 26 03       0162*      ld h,3 ; three frames per orientation
043E06 ED 6C       0163*      mlt hl
043E08 FD 7E 20    0164*      ld a,(iy+sprite_animation)
043E0B 85          0165*      add a,l
043E0C CD E8 19 04 0166*      call vdu_sprite_select_frame
043E10             0167*  ; set player velocities based on orientation
043E10 FD 7E 1D    0168*      ld a,(iy+sprite_orientation)
043E13 21 20 00 00 0169*      ld hl,speed_player
043E17 CD 3E 3E 04 0170*      call velocity_from_orientation
043E1B FD 0F 11    0171*      ld (iy+sprite_xvel),bc
043E1E FD 1F 14    0172*      ld (iy+sprite_yvel),de
043E21             0173*  ; compute preliminary new position based on velocities
043E21             0174*  ; and check whether it is valid
043E21 CD 6D 41 04 0175*      call move_sprite ; sprite_x and sprite_y are updated
043E25 DD 21 10 36 0176*      ld ix,maze_path ; point to the path definition
       04          
043E2A             0177*  
043E2A FD 07 0B    0178*      ld bc,(iy+sprite_x)
043E2D FD 17 0E    0179*      ld de,(iy+sprite_y)
043E30 DD 21 10 36 0180*      ld ix,maze_path
       04          
043E35 CD DC 2E 04 0181*      call map_to_screen
043E39 CD 51 1A 04 0182*  	call vdu_sprite_move_abs168
043E3D             0183*  ; done
043E3D C9          0184*      ret
043E3E             0185*  ; end player_input
043E3E             0186*  
043E3E             0187*  ; inputs: a = orientation, uh.l = speed in 16.8 fixed format
043E3E             0188*  ; outputs: ub.c and ud.e are vel_x and vel_y in 16.8 fixed format
043E3E             0189*  velocity_from_orientation:
043E3E             0190*  ; initialize velocities to zero
043E3E 01 00 00 00 0191*      ld bc,0
043E42 11 00 00 00 0192*      ld de,0
043E46             0193*  ; test for orientation
043E46 CB 4F       0194*      bit orient_left,a
043E48 C2 5F 3E 04 0195*      jp nz,@left
043E4C CB 47       0196*      bit orient_right,a
043E4E C2 66 3E 04 0197*      jp nz,@right
043E52 CB 57       0198*      bit orient_up,a
043E54 C2 69 3E 04 0199*      jp nz,@up
043E58 CB 5F       0200*      bit orient_down,a
043E5A C2 6F 3E 04 0201*      jp nz,@down
043E5E C9          0202*      ret ; no orientation set so velocities are zero
043E5F             0203*  @left:
043E5F CD 8E 07 04 0204*      call neg_hlu
043E63 E5          0205*      push hl
043E64 C1          0206*      pop bc
043E65 C9          0207*      ret
043E66             0208*  @right:
043E66 E5          0209*      push hl
043E67 C1          0210*      pop bc
043E68 C9          0211*      ret
043E69             0212*  @up:
043E69 CD 8E 07 04 0213*      call neg_hlu
043E6D EB          0214*      ex de,hl
043E6E C9          0215*      ret
043E6F             0216*  @down:
043E6F EB          0217*      ex de,hl
043E70 C9          0218*      ret
043E71             0219*  ; end velocity_from_orientation
043E71             0220*  
043E71             0221*  ; ###################################################################
043E71             0222*  ; TODO: the below is all stuff from the original code we need to port
043E71             0223*  ; ###################################################################
043E71             0224*  
043E71             0225*  kill_player:
043E71             0226*  ; ; set player status to dead
043E71             0227*  ;     xor a; sets all player flags to zero
043E71             0228*  ;     ld (player_collisions),a
043E71             0229*  ; ; deduct a player from the inventory
043E71             0230*  ;     ld a,(player_lives)
043E71             0231*  ;     dec a
043E71             0232*  ;     ld (player_lives),a
043E71             0233*  ; ; are we out of players?
043E71             0234*  ;     jp z,game_over
043E71             0235*  ; ; wait a few ticks
043E71             0236*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
043E71             0237*  ;     ld (player_move_timer),a
043E71             0238*  ; kill_player_loop:
043E71             0239*  ;     call vdu_vblank
043E71             0240*  ;     ld a,(player_move_timer)
043E71             0241*  ;     dec a
043E71             0242*  ;     ld (player_move_timer),a
043E71             0243*  ;     jr nz,kill_player_loop
043E71             0244*  ;     call player_init ; player respawn if timer zero
043E71 C9          0245*      ret ; and out
043E72             0246*  
043E72             0247*  ; draws the player's shields level
043E72             0248*  ; draw_shields:
043E72             0249*  ; TODO: Agonize this routine
043E72             0250*  ; ; prep the loop to draw the bars
043E72             0251*  ;     ld a,(player_shields) ; snag shields
043E72             0252*  ;     and a
043E72             0253*  ;     ret z ; don't draw if zero shields
043E72             0254*  ; ; set loop counter and drawing position
043E72             0255*  ;     ld b,a ; loop counter
043E72             0256*  ;     ld hl,#5300+48+12
043E72             0257*  ; ; set color based on bars remaining
043E72             0258*  ;     ld c,103 ; bright green 28fe0a
043E72             0259*  ;     cp 9
043E72             0260*  ;     jp p,draw_shields_loop
043E72             0261*  ;     ld c,74 ; bright yellow eafe5b
043E72             0262*  ;     cp 3
043E72             0263*  ;     jp p,draw_shields_loop
043E72             0264*  ;     ld c,28 ; bright red fe0a0a
043E72             0265*  ; draw_shields_loop:
043E72             0266*  ;     push bc ; yup,outta
043E72             0267*  ;     push hl ; registers again
043E72             0268*  ;     ; ld a,#A8 ; â–€,168
043E72             0269*  ;     ld a,10 ; â–€,168 ; we renumber because we don't use the full charset
043E72             0270*  ;     ; call draw_char
043E72             0271*  ;     call draw_num ; we nuked draw_char for the time being
043E72             0272*  ;     pop hl
043E72             0273*  ;     ld a,8
043E72             0274*  ;     add a,l
043E72             0275*  ;     ld l,a
043E72             0276*  ;     pop bc
043E72             0277*  ;     djnz draw_shields_loop
043E72             0278*      ; ret
043E72             0279*  
043E72             0280*  score_x: equ 0
043E72             0281*  score_y: equ 1
043E72             0282*  ; prints the player's score
043E72             0283*  print_score:
043E72             0284*  ; DEBUG
043E72 0E 00       0285*      ld c,score_x
043E74 06 00       0286*      ld b,score_y-1
043E76 CD 87 14 04 0287*      call vdu_move_cursor
043E7A CD 70 00 04 0288*      call printInline
043E7E 53 63 6F 72 0289*      asciz "Score:"
       65 3A 00    
043E85             0290*  ; END DEBUG
043E85 0E 00       0291*      ld c,score_x
043E87 06 01       0292*      ld b,score_y
043E89 CD 87 14 04 0293*      call vdu_move_cursor
043E8D 2A 02 3D 04 0294*      ld hl,(player_score)
043E91 CD 76 01 04 0295*      call printDec
043E95 C9          0296*      ret
043E96             0297*  
043E96             0298*  ; draw_lives:
043E96             0299*  ;     ld hl,player_small ; make small yellow player the active sprite
043E96             0300*  ;     ld (sprite_base_bufferId),hl
043E96             0301*  ;     ; ld a,#80 ; northern orientation
043E96             0302*  ;     ; ld (sprite_orientation),a
043E96             0303*  ;     ld hl,0 ; north
043E96             0304*  ;     ld (sprite_heading),hl
043E96             0305*  ;     xor a
043E96             0306*  ;     ld (sprite_animation),a
043E96             0307*  ;     ld a,#56 ; top of visible screen
043E96             0308*  ;     ld (sprite_y+1),a
043E96             0309*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043E96             0310*  ;     ld a,(player_lives)
043E96             0311*  ;     dec a ; we draw one fewer players than lives
043E96             0312*  ;     ret z ; nothing to draw here, move along
043E96             0313*  ;     ld b,a ; loop counter
043E96             0314*  ;     ld a,256-16 ; initial x position
043E96             0315*  ; draw_lives_loop:
043E96             0316*  ;     ld (sprite_x+1),a
043E96             0317*  ;     push af
043E96             0318*  ;     push bc
043E96             0319*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043E96             0320*  ;     pop bc
043E96             0321*  ;     pop af
043E96             0322*  ;     sub 10
043E96             0323*  ;     djnz draw_lives_loop
043E96             0324*  ;     ret
043E96             0052       include "sprites.inc"
043E96             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
043E96             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
043E96             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
043E96             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
043E96             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
043E96             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
043E96             0007*  sprite_collisions:      equ 08 ; 1 bytes see collisions.inc constants for bit definitions
043E96             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
043E96             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
043E96             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
043E96             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
043E96             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043E96             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043E96             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
043E96             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
043E96             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
043E96             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
043E96             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
043E96             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
043E96             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
043E96             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type
043E96             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision
043E96             0023*  
043E96             0024*  ; ###### SPRITE TABLE VARIABLES ######
043E96             0025*  ; maximum number of sprites
043E96             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
043E96             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
043E96             0028*  
043E96             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
043E96             0030*  table_base:
043E96 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0440F6             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0440F6             0033*  
0440F6             0034*  ; pointer to top address of current record, initialized to table_base
0440F6 96 3E 04    0035*  table_pointer: dl table_base
0440F9             0036*  ; how many active sprites
0440F9 00          0037*  table_active_sprites: db 0x00
0440FA             0038*  ; flag indicating collision with screen edge
0440FA             0039*  ; uses orientation codes to specify which edge(s)
0440FA 00          0040*  sprite_screen_edge: db #00
0440FB             0041*  ; next sprite id to use
0440FB 00          0042*  sprite_next_id: db 0
0440FC             0043*  
0440FC             0044*  ; origin_top: equ 48
0440FC             0045*  origin_top: equ 0 ; DEBUG
0440FC             0046*  origin_left: equ 128
0440FC             0047*  field_top: equ 0
0440FC             0048*  field_bottom: equ 383-origin_top
0440FC             0049*  field_left: equ 0
0440FC             0050*  field_right: equ 255
0440FC             0051*  sprite_top: equ 0
0440FC             0052*  sprite_bottom: equ field_bottom-16
0440FC             0053*  sprite_left: equ field_left
0440FC             0054*  sprite_right: equ field_right-16
0440FC             0055*  
0440FC             0056*  ; ######### COLLISION SPRITE PARAMETERS ##########
0440FC             0057*  ; integer coordinates are all that are needed for collision calculations
0440FC 00          0058*  collision_x: db 0x00
0440FD 00          0059*  collision_y: db 0x00
0440FE 00          0060*  collision_dim_x: db 0x00
0440FF 00          0061*  collision_dim_y: db 0x00
044100             0062*  
044100             0063*  ; scratch variables
044100 00          0064*  x: db 0x00 ; 8-bit signed integer
044101 00          0065*  y: db 0x00 ; 8-bit signed integer
044102 00 00 00    0066*  x0: dl 0x000000 ; 16.8 signed fixed place
044105 00 00 00    0067*  y0: dl 0x000000 ; 16.8 signed fixed place
044108 00 00 00    0068*  incx1: dl 0x000000 ; 16.8 signed fixed place
04410B 00 00 00    0069*  incy1: dl 0x000000 ; 16.8 signed fixed place
04410E 00 00 00    0070*  incx2: dl 0x000000 ; 16.8 signed fixed place
044111 00 00 00    0071*  incy2: dl 0x000000 ; 16.8 signed fixed place
044114             0072*  
044114             0073*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
044114 00 00 00    0074*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
044117 00 00 00    0075*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
04411A 00 00 00    0076*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
04411D             0077*  
04411D             0078*  ; gets the next available sprite id
04411D             0079*  ; inputs; none
04411D             0080*  ; returns: if new sprite available, a = sprite id,
04411D             0081*  ;           ix pointing to new sprite vars, carry set
04411D             0082*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
04411D             0083*  ; destroys: a,b,hl,ix
04411D             0084*  ; affects: bumps table_active_sprites by one
04411D             0085*  table_get_next_id:
04411D DD 21 96 3E 0086*      ld ix,table_base
       04          
044122 11 26 00 00 0087*      ld de,table_bytes_per_record
044126 06 10       0088*      ld b,table_max_records
044128             0089*  @loop:
044128 DD 7E 01    0090*      ld a,(ix+sprite_type)
04412B A7          0091*      and a
04412C 28 06       0092*      jr z,@found
04412E DD 19       0093*      add ix,de
044130 10 F6       0094*      djnz @loop
044132             0095*  @notfound:
044132 AF          0096*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
044133 C9          0097*      ret
044134             0098*  @found:
044134             0099*  ; bump number of active sprites
044134 21 F9 40 04 0100*      ld hl,table_active_sprites
044138 34          0101*      inc (hl)
044139             0102*  ; return sprite id
044139 3E 10       0103*      ld a,table_max_records
04413B 90          0104*      sub b
04413C 32 FB 40 04 0105*      ld (sprite_next_id),a
044140 37          0106*      scf ; sets carry flag indicating we found a free sprite
044141 C9          0107*      ret ; done
044142             0108*  ; end table_get_next_id
044142             0109*  
044142             0110*  ; deactivate the sprite with the given id
044142             0111*  ; inputs: iy set to sprite record, vdu_sprite_select called
044142             0112*  ; outputs: nothing
044142             0113*  ; destroys: a,hl
044142             0114*  ; affects: decrements table_active_sprites by one
044142             0115*  table_deactivate_sprite:
044142 CD 09 1A 04 0116*      call vdu_sprite_hide
044146 AF          0117*      xor a
044147 FD 77 01    0118*      ld (iy+sprite_type),a
04414A 21 F9 40 04 0119*      ld hl,table_active_sprites
04414E 35          0120*      dec (hl)
04414F C9          0121*      ret
044150             0122*  ; end table_deactivate_sprite
044150             0123*  
044150             0124*  sprites_init:
044150             0125*  ; initialize sprites
044150 CD B9 1A 04 0126*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
044154 AF          0127*  	xor a
044155             0128*  @sprite_loop:
044155 F5          0129*  	push af
044156 CD 85 19 04 0130*  	call vdu_sprite_select
04415A 21 00 01 00 0131*  	ld hl,256 ; can be anything, so we just use the first one on the list
04415E CD DA 1A 04 0132*  	call vdu_sprite_add_buff
044162 F1          0133*  	pop af
044163 3C          0134*  	inc a
044164 FE 10       0135*  	cp table_max_records
044166 20 ED       0136*  	jr nz,@sprite_loop
044168 CD B9 19 04 0137*  	call vdu_sprite_activate
04416C             0138*  ; all done
04416C C9          0139*      ret
04416D             0140*  ; end sprites_init
04416D             0141*  
04416D             0142*  ; compute a sprite's new position based on its component x,y velocities
04416D             0143*  ; with screen boundary checking and update its sprite table record accordingly
04416D             0144*  ; inputs: table_pointer set to sprite record
04416D             0145*  ; returns: updated x, y positions and edge collision flags in sprite table record
04416D             0146*  ; destroys: everything
04416D             0147*  ; note: actual rendering of sprite must be handled by caller
04416D             0148*  move_sprite:
04416D FD 2A F6 40 0149*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
044172             0150*  ; x-axis movement
044172 FD 27 0B    0151*      ld hl,(iy+sprite_x)
044175 FD 17 11    0152*      ld de,(iy+sprite_xvel)
044178 19          0153*      add hl,de
044179 FD 2F 0B    0154*      ld (iy+sprite_x),hl
04417C             0155*  ; y-axis movement
04417C FD 27 0E    0156*      ld hl,(iy+sprite_y)
04417F FD 17 14    0157*      ld de,(iy+sprite_yvel)
044182 19          0158*      add hl,de
044183 FD 2F 0E    0159*      ld (iy+sprite_y),hl
044186             0160*  ; detect screen edge collisions
044186 AF          0161*      xor a ; reset screen edge collision flag and clear carry
044187 32 FA 40 04 0162*      ld (sprite_screen_edge),a
04418B             0163*  ; y-axis first since we already have it in hl
04418B 11 00 00 00 0164*      ld de,-sprite_top*256
04418F ED 5A       0165*      adc hl,de
044191 FA BB 41 04 0166*      jp m,@top
044195 ED 52       0167*      sbc hl,de ; hl back to original value
044197 11 00 91 FE 0168*      ld de,-sprite_bottom*256
04419B ED 5A       0169*      adc hl,de
04419D F2 C5 41 04 0170*      jp p,@bottom
0441A1             0171*  @xaxis:
0441A1 FD 27 0B    0172*      ld hl,(iy+sprite_x)
0441A4 11 00 00 00 0173*      ld de,-sprite_left*256
0441A8 ED 5A       0174*      adc hl,de
0441AA FA E0 41 04 0175*      jp m,@left
0441AE ED 52       0176*      sbc hl,de ; hl back to original value
0441B0 11 00 11 FF 0177*      ld de,-sprite_right*256
0441B4 ED 5A       0178*      adc hl,de
0441B6 F2 EE 41 04 0179*      jp p,@right
0441BA             0180*  ; no edge collisions so go home
0441BA C9          0181*      ret
0441BB             0182*  @top:
0441BB 3E 08       0183*      ld a,collide_top
0441BD 21 00 00 00 0184*      ld hl,sprite_top*256
0441C1 C3 CB 41 04 0185*      jp @collide_y
0441C5             0186*  @bottom:
0441C5 3E 04       0187*      ld a,collide_bottom
0441C7 21 00 6F 01 0188*      ld hl,sprite_bottom*256
0441CB             0189*  @collide_y:
0441CB 32 FA 40 04 0190*      ld (sprite_screen_edge),a
0441CF FD 2F 0E    0191*      ld (iy+sprite_y),hl
0441D2             0192*  ; reverse y-axis velocity
0441D2 FD 27 14    0193*      ld hl,(iy+sprite_yvel)
0441D5 CD 8E 07 04 0194*      call neg_hlu
0441D9 FD 2F 14    0195*      ld (iy+sprite_yvel),hl
0441DC             0196*  ; go check for x-axis collisions
0441DC C3 A1 41 04 0197*      jp @xaxis
0441E0             0198*  @left:
0441E0 3A FA 40 04 0199*      ld a,(sprite_screen_edge)
0441E4 F6 02       0200*      or a,collide_left
0441E6 21 00 00 00 0201*      ld hl,sprite_left*256
0441EA C3 F8 41 04 0202*      jp @collide_x
0441EE             0203*  @right:
0441EE 3A FA 40 04 0204*      ld a,(sprite_screen_edge)
0441F2 F6 01       0205*      or a,collide_right
0441F4 21 00 EF 00 0206*      ld hl,sprite_right*256
0441F8             0207*  @collide_x:
0441F8 32 FA 40 04 0208*      ld (sprite_screen_edge),a
0441FC FD 2F 0B    0209*      ld (iy+sprite_x),hl
0441FF             0210*  ; reverse x-axis velocity
0441FF FD 27 11    0211*      ld hl,(iy+sprite_xvel)
044202 CD 8E 07 04 0212*      call neg_hlu
044206 FD 2F 11    0213*      ld (iy+sprite_xvel),hl
044209             0214*  ; final collision flag to a and return
044209 3A FA 40 04 0215*      ld a,(sprite_screen_edge)
04420D C9          0216*      ret
04420E             0217*  ; end move_sprite
04420E             0218*  
04420E             0219*  sprite_compute_velocities:
04420E FD 2A F6 40 0220*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
044213 FD 17 17    0221*      ld de,(iy+sprite_vel)
044216 CD 18 0A 04 0222*      call polar_to_cartesian
04421A FD 2A F6 40 0223*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04421F FD 0F 11    0224*      ld (iy+sprite_xvel),bc ; save x-velocity component
044222 FD 1F 14    0225*      ld (iy+sprite_yvel),de ; save y-velocity component
044225 C9          0226*      ret
044226             0227*  ; end sprite_compute_velocities
044226             0053       include "state.inc"
044226 00          0001*  cur_level: db 0
044227             0002*  
044227             0003*  init_level:
044227             0004*  ; offset gfx origin to account for sprite size
044227 01 80 00 00 0005*      ld bc,origin_left
04422B 11 05 00 00 0006*      ld de,origin_top+5 ; TODO: this is a weird value, is it legit?
04422F CD 20 15 04 0007*      call vdu_set_gfx_origin
044233             0008*  ; draw maze and pellets
044233 DD 21 97 32 0009*      ld ix,maze_walls
       04          
044238 21 4E 01 00 0010*      ld hl,BUF_TILE_00
04423C CD 4A 2E 04 0011*      call draw_maze
044240 DD 21 89 39 0012*      ld ix,maze_pellets
       04          
044245 21 20 01 00 0013*      ld hl,BUF_MAZE_PELLETS_00
044249 CD 4A 2E 04 0014*      call draw_maze
04424D             0015*  ; restore gfx origin to normal
04424D 01 80 00 00 0016*      ld bc,origin_left
044251 11 00 00 00 0017*      ld de,origin_top
044255 CD 20 15 04 0018*      call vdu_set_gfx_origin
044259 C9          0019*      ret
04425A             0020*  
04425A             0021*  ; Game state variables
04425A 68 42 04    0022*  game_state:  dl game_main_menu
04425D             0023*  
04425D             0024*  do_game:
04425D 2A 5A 42 04 0025*      ld hl,(game_state)   ; Load the current game state
044261             0026*      callHL                ; Call the corresponding state handler
044261 01 67 42 04 0001*M     ld bc,@F ; Address of first instruction after the jump
044265 C5          0002*M     push bc ; which constitutes the return address
044266 E9          0003*M     jp (hl) ; Jump to the address in HL
044267             0004*M @@:
044267 C9          0027*      ret
044268             0028*  
044268             0029*  ; ========================
044268             0030*  ; Main Game States
044268             0031*  ; ========================
044268             0032*  
044268             0033*  game_main_menu:
044268             0034*      ; Handle main menu options
044268             0035*      ; Example: Check input for "Start Game"
044268 CD 39 43 04 0036*      call check_input_menu
04426C C2 71 42 04 0037*      jp nz, game_initialize ; Start game on selection
044270 C9          0038*      ret
044271             0039*  
044271             0040*  game_initialize:
044271             0041*  ; reset the sprite table
044271 AF          0042*      xor a
044272 32 F9 40 04 0043*      ld (table_active_sprites),a
044276 21 96 3E 04 0044*      ld hl,table_base
04427A 22 F6 40 04 0045*      ld (table_pointer),hl
04427E             0046*  ; initialize sprites
04427E CD 50 41 04 0047*      call sprites_init
044282             0048*  ; initialize the first level
044282 AF          0049*      xor a
044283 32 26 42 04 0050*      ld (cur_level),a
044287 CD 27 42 04 0051*      call init_level
04428B             0052*  ; initialize player
04428B 21 00 00 00 0053*      ld hl,0
04428F 22 02 3D 04 0054*      ld (player_score),hl
044293 3E 03       0055*      ld a,3
044295 32 05 3D 04 0056*      ld (player_lives),a
044299 CD 2C 3D 04 0057*      call player_init
04429D             0058*  ; set the game state to playing
04429D 21 A7 42 04 0059*      ld hl,game_playing
0442A1 22 5A 42 04 0060*      ld (game_state), hl
0442A5 C9          0061*      ret
0442A6             0062*  ; done initializing
0442A6 C9          0063*      ret
0442A7             0064*  
0442A7             0065*  game_playing:
0442A7             0066*  ; Main gameplay loop
0442A7 CD 14 43 04 0067*      call do_player
0442AB CD 25 43 04 0068*      call do_enemies
0442AF             0069*  ; update UI: TODO make this a standalone function
0442AF CD 72 3E 04 0070*      call print_score
0442B3 C9          0071*      ret
0442B4             0072*  
0442B4             0073*  game_paused:
0442B4             0074*      ; Pause menu logic
0442B4 CD 3C 43 04 0075*      call check_input_pause
0442B8 C2 A7 42 04 0076*      jp nz, game_playing ; Resume game
0442BC CA 68 42 04 0077*      jp z, game_main_menu ; Exit to main menu
0442C0 C9          0078*      ret
0442C1             0079*  
0442C1             0080*  game_level_transition:
0442C1             0081*      ; Handle level transitions
0442C1 CD 3D 43 04 0082*      call load_next_level
0442C5 21 A7 42 04 0083*      ld hl, game_playing
0442C9 22 5A 42 04 0084*      ld (game_state), hl
0442CD C9          0085*      ret
0442CE             0086*  
0442CE             0087*  game_over:
0442CE             0088*      ; Display game over screen
0442CE CD 3E 43 04 0089*      call display_game_over
0442D2 C2 68 42 04 0090*      jp nz, game_main_menu ; Return to main menu on input
0442D6 C9          0091*      ret
0442D7             0092*  
0442D7             0093*  game_victory:
0442D7             0094*      ; Display victory screen
0442D7 CD 3F 43 04 0095*      call display_victory
0442DB C2 68 42 04 0096*      jp nz, game_main_menu ; Return to main menu on input
0442DF C9          0097*      ret
0442E0             0098*  
0442E0             0099*  ; ========================
0442E0             0100*  ; Supporting States
0442E0             0101*  ; ========================
0442E0             0102*  
0442E0             0103*  game_loading:
0442E0             0104*      ; Show loading screen while preparing assets
0442E0 CD 40 43 04 0105*      call load_resources
0442E4 21 71 42 04 0106*      ld hl, game_initialize
0442E8 22 5A 42 04 0107*      ld (game_state), hl
0442EC C9          0108*      ret
0442ED             0109*  
0442ED             0110*  game_cutscene:
0442ED             0111*      ; Play a non-interactive cutscene
0442ED CD 41 43 04 0112*      call play_cutscene
0442F1 C2 A7 42 04 0113*      jp nz, game_playing ; Return to gameplay after cutscene
0442F5 C9          0114*      ret
0442F6             0115*  
0442F6             0116*  game_inventory:
0442F6             0117*      ; Open inventory or shop
0442F6 CD 42 43 04 0118*      call display_inventory
0442FA C2 A7 42 04 0119*      jp nz, game_playing ; Return to gameplay after inventory close
0442FE C9          0120*      ret
0442FF             0121*  
0442FF             0122*  game_map:
0442FF             0123*      ; Display map or quest
0442FF CD 43 43 04 0124*      call display_map
044303 C2 A7 42 04 0125*      jp nz, game_playing ; Return to gameplay after map close
044307 C9          0126*      ret
044308             0127*  
044308             0128*  game_exit:
044308             0129*      ; Handle exit logic
044308 CD 44 43 04 0130*      call save_game
04430C C3 45 43 04 0131*      jp exit_game         ; Safely shut down
044310 C9          0132*      ret
044311             0133*  
044311             0134*  ; ========================
044311             0135*  ; Sub-state branching (Example for player state)
044311             0136*  ; ========================
044311             0137*  
044311 1F 43 04    0138*  player_state:  dl player_alive ; Player state variable
044314             0139*  
044314             0140*  do_player:
044314 2A 11 43 04 0141*      ld hl,(player_state)
044318             0142*      callHL                ; Call the corresponding player state
044318 01 1E 43 04 0001*M     ld bc,@F ; Address of first instruction after the jump
04431C C5          0002*M     push bc ; which constitutes the return address
04431D E9          0003*M     jp (hl) ; Jump to the address in HL
04431E             0004*M @@:
04431E C9          0143*      ret
04431F             0144*  
04431F             0145*  player_alive:
04431F CD 71 3D 04 0146*      call player_input     ; Handle player input
044323 C9          0147*      ret
044324             0148*  
044324             0149*  player_dead:
044324 C9          0150*      ret
044325             0151*  
044325             0152*  do_enemies:
044325 2A 30 43 04 0153*      ld hl, (enemies_state)
044329             0154*      callHL
044329 01 2F 43 04 0001*M     ld bc,@F ; Address of first instruction after the jump
04432D C5          0002*M     push bc ; which constitutes the return address
04432E E9          0003*M     jp (hl) ; Jump to the address in HL
04432F             0004*M @@:
04432F C9          0155*      ret
044330 33 43 04    0156*  enemies_state: dl enemies_dead
044333             0157*  enemies_dead:
044333 C9          0158*      ret
044334             0159*  
044334             0160*  enemies_alive:
044334 CD 22 1B 04 0161*      call move_enemies
044338 C9          0162*      ret
044339             0163*  
044339             0164*  check_input_menu:
044339 C9          0165*      ret
04433A             0166*  
04433A             0167*  update_game_world:
04433A C9          0168*      ret
04433B             0169*  
04433B             0170*  check_game_events:
04433B C9          0171*      ret
04433C             0172*  
04433C             0173*  check_input_pause:
04433C C9          0174*      ret
04433D             0175*  
04433D             0176*  load_next_level:
04433D C9          0177*      ret
04433E             0178*  
04433E             0179*  display_game_over:
04433E C9          0180*      ret
04433F             0181*  
04433F             0182*  display_victory:
04433F C9          0183*      ret
044340             0184*  
044340             0185*  load_resources:
044340 C9          0186*      ret
044341             0187*  
044341             0188*  play_cutscene:
044341 C9          0189*      ret
044342             0190*  
044342             0191*  display_inventory:
044342 C9          0192*      ret
044343             0193*  
044343             0194*  display_map:
044343 C9          0195*      ret
044344             0196*  
044344             0197*  save_game:
044344 C9          0198*      ret
044345             0199*  
044345             0200*  exit_game:
044345 C9          0201*      ret
044346             0202*  
044346             0054   
044346             0055   init:
044346 C9          0056       ret
044347             0057   
044347             0058   main:
044347 AF          0059       xor a
044348 CB D7       0060       set orient_up, a
04434A CB DF       0061       set orient_down,a
04434C F5          0062       push af
04434D CD 15 03 04 0063       call printBin8
044351 F1          0064       pop af
044352 E6 0C       0065       and 12
044354 CD 15 03 04 0066       call printBin8
044358 CD 8C 00 04 0067       call printNewLine
04435C             0068   
04435C             0069       ; call printNewLine
04435C             0070       ; ld ix,maze_index
04435C             0071       ; ld bc,0x000324 ; 3.142
04435C             0072       ; ld de,0x0002B7 ; 2.718
04435C             0073       ; call map_get_cell
04435C             0074       ; call dumpRegistersHex
04435C             0075       ; call printNewLine
04435C             0076   
04435C             0077       ; call printNewLine
04435C             0078       ; ld ix,maze_index
04435C             0079       ; ld bc,0x000324 ; 3.142
04435C             0080       ; ld de,0x0002B7 ; 2.718
04435C             0081       ; call map_to_screen
04435C             0082       ; call dumpRegistersHex
04435C             0083       ; call printNewLine
04435C             0084   
04435C             0085       ; call printNewLine
04435C             0086       ; ld ix,maze_index
04435C             0087       ; ld bc,0x003733 ; 55.2
04435C             0088       ; ld de,0x001666 ; 22.4
04435C             0089       ; call screen_to_map
04435C             0090       ; ld a,(ix)
04435C             0091       ; call dumpRegistersHex
04435C             0092       ; call printNewLine
04435C             0093   
04435C             0094   main_end:
04435C C9          0095       ret
