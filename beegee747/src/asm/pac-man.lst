PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000 C3 45 00 04 0003       jp start
040004 FF FF FF FF 0004       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005       db "MOS"
040043 00          0006       db 00h
040044 01          0007       db 01h
040045             0008   
040045             0009   start:
040045 F5          0010       push af
040046 C5          0011       push bc
040047 D5          0012       push de
040048 DD E5       0013       push ix
04004A FD E5       0014       push iy
04004C CD 36 3B 04 0015       call init
040050 CD B8 3B 04 0016       call main
040054             0017   
040054             0018   exit:
040054 FD E1       0019       pop iy
040056 DD E1       0020       pop ix
040058 D1          0021       pop de
040059 C1          0022       pop bc
04005A F1          0023       pop af
04005B 21 00 00 00 0024       ld hl,0
04005F             0025   
04005F C9          0026       ret
040060             0027   
040060             0028   ; API INCLUDES
040060             0029       include "mos_api.inc"
040060             0001*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*  ; Title:	AGON MOS - API for user projects
040060             0003*  ; Author:	Dean Belfield
040060             0004*  ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*  ;			Added MOS error codes for return in HL
040060             0006*  ; Created:	03/08/2022
040060             0007*  ; Last Updated:	10/08/2023
040060             0008*  ;
040060             0009*  ; Modinfo:
040060             0010*  ; 05/08/2022:	Added mos_feof
040060             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*  ; 13/10/2022:	Added mos_oscli
040060             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*  ; 19/05/2023:	Added sysvar_scrMode
040060             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*  ; 03/08/2023:	Added mos_setkbvector
040060             0028*  ; 10/08/2023:	Added mos_getkbmap
040060             0029*  
040060             0030*  ; VDP control (VDU 23, 0, n)
040060             0031*  ;
040060             0032*  vdp_gp:				EQU 80h
040060             0033*  vdp_keycode:		EQU 81h
040060             0034*  vdp_cursor:			EQU	82h
040060             0035*  vdp_scrchar:		EQU	83h
040060             0036*  vdp_scrpixel:		EQU	84h
040060             0037*  vdp_audio:			EQU	85h
040060             0038*  vdp_mode:			EQU	86h
040060             0039*  vdp_rtc:			EQU	87h
040060             0040*  vdp_keystate:		EQU	88h
040060             0041*  vdp_logicalcoords:	EQU	C0h
040060             0042*  vdp_terminalmode:	EQU	FFh
040060             0043*  
040060             0044*  ; MOS high level functions
040060             0045*  ;
040060             0046*  mos_getkey:			EQU	00h
040060             0047*  mos_load:			EQU	01h
040060             0048*  mos_save:			EQU	02h
040060             0049*  mos_cd:				EQU	03h
040060             0050*  mos_dir:			EQU	04h
040060             0051*  mos_del:			EQU	05h
040060             0052*  mos_ren:			EQU	06h
040060             0053*  mos_mkdir:			EQU	07h
040060             0054*  mos_sysvars:		EQU	08h
040060             0055*  mos_editline:		EQU	09h
040060             0056*  mos_fopen:			EQU	0Ah
040060             0057*  mos_fclose:			EQU	0Bh
040060             0058*  mos_fgetc:			EQU	0Ch
040060             0059*  mos_fputc:			EQU	0Dh
040060             0060*  mos_feof:			EQU	0Eh
040060             0061*  mos_getError:		EQU	0Fh
040060             0062*  mos_oscli:			EQU	10h
040060             0063*  mos_copy:			EQU	11h
040060             0064*  mos_getrtc:			EQU	12h
040060             0065*  mos_setrtc:			EQU	13h
040060             0066*  mos_setintvector:	EQU	14h
040060             0067*  mos_uopen:			EQU	15h
040060             0068*  mos_uclose:			EQU	16h
040060             0069*  mos_ugetc:			EQU	17h
040060             0070*  mos_uputc:			EQU	18h
040060             0071*  mos_getfil:			EQU	19h
040060             0072*  mos_fread:			EQU	1Ah
040060             0073*  mos_fwrite:			EQU	1Bh
040060             0074*  mos_flseek:			EQU	1Ch
040060             0075*  mos_setkbvector:	EQU	1Dh
040060             0076*  mos_getkbmap:		EQU	1Eh
040060             0077*  
040060             0078*  ; MOS program exit codes
040060             0079*  ;
040060             0080*  EXIT_OK:				EQU  0;	"OK",
040060             0081*  EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*  EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*  EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*  EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*  EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*  EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*  EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*  EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*  EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*  EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*  EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*  EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*  EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*  EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*  EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*  EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*  EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*  EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*  EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*  EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*  EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*  ; FatFS file access functions
040060             0103*  ;
040060             0104*  ffs_fopen:			EQU	80h
040060             0105*  ffs_fclose:			EQU	81h
040060             0106*  ffs_fread:			EQU	82h
040060             0107*  ffs_fwrite:			EQU	83h
040060             0108*  ffs_flseek:			EQU	84h
040060             0109*  ffs_ftruncate:		EQU	85h
040060             0110*  ffs_fsync:			EQU	86h
040060             0111*  ffs_fforward:		EQU	87h
040060             0112*  ffs_fexpand:		EQU	88h
040060             0113*  ffs_fgets:			EQU	89h
040060             0114*  ffs_fputc:			EQU	8Ah
040060             0115*  ffs_fputs:			EQU	8Bh
040060             0116*  ffs_fprintf:		EQU	8Ch
040060             0117*  ffs_ftell:			EQU	8Dh
040060             0118*  ffs_feof:			EQU	8Eh
040060             0119*  ffs_fsize:			EQU	8Fh
040060             0120*  ffs_ferror:			EQU	90h
040060             0121*  
040060             0122*  ; FatFS directory access functions
040060             0123*  ;
040060             0124*  ffs_dopen:			EQU	91h
040060             0125*  ffs_dclose:			EQU	92h
040060             0126*  ffs_dread:			EQU	93h
040060             0127*  ffs_dfindfirst:		EQU	94h
040060             0128*  ffs_dfindnext:		EQU	95h
040060             0129*  
040060             0130*  ; FatFS file and directory management functions
040060             0131*  ;
040060             0132*  ffs_stat:			EQU	96h
040060             0133*  ffs_unlink:			EQU	97h
040060             0134*  ffs_rename:			EQU	98h
040060             0135*  ffs_chmod:			EQU	99h
040060             0136*  ffs_utime:			EQU	9Ah
040060             0137*  ffs_mkdir:			EQU	9Bh
040060             0138*  ffs_chdir:			EQU	9Ch
040060             0139*  ffs_chdrive:		EQU	9Dh
040060             0140*  ffs_getcwd:			EQU	9Eh
040060             0141*  
040060             0142*  ; FatFS volume management and system configuration functions
040060             0143*  ;
040060             0144*  ffs_mount:			EQU	9Fh
040060             0145*  ffs_mkfs:			EQU	A0h
040060             0146*  ffs_fdisk:			EQU	A1h
040060             0147*  ffs_getfree:		EQU	A2h
040060             0148*  ffs_getlabel:		EQU	A3h
040060             0149*  ffs_setlabel:		EQU	A4h
040060             0150*  ffs_setcp:			EQU	A5h
040060             0151*  
040060             0152*  ; File access modes
040060             0153*  ;
040060             0154*  fa_read:			EQU	01h
040060             0155*  fa_write:			EQU	02h
040060             0156*  fa_open_existing:	EQU	00h
040060             0157*  fa_create_new:		EQU	04h
040060             0158*  fa_create_always:	EQU	08h
040060             0159*  fa_open_always:		EQU	10h
040060             0160*  fa_open_append:		EQU	30h
040060             0161*  
040060             0162*  ; System variable indexes for api_sysvars
040060             0163*  ; Index into _sysvars in globals.inc
040060             0164*  ;
040060             0165*  sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*  sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*  sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*  sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*  sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*  sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*  sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*  sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*  sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*  sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*  sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*  sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*  sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*  sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*  sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*  sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*  sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*  sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*  sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*  sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*  sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*  sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*  sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*  
040060             0192*  ; Flags for the VPD protocol
040060             0193*  ;
040060             0194*  vdp_pflag_cursor:		EQU	00000001b
040060             0195*  vdp_pflag_scrchar:		EQU	00000010b
040060             0196*  vdp_pflag_point:		EQU	00000100b
040060             0197*  vdp_pflag_audio:		EQU	00001000b
040060             0198*  vdp_pflag_mode:			EQU	00010000b
040060             0199*  vdp_pflag_rtc:			EQU	00100000b
040060             0200*  
040060             0201*  ;
040060             0202*  ; FatFS structures
040060             0203*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*  ;
040060             0205*  ; Object ID and allocation information (FFOBJID)
040060             0206*  ;
040060             0207*  ; Indexes into FFOBJID structure
040060             0208*  ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*  ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*  ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*  ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*  ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*  ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*  ;
040060             0215*  ; File object structure (FIL)
040060             0216*  ;
040060             0217*  ; Indexes into FIL structure
040060             0218*  fil_obj:		EQU 0	; 15: Object identifier
040060             0219*  fil_flag:		EQU	15 	;  1: File status flags
040060             0220*  fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*  fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*  fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*  fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*  fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*  fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*  ;
040060             0227*  ; Directory object structure (DIR)
040060             0228*  ; Indexes into DIR structure
040060             0229*  dir_obj:		EQU  0	; 15: Object identifier
040060             0230*  dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*  dir_clust:		EQU	19	;  4: Current cluster
040060             0232*  dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*  dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*  dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*  dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*  ;
040060             0237*  ; File information structure (FILINFO)
040060             0238*  ;
040060             0239*  ; Indexes into FILINFO structure
040060             0240*  filinfo_fsize:		EQU 0	;   4: File size
040060             0241*  filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*  filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*  filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*  filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*  filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*  ;
040060             0247*  ; Macro for calling the API
040060             0248*  ; Parameters:
040060             0249*  ; - function: One of the function numbers listed above
040060             0250*  ;
040060             0251*  	MACRO	MOSCALL	function
040060             0252*  			LD	A, function
040060             0253*  			RST.LIL	08h
040060             0254*  	ENDMACRO
040060             0030       include "functions.inc"
040060             0001*  
040060             0002*      MACRO printChar char
040060             0003*      LD A, char
040060             0004*      RST.LIL 10h
040060             0005*      ENDMACRO
040060             0006*  
040060             0007*  ; Simulated call to subroutine at HL
040060             0008*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0009*  ; outputs: whatever the subroutine does, including HL and BC
040060             0010*  ; destroys: only what the subroutine does, but always BC
040060             0011*      MACRO callHL
040060             0012*      ld bc,@F ; Address of first instruction after the jump
040060             0013*      push bc ; which constitutes the return address
040060             0014*      jp (hl) ; Jump to the address in HL
040060             0015*  @@:
040060             0016*      ENDMACRO
040060             0017*  
040060             0018*  ; Simulated call to subroutine at IX
040060             0019*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0020*  ; outputs: whatever the subroutine does, including IX and BC
040060             0021*  ; destroys: only what the subroutine does, but always BC
040060             0022*      MACRO callIX
040060             0023*      ld bc,@F ; Address of first instruction after the jump
040060             0024*      push bc ; which constitutes the return address
040060             0025*      jp (ix) ; Jump to the address in IX
040060             0026*  @@:
040060             0027*      ENDMACRO
040060             0028*  
040060             0029*  ; Simulated call to soubroutinte at IY
040060             0030*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0031*  ; outputs: whatever the subroutine does, including IY and BC
040060             0032*  ; destroys: only what the subroutine does, but always BC
040060             0033*      MACRO callIY
040060             0034*      ld bc,@F ; Address of first instruction after the jump
040060             0035*      push bc ; which constitutes the return address
040060             0036*      jp (iy) ; Jump to the address in IY
040060             0037*  @@:
040060             0038*      ENDMACRO
040060             0039*  
040060             0040*  ; put the value in HLU into the accumulator
040060             0041*  ; destroys: af
040060             0042*      MACRO HLU_TO_A
040060             0043*      push hl ; 4 cycles
040060             0044*      inc sp ; 1 cycle
040060             0045*      pop af ; 4 cycles
040060             0046*      dec sp ; 1 cycle
040060             0047*      ; 10 cycles total
040060             0048*      ENDMACRO
040060             0049*  
040060             0050*  A_TO_HLU:
040060             0051*      ; call is 7 cycles
040060 22 6D 00 04 0052*      ld (@scratch),hl ; 7 cycles
040064 32 6F 00 04 0053*      ld (@scratch+2),a ; 5 cycles
040068 2A 6D 00 04 0054*      ld hl,(@scratch) ; 7 cycles
04006C C9          0055*      ret ; 6 cycles
04006D             0056*      ; 25 cycles total
04006D 00 00 00    0057*  @scratch: dl 0
040070             0058*  
040070             0059*      ; TODO: implement this
040070             0060*      ; MACRO A_TO_HLU
040070             0061*      ;     push.s af
040070             0062*      ;     inc sp
040070             0063*      ;     push.s hl
040070             0064*      ;     pop hl
040070             0065*      ;     inc sp
040070             0066*      ;     inc sp
040070             0067*      ; ENDMACRO
040070             0068*  
040070             0069*      MACRO PUSH_ALL
040070             0070*      ex af,af'
040070             0071*      exx
040070             0072*      push af
040070             0073*      push hl
040070             0074*      push bc
040070             0075*      push de
040070             0076*  
040070             0077*      ex af,af'
040070             0078*      exx
040070             0079*      push af
040070             0080*      push hl
040070             0081*      push bc
040070             0082*      push de
040070             0083*      push ix
040070             0084*      push iy
040070             0085*      ENDMACRO
040070             0086*  
040070             0087*      MACRO POP_ALL
040070             0088*      pop iy
040070             0089*      pop ix
040070             0090*      pop de
040070             0091*      pop bc
040070             0092*      pop hl
040070             0093*      pop af
040070             0094*      ex af,af'
040070             0095*      exx
040070             0096*  
040070             0097*      pop de
040070             0098*      pop bc
040070             0099*      pop hl
040070             0100*      pop af
040070             0101*      ex af,af'
040070             0102*      exx
040070             0103*      ENDMACRO
040070             0104*  
040070             0105*  ; Print a zero-terminated string inline with code, e.g.:
040070             0106*  ;
040070             0107*  ;    call printInline
040070             0108*  ;    ASCIZ "Hello, world!\r\n"
040070             0109*  ;
040070             0110*  ; Destroys: HL,AF
040070             0111*  printInline:
040070 E1          0112*      pop hl ; get the return address = pointer to start of string
040071 CD 77 00 04 0113*      call printString ; HL advances to end of string
040075 E5          0114*      push hl ; restore the return address = pointer to end of string
040076 C9          0115*      ret
040077             0116*  
040077             0117*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040077             0118*  ; Print a zero-terminated string
040077             0119*  ; HL: Pointer to string
040077             0120*  printString:
040077 C5          0121*      PUSH BC
040078 01 00 00 00 0122*      LD BC,0
04007C 3E 00       0123*      LD A,0
04007E 5B DF       0124*      RST.LIL 18h
040080 C1          0125*      POP BC
040081 C9          0126*      RET
040082             0127*  ; print a VDU sequence
040082             0128*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040082             0129*  sendVDUsequence:
040082 C5          0130*      PUSH BC
040083 01 00 00 00 0131*      LD BC, 0
040087 4E          0132*      LD C, (HL)
040088 5B DF       0133*      RST.LIL 18h
04008A C1          0134*      POP BC
04008B C9          0135*      RET
04008C             0136*  ; Print Newline sequence to VDP
04008C             0137*  printNewLine:
04008C F5          0138*      push af ; for some reason rst.lil 10h sets carry flag
04008D 3E 0D       0139*      LD A, '\r'
04008F 5B D7       0140*      RST.LIL 10h
040091 3E 0A       0141*      LD A, '\n'
040093 5B D7       0142*      RST.LIL 10h
040095 F1          0143*      pop af
040096 C9          0144*      RET
040097             0145*  
040097             0146*  ; Print a 24-bit HEX number
040097             0147*  ; HLU: Number to print
040097             0148*  printHex24:
040097             0149*      HLU_TO_A
040097 E5          0001*M     push hl ; 4 cycles
040098 33          0002*M     inc sp ; 1 cycle
040099 F1          0003*M     pop af ; 4 cycles
04009A 3B          0004*M     dec sp ; 1 cycle
04009B             0005*M     ; 10 cycles total
04009B CD A5 00 04 0150*      CALL printHex8
04009F             0151*  ; Print a 16-bit HEX number
04009F             0152*  ; HL: Number to print
04009F             0153*  printHex16:
04009F 7C          0154*      LD A,H
0400A0 CD A5 00 04 0155*      CALL printHex8
0400A4 7D          0156*      LD A,L
0400A5             0157*  ; Print an 8-bit HEX number
0400A5             0158*  ; A: Number to print
0400A5             0159*  printHex8:
0400A5 4F          0160*      LD C,A
0400A6 1F          0161*      RRA
0400A7 1F          0162*      RRA
0400A8 1F          0163*      RRA
0400A9 1F          0164*      RRA
0400AA CD AF 00 04 0165*      CALL @F
0400AE 79          0166*      LD A,C
0400AF             0167*  @@:
0400AF E6 0F       0168*      AND 0Fh
0400B1 C6 90       0169*      ADD A,90h
0400B3 27          0170*      DAA
0400B4 CE 40       0171*      ADC A,40h
0400B6 27          0172*      DAA
0400B7 5B D7       0173*      RST.LIL 10h
0400B9 C9          0174*      RET
0400BA             0175*  
0400BA             0176*  printHexA:
0400BA F5          0177*      push af
0400BB C5          0178*      push bc
0400BC CD A5 00 04 0179*      call printHex8
0400C0 3E 20       0180*      ld a,' '
0400C2 5B D7       0181*      rst.lil 10h
0400C4 C1          0182*      pop bc
0400C5 F1          0183*      pop af
0400C6 C9          0184*      ret
0400C7             0185*  
0400C7             0186*  printHexHL:
0400C7 F5          0187*      push af
0400C8 C5          0188*      push bc
0400C9 CD 9F 00 04 0189*      call printHex16
0400CD 3E 20       0190*      ld a,' '
0400CF 5B D7       0191*      rst.lil 10h
0400D1 C1          0192*      pop bc
0400D2 F1          0193*      pop af
0400D3 C9          0194*      ret
0400D4             0195*  
0400D4             0196*  printHexUHL:
0400D4 F5          0197*      push af
0400D5 C5          0198*      push bc
0400D6 CD 97 00 04 0199*      call printHex24
0400DA 3E 20       0200*      ld a,' '
0400DC 5B D7       0201*      rst.lil 10h
0400DE C1          0202*      pop bc
0400DF F1          0203*      pop af
0400E0 C9          0204*      ret
0400E1             0205*  
0400E1             0206*  printHexAUHL:
0400E1 F5          0207*      push af
0400E2 C5          0208*      push bc
0400E3 CD A5 00 04 0209*      call printHex8
0400E7 3E 2E       0210*      ld a,'.'
0400E9 5B D7       0211*      rst.lil 10h
0400EB CD 97 00 04 0212*      call printHex24
0400EF 3E 20       0213*      ld a,' '
0400F1 5B D7       0214*      rst.lil 10h
0400F3 C1          0215*      pop bc
0400F4 F1          0216*      pop af
0400F5 C9          0217*      ret
0400F6             0218*  
0400F6             0219*  printHexABHL:
0400F6             0220*  ; preserve registers
0400F6 C5          0221*      push bc ; b will be ok c will not
0400F7 F5          0222*      push af ; will get totally destroyed
0400F8             0223*  ; print a
0400F8 CD A5 00 04 0224*      call printHex8
0400FC             0225*  ; print b
0400FC 78          0226*      ld a,b
0400FD CD A5 00 04 0227*      call printHex8
040101             0228*  ; print hl
040101 CD 9F 00 04 0229*      call printHex16
040105             0230*  ; restore registers
040105 F1          0231*      pop af
040106 C1          0232*      pop bc
040107 C9          0233*      ret
040108             0234*  
040108             0235*  printHexBHL:
040108             0236*  ; preserve registers
040108 C5          0237*      push bc ; b will be ok c will not
040109 F5          0238*      push af ; will get totally destroyed
04010A             0239*  ; print b
04010A 78          0240*      ld a,b
04010B CD A5 00 04 0241*      call printHex8
04010F             0242*  ; print hl
04010F CD 9F 00 04 0243*      call printHex16
040113             0244*  ; restore registers
040113 F1          0245*      pop af
040114 C1          0246*      pop bc
040115 C9          0247*      ret
040116             0248*  
040116             0249*  printHexCDE:
040116             0250*  ; preserve registers
040116 C5          0251*      push bc ; b will be ok c will not
040117 F5          0252*      push af ; will get totally destroyed
040118             0253*  ; print c
040118 79          0254*      ld a,c
040119 CD A5 00 04 0255*      call printHex8
04011D             0256*  ; print de
04011D EB          0257*      ex de,hl
04011E CD 9F 00 04 0258*      call printHex16
040122 EB          0259*      ex de,hl
040123             0260*  ; restore registers
040123 F1          0261*      pop af
040124 C1          0262*      pop bc
040125 C9          0263*      ret
040126             0264*  
040126             0265*  printHexUIX:
040126             0266*  ; store everything in scratch
040126 22 9F 05 04 0267*      ld (uhl),hl
04012A ED 43 A2 05 0268*      ld (ubc),bc
       04          
04012F ED 53 A5 05 0269*      ld (ude),de
       04          
040134 DD 22 A8 05 0270*      ld (uix),ix
       04          
040139 FD 22 AB 05 0271*      ld (uiy),iy
       04          
04013E F5          0272*      push af ; fml
04013F             0273*  
04013F 21 36 05 04 0274*      ld hl,str_ixu
040143 CD 77 00 04 0275*      call printString
040147 2A A8 05 04 0276*      ld hl,(uix)
04014B CD 97 00 04 0277*      call printHex24
04014F CD 8C 00 04 0278*      call printNewLine
040153             0279*  
040153             0280*  ; restore everything
040153 2A 9F 05 04 0281*      ld hl, (uhl)
040157 ED 4B A2 05 0282*      ld bc, (ubc)
       04          
04015C ED 5B A5 05 0283*      ld de, (ude)
       04          
040161 DD 2A A8 05 0284*      ld ix, (uix)
       04          
040166 FD 2A AB 05 0285*      ld iy, (uiy)
       04          
04016B F1          0286*      pop af
04016C             0287*  ; all done
04016C C9          0288*      ret
04016D             0289*  
04016D             0290*  ; Print a 0x HEX prefix
04016D             0291*  DisplayHexPrefix:
04016D 3E 30       0292*      LD A, '0'
04016F 5B D7       0293*      RST.LIL 10h
040171 3E 78       0294*      LD A, 'x'
040173 5B D7       0295*      RST.LIL 10h
040175 C9          0296*      RET
040176             0297*  
040176             0298*      MACRO printDecBC
040176             0299*      push hl
040176             0300*      push bc
040176             0301*      pop hl
040176             0302*      call printDec
040176             0303*      pop hl
040176             0304*      ENDMACRO
040176             0305*  
040176             0306*      MACRO printDecDE
040176             0307*      push hl
040176             0308*      push de
040176             0309*      pop hl
040176             0310*      call printDec
040176             0311*      pop hl
040176             0312*      ENDMACRO
040176             0313*  
040176             0314*      MACRO printDecHL
040176             0315*      call printDec
040176             0316*      ENDMACRO
040176             0317*  
040176             0318*      MACRO printDecIX
040176             0319*      push hl
040176             0320*      push ix
040176             0321*      pop hl
040176             0322*      call printDec
040176             0323*      pop hl
040176             0324*      ENDMACRO
040176             0325*  
040176             0326*      MACRO printDecIY
040176             0327*      push hl
040176             0328*      push iy
040176             0329*      pop hl
040176             0330*      call printDec
040176             0331*      pop hl
040176             0332*      ENDMACRO
040176             0333*  
040176             0334*  
040176             0335*  ; Prints the right justified decimal value in HL without leading zeroes
040176             0336*  ; HL : Value to print
040176             0337*  ; preserves all registers and flags
040176             0338*  printDec:
040176             0339*  ; BEGIN MY CODE
040176             0340*  ; back up all the things
040176 F5          0341*      push af
040177 C5          0342*      push bc
040178 D5          0343*      push de
040179 E5          0344*      push hl
04017A             0345*  ; END MY CODE
04017A 11 A2 01 04 0346*      LD DE, _printDecBuffer
04017E CD B2 01 04 0347*      CALL u24_to_ascii
040182             0348*  ; BEGIN MY CODE
040182             0349*  ; replace leading zeroes with spaces
040182 21 A2 01 04 0350*      LD HL, _printDecBuffer
040186 06 07       0351*      ld B, 7 ; if HL was 0, we want to keep the final zero
040188             0352*  @loop:
040188 7E          0353*      LD A, (HL)
040189 FE 30       0354*      CP '0'
04018B C2 95 01 04 0355*      JP NZ, @done
04018F 3E 20       0356*      LD A, ' '
040191 77          0357*      LD (HL), A
040192 23          0358*      INC HL
040193             0359*      ; CALL vdu_cursor_forward
040193 10 F3       0360*      DJNZ @loop
040195             0361*  @done:
040195             0362*  ; END MY CODE
040195 21 A2 01 04 0363*      LD HL, _printDecBuffer
040199 CD 77 00 04 0364*      CALL printString
04019D             0365*  ; BEGIN MY CODE
04019D             0366*  ; restore all the things
04019D E1          0367*      pop hl
04019E D1          0368*      pop de
04019F C1          0369*      pop bc
0401A0 F1          0370*      pop af
0401A1             0371*  ; END MY CODE
0401A1 C9          0372*      RET
0401A2 00 00 00 00 0373*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0401B2             0374*  
0401B2             0375*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0401B2             0376*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0401B2             0377*  ; so it will allways be 8 characters length
0401B2             0378*  ; HL : Value to convert to string
0401B2             0379*  ; DE : pointer to buffer, at least 8 byte + 0
0401B2             0380*  u24_to_ascii:
0401B2 01 80 69 67 0381*      LD BC,-10000000
0401B6 CD E9 01 04 0382*      CALL @one_digit
0401BA 01 C0 BD F0 0383*      LD BC,-1000000
0401BE CD E9 01 04 0384*      CALL @one_digit
0401C2 01 60 79 FE 0385*      LD BC,-100000
0401C6 CD E9 01 04 0386*      CALL @one_digit
0401CA 01 F0 D8 FF 0387*      LD BC,-10000
0401CE CD E9 01 04 0388*      CALL @one_digit
0401D2 01 18 FC FF 0389*      LD BC,-1000
0401D6 CD E9 01 04 0390*      CALL @one_digit
0401DA 01 9C FF FF 0391*      LD BC,-100
0401DE CD E9 01 04 0392*      CALL @one_digit
0401E2 0E F6       0393*      LD C,-10
0401E4 CD E9 01 04 0394*      CALL @one_digit
0401E8 48          0395*      LD C,B
0401E9             0396*  @one_digit:
0401E9 3E 2F       0397*      LD A,'0'-1
0401EB             0398*  @divide_me:
0401EB 3C          0399*      INC A
0401EC 09          0400*      ADD HL,BC
0401ED 38 FC       0401*      JR C,@divide_me
0401EF ED 42       0402*      SBC HL,BC
0401F1 12          0403*      LD (DE),A
0401F2 13          0404*      INC DE
0401F3 C9          0405*      RET
0401F4             0406*  
0401F4             0407*  print_u24:
0401F4 D5          0408*      push de
0401F5 E5          0409*      push hl
0401F6 11 A2 01 04 0410*      ld de,_printDecBuffer
0401FA CD B2 01 04 0411*      call u24_to_ascii
0401FE 21 A2 01 04 0412*      ld hl,_printDecBuffer
040202 CD 77 00 04 0413*      call printString
040206 3E 20       0414*      ld a,' '
040208 5B D7       0415*      rst.lil 10h
04020A E1          0416*      pop hl
04020B D1          0417*      pop de
04020C C9          0418*      ret
04020D             0419*  
04020D             0420*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04020D             0421*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04020D             0422*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04020D             0423*  u168_to_ascii:
04020D             0424*  ; add a leading space to make room for sign flag if needed
04020D 3E 20       0425*      ld a,' '
04020F 12          0426*      ld (de),a
040210 13          0427*      inc de
040211             0428*  ; Convert integer part
040211 E5          0429*      push hl ; Save HL (weâ€™ll need the fractional part later)
040212 CD FB 06 04 0430*      call hlu_udiv256 ; Shift to get integer portion in HL
040216 01 F0 D8 FF 0431*      ld bc, -10000
04021A CD 3D 02 04 0432*      call @one_int
04021E 01 18 FC FF 0433*      ld bc, -1000
040222 CD 3D 02 04 0434*      call @one_int
040226 01 9C FF FF 0435*      ld bc, -100
04022A CD 3D 02 04 0436*      call @one_int
04022E 0E F6       0437*      ld c, -10
040230 CD 3D 02 04 0438*      call @one_int
040234 48          0439*      ld c, b
040235 CD 3D 02 04 0440*      call @one_int
040239 C3 48 02 04 0441*      jp @frac ; Jump to fractional part conversion
04023D             0442*  @one_int:
04023D 3E 2F       0443*      ld a, '0' - 1 ; Start ASCII character at '0'
04023F             0444*  @divide_me:
04023F 3C          0445*      inc a
040240 09          0446*      add hl, bc ; Accumulate until overflow
040241 38 FC       0447*      jr c, @divide_me
040243 ED 42       0448*      sbc hl, bc ; Remove excess after overflow
040245 12          0449*      ld (de), a ; Store ASCII digit
040246 13          0450*      inc de
040247 C9          0451*      ret
040248             0452*  ; Convert fractional part
040248             0453*  @frac:
040248 3E 2E       0454*      ld a, '.' ; Decimal point
04024A 12          0455*      ld (de), a
04024B 13          0456*      inc de
04024C E1          0457*      pop hl ; Restore HL with original fraction
04024D 06 03       0458*      ld b, 3 ; Loop counter for 3 fractional digits
04024F             0459*  @frac_loop:
04024F 26 0A       0460*      ld h, 10 ; Load multiplier for fractional part
040251 ED 6C       0461*      mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040253 3E 30       0462*      ld a, '0'
040255 84          0463*      add a, h ; Convert integer part to ASCII
040256 12          0464*      ld (de), a
040257 13          0465*      inc de
040258 10 F5       0466*      djnz @frac_loop ; Repeat for each fractional digit
04025A             0467*  ; Add null terminator
04025A AF          0468*      xor a ; Null terminator
04025B 12          0469*      ld (de), a
04025C C9          0470*      ret
04025D             0471*  
04025D             0472*  print_u168:
04025D D5          0473*      push de
04025E E5          0474*      push hl
04025F 11 A2 01 04 0475*      ld de,_printDecBuffer
040263 CD 0D 02 04 0476*      call u168_to_ascii
040267 21 A2 01 04 0477*      ld hl,_printDecBuffer
04026B CD 77 00 04 0478*      call printString
04026F E1          0479*      pop hl
040270 D1          0480*      pop de
040271 C9          0481*      ret
040272             0482*  
040272             0483*  ; signed version of u168_to_ascii
040272             0484*  s168_to_ascii:
040272 D5          0485*      push de ; save starting address of buffer
040273 CD 94 06 04 0486*      call hlu_abs
040277 F5          0487*      push af ; save sign flag
040278 CD 0D 02 04 0488*      call u168_to_ascii
04027C F1          0489*      pop af ; restore sign flag
04027D D1          0490*      pop de ; restore starting address of buffer
04027E F0          0491*      ret p ; hlu was positive so nothing to do
04027F 3E 2D       0492*      ld a,'-'
040281 12          0493*      ld (de),a
040282 C9          0494*      ret
040283             0495*  
040283             0496*  print_s168:
040283 D5          0497*      push de
040284 E5          0498*      push hl
040285 11 A2 01 04 0499*      ld de,_printDecBuffer
040289 CD 72 02 04 0500*      call s168_to_ascii
04028D 21 A2 01 04 0501*      ld hl,_printDecBuffer
040291 CD 77 00 04 0502*      call printString
040295 E1          0503*      pop hl
040296 D1          0504*      pop de
040297 C9          0505*      ret
040298             0506*  
040298             0507*  print_s168_hl:
040298 F5          0508*      push af
040299 E5          0509*      push hl
04029A CD 83 02 04 0510*      call print_s168
04029E 3E 20       0511*      ld a,' '
0402A0 5B D7       0512*      rst.lil 10h
0402A2 E1          0513*      pop hl
0402A3 F1          0514*      pop af
0402A4 C9          0515*      ret
0402A5             0516*  
0402A5             0517*  print_s168_bc:
0402A5 F5          0518*      push af
0402A6 C5          0519*      push bc
0402A7 E5          0520*      push hl
0402A8 C5          0521*      push bc
0402A9 E1          0522*      pop hl
0402AA CD 83 02 04 0523*      call print_s168
0402AE 3E 20       0524*      ld a,' '
0402B0 5B D7       0525*      rst.lil 10h
0402B2 E1          0526*      pop hl
0402B3 C1          0527*      pop bc
0402B4 F1          0528*      pop af
0402B5 C9          0529*      ret
0402B6             0530*  
0402B6             0531*  print_s168_de:
0402B6 F5          0532*      push af
0402B7 D5          0533*      push de
0402B8 E5          0534*      push hl
0402B9 EB          0535*      ex de,hl
0402BA CD 83 02 04 0536*      call print_s168
0402BE 3E 20       0537*      ld a,' '
0402C0 5B D7       0538*      rst.lil 10h
0402C2 E1          0539*      pop hl
0402C3 D1          0540*      pop de
0402C4 F1          0541*      pop af
0402C5 C9          0542*      ret
0402C6             0543*  
0402C6             0544*  print_s168_hl_bc_de:
0402C6 F5          0545*      push af
0402C7 C5          0546*      push bc
0402C8 D5          0547*      push de
0402C9 E5          0548*      push hl
0402CA CD 83 02 04 0549*      call print_s168
0402CE 3E 20       0550*      ld a,' '
0402D0 5B D7       0551*      rst.lil 10h
0402D2 C5          0552*      push bc
0402D3 E1          0553*      pop hl
0402D4 CD 83 02 04 0554*      call print_s168
0402D8 3E 20       0555*      ld a,' '
0402DA 5B D7       0556*      rst.lil 10h
0402DC EB          0557*      ex de,hl
0402DD CD 83 02 04 0558*      call print_s168
0402E1 3E 20       0559*      ld a,' '
0402E3 5B D7       0560*      rst.lil 10h
0402E5 E1          0561*      pop hl
0402E6 D1          0562*      pop de
0402E7 C1          0563*      pop bc
0402E8 F1          0564*      pop af
0402E9 C9          0565*      ret
0402EA             0566*  
0402EA             0567*  print_s168_bc_de:
0402EA F5          0568*      push af
0402EB C5          0569*      push bc
0402EC D5          0570*      push de
0402ED C5          0571*      push bc
0402EE E1          0572*      pop hl
0402EF CD 83 02 04 0573*      call print_s168
0402F3 3E 20       0574*      ld a,' '
0402F5 5B D7       0575*      rst.lil 10h
0402F7 EB          0576*      ex de,hl
0402F8 CD 83 02 04 0577*      call print_s168
0402FC 3E 20       0578*      ld a,' '
0402FE 5B D7       0579*      rst.lil 10h
040300 E1          0580*      pop hl
040301 D1          0581*      pop de
040302 C1          0582*      pop bc
040303 F1          0583*      pop af
040304 C9          0584*      ret
040305             0585*  
040305             0586*  print_s168_a:
040305 F5          0587*      push af
040306 C5          0588*      push bc
040307 E5          0589*      push hl
040308 21 00 00 00 0590*      ld hl,0
04030C 6F          0591*      ld l,a
04030D CD 98 02 04 0592*      call print_s168_hl
040311 E1          0593*      pop hl
040312 C1          0594*      pop bc
040313 F1          0595*      pop af
040314 C9          0596*      ret
040315             0597*  
040315             0598*  ; #### new functions added by Brandon R. Gates ####
040315             0599*  
040315             0600*  ; print the binary representation of the 8-bit value in a
040315             0601*  ; destroys a, hl, bc
040315             0602*  printBin8:
040315 06 08       0603*      ld b,8 ; loop counter for 8 bits
040317 21 32 03 04 0604*      ld hl,@cmd ; set hl to the low byte of the output string
04031B             0605*      ; (which will be the high bit of the value in a)
04031B             0606*  @loop:
04031B 07          0607*      rlca ; put the next highest bit into carry
04031C 38 04       0608*      jr c,@one
04031E 36 30       0609*      ld (hl),'0'
040320 18 02       0610*      jr @next_bit
040322             0611*  @one:
040322 36 31       0612*      ld (hl),'1'
040324             0613*  @next_bit:
040324 23          0614*      inc hl
040325 10 F4       0615*      djnz @loop
040327             0616*  ; print it
040327 21 32 03 04 0617*      ld hl,@cmd
04032B 01 08 00 00 0618*      ld bc,@end-@cmd
04032F 5B DF       0619*      rst.lil $18
040331 C9          0620*      ret
040332             0621*  @cmd: ds 8 ; eight bytes for eight bits
04033A             0622*  @end:
04033A             0623*  
04033A             0624*  ; print the binary representation of the 8-bit value in a
04033A             0625*  ; in reverse order (lsb first)
04033A             0626*  ; destroys a, hl, bc
04033A             0627*  printBin8Rev:
04033A 06 08       0628*      ld b,8 ; loop counter for 8 bits
04033C 21 57 03 04 0629*      ld hl,@cmd ; set hl to the low byte of the output string
040340             0630*      ; (which will be the high bit of the value in a)
040340             0631*  @loop:
040340 0F          0632*      rrca ; put the next lowest bit into carry
040341 38 04       0633*      jr c,@one
040343 36 30       0634*      ld (hl),'0'
040345 18 02       0635*      jr @next_bit
040347             0636*  @one:
040347 36 31       0637*      ld (hl),'1'
040349             0638*  @next_bit:
040349 23          0639*      inc hl
04034A 10 F4       0640*      djnz @loop
04034C             0641*  ; print it
04034C 21 57 03 04 0642*      ld hl,@cmd
040350 01 08 00 00 0643*      ld bc,@end-@cmd
040354 5B DF       0644*      rst.lil $18
040356 C9          0645*      ret
040357             0646*  @cmd: ds 8 ; eight bytes for eight bits
04035F             0647*  @end:
04035F             0648*  
04035F             0649*  ; print registers to screen in hexidecimal format
04035F             0650*  ; inputs: none
04035F             0651*  ; outputs: values of every register printed to screen
04035F             0652*  ;    values of each register in global scratch memory
04035F             0653*  ; destroys: nothing
04035F             0654*  stepRegistersHex:
04035F             0655*  ; store everything in scratch
04035F 22 9F 05 04 0656*      ld (uhl),hl
040363 ED 43 A2 05 0657*      ld (ubc),bc
       04          
040368 ED 53 A5 05 0658*      ld (ude),de
       04          
04036D DD 22 A8 05 0659*      ld (uix),ix
       04          
040372 FD 22 AB 05 0660*      ld (uiy),iy
       04          
040377 F5          0661*      push af ; fml
040378 E1          0662*      pop hl ; thanks, zilog
040379 22 9C 05 04 0663*      ld (uaf),hl
04037D F5          0664*      push af ; dammit
04037E             0665*  
04037E             0666*  ; home the cursor
04037E             0667*      ; call vdu_home_cursor
04037E             0668*  
04037E             0669*  ; print each register
04037E 21 22 05 04 0670*      ld hl,str_afu
040382 CD 77 00 04 0671*      call printString
040386 2A 9C 05 04 0672*      ld hl,(uaf)
04038A CD 97 00 04 0673*      call printHex24
04038E CD 8C 00 04 0674*      call printNewLine
040392             0675*  
040392 21 27 05 04 0676*      ld hl,str_hlu
040396 CD 77 00 04 0677*      call printString
04039A 2A 9F 05 04 0678*      ld hl,(uhl)
04039E CD 97 00 04 0679*      call printHex24
0403A2 CD 8C 00 04 0680*      call printNewLine
0403A6             0681*  
0403A6 21 2C 05 04 0682*      ld hl,str_bcu
0403AA CD 77 00 04 0683*      call printString
0403AE 2A A2 05 04 0684*      ld hl,(ubc)
0403B2 CD 97 00 04 0685*      call printHex24
0403B6 CD 8C 00 04 0686*      call printNewLine
0403BA             0687*  
0403BA 21 31 05 04 0688*      ld hl,str_deu
0403BE CD 77 00 04 0689*      call printString
0403C2 2A A5 05 04 0690*      ld hl,(ude)
0403C6 CD 97 00 04 0691*      call printHex24
0403CA CD 8C 00 04 0692*      call printNewLine
0403CE             0693*  
0403CE 21 36 05 04 0694*      ld hl,str_ixu
0403D2 CD 77 00 04 0695*      call printString
0403D6 2A A8 05 04 0696*      ld hl,(uix)
0403DA CD 97 00 04 0697*      call printHex24
0403DE CD 8C 00 04 0698*      call printNewLine
0403E2             0699*  
0403E2 21 3B 05 04 0700*      ld hl,str_iyu
0403E6 CD 77 00 04 0701*      call printString
0403EA 2A AB 05 04 0702*      ld hl,(uiy)
0403EE CD 97 00 04 0703*      call printHex24
0403F2 CD 8C 00 04 0704*      call printNewLine
0403F6             0705*  
0403F6             0706*      ; call vsync
0403F6             0707*  
0403F6 CD 8C 00 04 0708*      call printNewLine
0403FA             0709*  
0403FA             0710*  ; check for right shift key and quit if pressed
0403FA             0711*      MOSCALL mos_getkbmap
0403FA 3E 1E       0001*M 			LD	A, function
0403FC 5B CF       0002*M 			RST.LIL	08h
0403FE             0712*  @stayhere:
0403FE             0713*  ; 7 RightShift
0403FE DD CB 00 76 0714*      bit 6,(ix+0)
040402 20 02       0715*      jr nz,@RightShift
040404 18 F8       0716*      jr @stayhere
040406             0717*  @RightShift:
040406 DD CB 0E 86 0718*      res 0,(ix+14) ; debounce the key (hopefully)
04040A 3E 80       0719*      ld a,%10000000
04040C             0720*      ; call multiPurposeDelay
04040C             0721*  
04040C             0722*  ; restore everything
04040C 2A 9F 05 04 0723*      ld hl, (uhl)
040410 ED 4B A2 05 0724*      ld bc, (ubc)
       04          
040415 ED 5B A5 05 0725*      ld de, (ude)
       04          
04041A DD 2A A8 05 0726*      ld ix, (uix)
       04          
04041F FD 2A AB 05 0727*      ld iy, (uiy)
       04          
040424 F1          0728*      pop af
040425             0729*  ; all done
040425 C9          0730*      ret
040426             0731*  
040426             0732*  ; print registers to screen in hexidecimal format
040426             0733*  ; inputs: none
040426             0734*  ; outputs: values of every register printed to screen
040426             0735*  ;    values of each register in global scratch memory
040426             0736*  ; destroys: nothing
040426             0737*  dumpRegistersHex:
040426             0738*  ; store everything in scratch
040426 22 9F 05 04 0739*      ld (uhl),hl
04042A ED 43 A2 05 0740*      ld (ubc),bc
       04          
04042F ED 53 A5 05 0741*      ld (ude),de
       04          
040434 DD 22 A8 05 0742*      ld (uix),ix
       04          
040439 FD 22 AB 05 0743*      ld (uiy),iy
       04          
04043E F5          0744*      push af ; fml
04043F E1          0745*      pop hl ; thanks, zilog
040440 22 9C 05 04 0746*      ld (uaf),hl
040444 F5          0747*      push af ; dammit
040445             0748*  
040445             0749*  ; home the cursor
040445             0750*      ; call vdu_home_cursor
040445             0751*      ; call printNewLine
040445             0752*  
040445             0753*  ; print each register
040445 21 22 05 04 0754*      ld hl,str_afu
040449 CD 77 00 04 0755*      call printString
04044D 2A 9C 05 04 0756*      ld hl,(uaf)
040451 CD 97 00 04 0757*      call printHex24
040455             0758*      ; call printNewLine
040455             0759*  
040455 21 27 05 04 0760*      ld hl,str_hlu
040459 CD 77 00 04 0761*      call printString
04045D 2A 9F 05 04 0762*      ld hl,(uhl)
040461 CD 97 00 04 0763*      call printHex24
040465             0764*      ; call printNewLine
040465             0765*  
040465 21 2C 05 04 0766*      ld hl,str_bcu
040469 CD 77 00 04 0767*      call printString
04046D 2A A2 05 04 0768*      ld hl,(ubc)
040471 CD 97 00 04 0769*      call printHex24
040475             0770*      ; call printNewLine
040475             0771*  
040475 21 31 05 04 0772*      ld hl,str_deu
040479 CD 77 00 04 0773*      call printString
04047D 2A A5 05 04 0774*      ld hl,(ude)
040481 CD 97 00 04 0775*      call printHex24
040485             0776*      ; call printNewLine
040485             0777*  
040485 21 36 05 04 0778*      ld hl,str_ixu
040489 CD 77 00 04 0779*      call printString
04048D 2A A8 05 04 0780*      ld hl,(uix)
040491 CD 97 00 04 0781*      call printHex24
040495             0782*      ; call printNewLine
040495             0783*  
040495 21 3B 05 04 0784*      ld hl,str_iyu
040499 CD 77 00 04 0785*      call printString
04049D 2A AB 05 04 0786*      ld hl,(uiy)
0404A1 CD 97 00 04 0787*      call printHex24
0404A5             0788*      ; call printNewLine
0404A5             0789*  
0404A5             0790*      ; call vdu_vblank
0404A5             0791*  
0404A5 CD 8C 00 04 0792*      call printNewLine
0404A9             0793*  ; restore everything
0404A9 2A 9F 05 04 0794*      ld hl, (uhl)
0404AD ED 4B A2 05 0795*      ld bc, (ubc)
       04          
0404B2 ED 5B A5 05 0796*      ld de, (ude)
       04          
0404B7 DD 2A A8 05 0797*      ld ix, (uix)
       04          
0404BC FD 2A AB 05 0798*      ld iy, (uiy)
       04          
0404C1 F1          0799*      pop af
0404C2             0800*  ; all done
0404C2 C9          0801*      ret
0404C3             0802*  
0404C3             0803*  dumpRegistersHexPrime:
0404C3 D9          0804*      exx
0404C4 08          0805*      ex af,af'
0404C5 CD 26 04 04 0806*      call dumpRegistersHex
0404C9 08          0807*      ex af,af'
0404CA D9          0808*      exx
0404CB C9          0809*      ret
0404CC             0810*  
0404CC             0811*  ; additionally dump prime registers
0404CC             0812*  ; inputs: none
0404CC             0813*  ; outputs: values of every register printed to screen
0404CC             0814*  ; destroys: nothing
0404CC             0815*  dumpRegistersHexAll:
0404CC CD 26 04 04 0816*      call dumpRegistersHex
0404D0 08          0817*      ex af,af'
0404D1 D9          0818*      exx
0404D2 CD 26 04 04 0819*      call dumpRegistersHex
0404D6 08          0820*      ex af,af'
0404D7 D9          0821*      exx
0404D8 C9          0822*      ret
0404D9             0823*  
0404D9             0824*  ; print hlu to screen in hexidecimal format
0404D9             0825*  ; inputs: none
0404D9             0826*  ; destroys: nothing
0404D9             0827*  print_hex_hl:
0404D9 F5          0828*      push af
0404DA E5          0829*      push hl
0404DB 21 27 05 04 0830*      ld hl,str_hlu
0404DF CD 77 00 04 0831*      call printString
0404E3 E1          0832*      pop hl
0404E4 E5          0833*      push hl
0404E5 CD 97 00 04 0834*      call printHex24
0404E9 3E 20       0835*      ld a,' '
0404EB 5B D7       0836*      rst.lil 10h
0404ED E1          0837*      pop hl
0404EE F1          0838*      pop af
0404EF C9          0839*      ret
0404F0             0840*  
0404F0             0841*  ; print bcu to screen in hexidecimal format
0404F0             0842*  ; inputs: none
0404F0             0843*  ; destroys: nothing
0404F0             0844*  print_hex_bc:
0404F0 F5          0845*      push af
0404F1 E5          0846*      push hl
0404F2 C5          0847*      push bc
0404F3 21 2C 05 04 0848*      ld hl,str_bcu
0404F7 CD 77 00 04 0849*      call printString
0404FB E1          0850*      pop hl
0404FC E5          0851*      push hl
0404FD CD 97 00 04 0852*      call printHex24
040501 3E 20       0853*      ld a,' '
040503 5B D7       0854*      rst.lil 10h
040505 C1          0855*      pop bc
040506 E1          0856*      pop hl
040507 F1          0857*      pop af
040508 C9          0858*      ret
040509             0859*  
040509             0860*  ; print deu to screen in hexidecimal format
040509             0861*  ; inputs: none
040509             0862*  ; destroys: nothing
040509             0863*  print_hex_de:
040509 F5          0864*      push af
04050A E5          0865*      push hl
04050B D5          0866*      push de
04050C 21 31 05 04 0867*      ld hl,str_deu
040510 CD 77 00 04 0868*      call printString
040514 E1          0869*      pop hl
040515 E5          0870*      push hl
040516 CD 97 00 04 0871*      call printHex24
04051A 3E 20       0872*      ld a,' '
04051C 5B D7       0873*      rst.lil 10h
04051E D1          0874*      pop de
04051F E1          0875*      pop hl
040520 F1          0876*      pop af
040521 C9          0877*      ret
040522             0878*  
040522 20 61 66 3D 0879*  str_afu: db " af=",0
       00          
040527 20 68 6C 3D 0880*  str_hlu: db " hl=",0
       00          
04052C 20 62 63 3D 0881*  str_bcu: db " bc=",0
       00          
040531 20 64 65 3D 0882*  str_deu: db " de=",0
       00          
040536 20 69 78 3D 0883*  str_ixu: db " ix=",0
       00          
04053B 20 69 79 3D 0884*  str_iyu: db " iy=",0
       00          
040540             0885*  
040540             0886*  ; print udeuhl to screen in hexidecimal format
040540             0887*  ; inputs: none
040540             0888*  ; outputs: concatenated hexidecimal udeuhl
040540             0889*  ; destroys: nothing
040540             0890*  dumpUDEUHLHex:
040540             0891*  ; store everything in scratch
040540 22 9F 05 04 0892*      ld (uhl),hl
040544 ED 43 A2 05 0893*      ld (ubc),bc
       04          
040549 ED 53 A5 05 0894*      ld (ude),de
       04          
04054E DD 22 A8 05 0895*      ld (uix),ix
       04          
040553 FD 22 AB 05 0896*      ld (uiy),iy
       04          
040558 F5          0897*      push af
040559             0898*  
040559             0899*  ; print each register
040559             0900*  
040559 21 93 05 04 0901*      ld hl,str_udeuhl
04055D CD 77 00 04 0902*      call printString
040561 2A A5 05 04 0903*      ld hl,(ude)
040565 CD 97 00 04 0904*      call printHex24
040569 3E 2E       0905*      ld a,'.' ; print a dot to separate the values
04056B 5B D7       0906*      rst.lil 10h
04056D 2A 9F 05 04 0907*      ld hl,(uhl)
040571 CD 97 00 04 0908*      call printHex24
040575 CD 8C 00 04 0909*      call printNewLine
040579             0910*  
040579             0911*  ; restore everything
040579 2A 9F 05 04 0912*      ld hl, (uhl)
04057D ED 4B A2 05 0913*      ld bc, (ubc)
       04          
040582 ED 5B A5 05 0914*      ld de, (ude)
       04          
040587 DD 2A A8 05 0915*      ld ix, (uix)
       04          
04058C FD 2A AB 05 0916*      ld iy, (uiy)
       04          
040591 F1          0917*      pop af
040592             0918*  ; all done
040592 C9          0919*      ret
040593             0920*  
040593 75 64 65 2E 0921*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04059C             0922*  
04059C             0923*  ; global scratch memory for registers
04059C 00 00 00    0924*  uaf: dl 0
04059F 00 00 00    0925*  uhl: dl 0
0405A2 00 00 00    0926*  ubc: dl 0
0405A5 00 00 00    0927*  ude: dl 0
0405A8 00 00 00    0928*  uix: dl 0
0405AB 00 00 00    0929*  uiy: dl 0
0405AE 00 00 00    0930*  usp: dl 0
0405B1 00 00 00    0931*  upc: dl 0
0405B4             0932*  
0405B4             0933*  ; inputs: whatever is in the flags register
0405B4             0934*  ; outputs: binary representation of flags
0405B4             0935*  ;          with a header so we know which is what
0405B4             0936*  ; destroys: nothing
0405B4             0937*  ; preserves: everything
0405B4             0938*  dumpFlags:
0405B4             0939*  ; first we curse zilog for not giving direct access to flags
0405B4 F5          0940*      push af ; this is so we can send it back unharmed
0405B5 F5          0941*      push af ; this is so we can pop it to hl
0405B6             0942*  ; store everything in scratch
0405B6 22 9F 05 04 0943*      ld (uhl),hl
0405BA ED 43 A2 05 0944*      ld (ubc),bc
       04          
0405BF ED 53 A5 05 0945*      ld (ude),de
       04          
0405C4 DD 22 A8 05 0946*      ld (uix),ix
       04          
0405C9 FD 22 AB 05 0947*      ld (uiy),iy
       04          
0405CE             0948*  ; next we print the header
0405CE 21 FA 05 04 0949*      ld hl,@header
0405D2 CD 77 00 04 0950*      call printString
0405D6 E1          0951*      pop hl ; flags are now in l
0405D7 7D          0952*      ld a,l ; flags are now in a
0405D8 CD 15 03 04 0953*      call printBin8
0405DC CD 8C 00 04 0954*      call printNewLine
0405E0             0955*  ; restore everything
0405E0 2A 9F 05 04 0956*      ld hl, (uhl)
0405E4 ED 4B A2 05 0957*      ld bc, (ubc)
       04          
0405E9 ED 5B A5 05 0958*      ld de, (ude)
       04          
0405EE DD 2A A8 05 0959*      ld ix, (uix)
       04          
0405F3 FD 2A AB 05 0960*      ld iy, (uiy)
       04          
0405F8 F1          0961*      pop af ; send her home the way she came
0405F9 C9          0962*      ret
0405FA             0963*  ; Bit 7 (S): Sign flag
0405FA             0964*  ; Bit 6 (Z): Zero flag
0405FA             0965*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0405FA             0966*  ; Bit 4 (H): Half Carry flag
0405FA             0967*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0405FA             0968*  ; Bit 2 (PV): Parity/Overflow flag
0405FA             0969*  ; Bit 1 (N): Subtract flag
0405FA             0970*  ; Bit 0 (C): Carry flag
0405FA 53 5A 78 48 0971*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
040605             0972*  
040605             0973*  ; set all the bits in the flag register
040605             0974*  ; more of an academic exercise than anything useful
040605             0975*  ; inputs; none
040605             0976*  ; outputs; a=0,f=255
040605             0977*  ; destroys: flags, hl
040605             0978*  ; preserves: a, because why not
040605             0979*  setAllFlags:
040605 21 FF 00 00 0980*      ld hl,255
040609 67          0981*      ld h,a ; four cycles to preserve a is cheap
04060A E5          0982*      push hl
04060B F1          0983*      pop af
04060C C9          0984*      ret
04060D             0985*  
04060D             0986*  ; reset all the bits in the flag register
04060D             0987*  ; unlike its inverse counterpart, this may actually be useful
04060D             0988*  ; inputs; none
04060D             0989*  ; outputs; a=0,f=0
04060D             0990*  ; destroys: flags, hl
04060D             0991*  ; preserves: a, because why not
04060D             0992*  resetAllFlags:
04060D 21 00 00 00 0993*      ld hl,0
040611 67          0994*      ld h,a ; four cycles to preserve a is cheap
040612 E5          0995*      push hl
040613 F1          0996*      pop af
040614 C9          0997*      ret
040615             0998*  
040615             0999*  ; wait until user presses a key
040615             1000*  ; inputs: none
040615             1001*  ; outputs: ascii code of key pressed in a
040615             1002*  ; destroys: af,ix
040615             1003*  waitKeypress:
040615             1004*      MOSCALL mos_getkey
040615 3E 00       0001*M 			LD	A, function
040617 5B CF       0002*M 			RST.LIL	08h
040619 C9          1005*      ret
04061A             1006*  
04061A             1007*  ; print bytes from an address to the screen in hexidecimal format
04061A             1008*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04061A             1009*  ; outputs: values of each byte printed to screen separated by spaces
04061A             1010*  ; destroys: nothing
04061A             1011*  dumpMemoryHex:
04061A             1012*  ; save registers to the stack
04061A C5          1013*      push bc
04061B E5          1014*      push hl
04061C F5          1015*      push af
04061D             1016*  
04061D             1017*  ; print the address and separator
04061D CD 97 00 04 1018*      call printHex24
040621 3E 3A       1019*      ld a,':'
040623 5B D7       1020*      rst.lil 10h
040625 3E 20       1021*      ld a,' '
040627 5B D7       1022*      rst.lil 10h
040629             1023*  
040629             1024*  ; set b to be our loop counter
040629 F1          1025*      pop af
04062A 47          1026*      ld b,a
04062B E1          1027*      pop hl
04062C E5          1028*      push hl
04062D F5          1029*      push af
04062E             1030*  @loop:
04062E             1031*  ; print the byte
04062E 7E          1032*      ld a,(hl)
04062F CD A5 00 04 1033*      call printHex8
040633             1034*  ; print a space
040633 3E 20       1035*      ld a,' '
040635 5B D7       1036*      rst.lil 10h
040637 23          1037*      inc hl
040638 10 F4       1038*      djnz @loop
04063A CD 8C 00 04 1039*      call printNewLine
04063E             1040*  
04063E             1041*  ; restore everything
04063E F1          1042*      pop af
04063F E1          1043*      pop hl
040640 C1          1044*      pop bc
040641             1045*  
040641             1046*  ; all done
040641 C9          1047*      ret
040642             1048*  
040642             1049*  
040642             1050*  ; print bytes from an address to the screen in binary format
040642             1051*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040642             1052*  ; outputs: values of each byte printed to screen separated by spaces
040642             1053*  ; destroys: nothing
040642             1054*  dumpMemoryBin:
040642             1055*  ; save all registers to the stack
040642 F5          1056*      push af
040643 C5          1057*      push bc
040644 D5          1058*      push de
040645 E5          1059*      push hl
040646 DD E5       1060*      push ix
040648 FD E5       1061*      push iy
04064A             1062*  
04064A             1063*  ; set b to be our loop counter
04064A 47          1064*      ld b,a
04064B             1065*  @loop:
04064B             1066*  ; print the byte
04064B 7E          1067*      ld a,(hl)
04064C E5          1068*      push hl
04064D C5          1069*      push bc
04064E CD 15 03 04 1070*      call printBin8
040652 C1          1071*      pop bc
040653             1072*  ; print a space
040653 3E 20       1073*      ld a,' '
040655 5B D7       1074*      rst.lil 10h
040657 E1          1075*      pop hl
040658 23          1076*      inc hl
040659 10 F0       1077*      djnz @loop
04065B CD 8C 00 04 1078*      call printNewLine
04065F             1079*  
04065F             1080*  ; restore everything
04065F FD E1       1081*      pop iy
040661 DD E1       1082*      pop ix
040663 E1          1083*      pop hl
040664 D1          1084*      pop de
040665 C1          1085*      pop bc
040666 F1          1086*      pop af
040667             1087*  ; all done
040667 C9          1088*      ret
040668             1089*  
040668             1090*  ; print bytes from an address to the screen in binary format
040668             1091*  ; with the bits of each byte in reverse order (lsb first)
040668             1092*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040668             1093*  ; outputs: values of each byte printed to screen separated by spaces
040668             1094*  ; destroys: nothing
040668             1095*  dumpMemoryBinRev:
040668             1096*  ; save all registers to the stack
040668 F5          1097*      push af
040669 C5          1098*      push bc
04066A D5          1099*      push de
04066B E5          1100*      push hl
04066C DD E5       1101*      push ix
04066E FD E5       1102*      push iy
040670             1103*  
040670             1104*  ; set b to be our loop counter
040670 47          1105*      ld b,a
040671             1106*  @loop:
040671             1107*  ; print the byte
040671 7E          1108*      ld a,(hl)
040672 E5          1109*      push hl
040673 C5          1110*      push bc
040674 CD 3A 03 04 1111*      call printBin8Rev
040678 C1          1112*      pop bc
040679             1113*  ; print a space
040679 3E 20       1114*      ld a,' '
04067B 5B D7       1115*      rst.lil 10h
04067D E1          1116*      pop hl
04067E 23          1117*      inc hl
04067F 10 F0       1118*      djnz @loop
040681 CD 8C 00 04 1119*      call printNewLine
040685             1120*  
040685             1121*  ; restore everything
040685 FD E1       1122*      pop iy
040687 DD E1       1123*      pop ix
040689 E1          1124*      pop hl
04068A D1          1125*      pop de
04068B C1          1126*      pop bc
04068C F1          1127*      pop af
04068D             1128*  ; all done
04068D C9          1129*      ret
04068E             0031       include "maths.inc"
04068E             0001*  ; test the sign of HL
04068E             0002*  ; inputs: HL obviously
04068E             0003*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04068E             0004*  ; destroys: flags
04068E             0005*      MACRO sign_hlu
04068E             0006*      add hl,de
04068E             0007*      or a ; clear flags
04068E             0008*      sbc hl,de
04068E             0009*      ENDMACRO
04068E             0010*  
04068E             0011*  
04068E             0012*  ;------------------------------------------------------------------------
04068E             0013*  ; Scratch area for calculations
04068E             0014*  ;------------------------------------------------------------------------
04068E 00 00 00    0015*  scratch1: dw24 0 ;bit manipulation buffer 1
040691 00 00 00    0016*  scratch2: dw24 0 ;bit manipulation buffer 2
040694             0017*  
040694             0018*  ; absolute value of hlu
040694             0019*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040694             0020*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040694             0021*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040694             0022*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040694             0023*  ; destroys: a
040694             0024*  hlu_abs:
040694 19          0025*      add hl,de
040695 B7          0026*      or a
040696 ED 52       0027*      sbc hl,de
040698 FA 9D 06 04 0028*      jp m,@is_neg
04069C C9          0029*      ret ; hlu is positive or zero so we're done
04069D             0030*  @is_neg:
04069D F5          0031*      push af ; otherwise, save current flags for return
04069E CD A4 06 04 0032*      call neg_hlu ; negate hlu
0406A2 F1          0033*      pop af ; get back flags
0406A3 C9          0034*      ret
0406A4             0035*  
0406A4             0036*  ; flip the sign of hlu
0406A4             0037*  ; inputs: hlu
0406A4             0038*  ; returns: 0-hlu, flags set appropriately for the result:
0406A4             0039*  ;         s1,z0,pv0,n1,c1 if result is negative
0406A4             0040*  ;         s0,z1,pv0,n1,c0 if result is zero
0406A4             0041*  ;         s0,z0,pv0,n1,c1 if result is positive
0406A4             0042*  ; destroys a
0406A4             0043*  neg_hlu:
0406A4 D5          0044*      push de ; save de
0406A5 EB          0045*      ex de,hl ; put hl into de
0406A6 21 00 00 00 0046*      ld hl,0 ; clear hl
0406AA AF          0047*      xor a ; clear carry
0406AB ED 52       0048*      sbc hl,de ; 0-hlu = -hlu
0406AD D1          0049*      pop de ; get de back
0406AE C9          0050*      ret ; easy peasy
0406AF             0051*  
0406AF             0052*  ;------------------------------------------------------------------------
0406AF             0053*  ; divide hlu by 2, inspired by above
0406AF             0054*  ;------------------------------------------------------------------------
0406AF             0055*  hlu_div2:
0406AF 22 8E 06 04 0056*      ld (scratch1),hl
0406B3 21 90 06 04 0057*      ld hl,scratch1+2
0406B7 CB 1E       0058*      rr (hl)
0406B9 2B          0059*      dec hl
0406BA CB 1E       0060*      rr (hl)
0406BC 2B          0061*      dec hl
0406BD CB 1E       0062*      rr (hl)
0406BF 23          0063*      inc hl
0406C0 23          0064*      inc hl
0406C1 2A 8E 06 04 0065*      ld hl,(scratch1)
0406C5 C9          0066*      ret
0406C6             0067*  
0406C6             0068*  ; this is my little hack to divide by 16
0406C6             0069*  hlu_div16:
0406C6 AF          0070*      xor a
0406C7 29          0071*      add hl,hl
0406C8 17          0072*      rla
0406C9 29          0073*      add hl,hl
0406CA 17          0074*      rla
0406CB 29          0075*      add hl,hl
0406CC 17          0076*      rla
0406CD 29          0077*      add hl,hl
0406CE 17          0078*      rla
0406CF 22 DC 06 04 0079*      ld (@scratch),hl
0406D3 32 DF 06 04 0080*      ld (@scratch+3),a
0406D7 2A DD 06 04 0081*      ld hl,(@scratch+1)
0406DB C9          0082*      ret
0406DC             0083*  @scratch: ds 4
0406E0             0084*  
0406E0             0085*  ; hlu signed division by 256
0406E0             0086*  ; returns: hlu / 256
0406E0             0087*  ; destroys: af
0406E0             0088*  hlu_sdiv256:
0406E0 AF          0089*      xor a ; assume hl is positive
0406E1 22 F7 06 04 0090*      ld (@buffer),hl
0406E5             0091*      sign_hlu
0406E5 19          0001*M     add hl,de
0406E6 B7          0002*M     or a ; clear flags
0406E7 ED 52       0003*M     sbc hl,de
0406E9 F2 EE 06 04 0092*      jp p,@hl_pos
0406ED 3D          0093*      dec a
0406EE             0094*  @hl_pos:
0406EE 32 FA 06 04 0095*      ld (@buffer+3),a
0406F2 2A F8 06 04 0096*      ld hl,(@buffer+1)
0406F6 C9          0097*      ret
0406F7             0098*  @buffer: ds 4
0406FB             0099*  
0406FB             0100*  ; hlu 1 byte right shift, unsigned
0406FB             0101*  ; returns: hlu / 256, fractional portion in a
0406FB             0102*  ; destroys: af
0406FB             0103*  hlu_udiv256:
0406FB AF          0104*      xor a
0406FC 32 0D 07 04 0105*      ld (@buffer+3),a
040700 7D          0106*      ld a,l ; save the fractional portion
040701 22 0A 07 04 0107*      ld (@buffer),hl
040705 2A 0B 07 04 0108*      ld hl,(@buffer+1)
040709 C9          0109*      ret
04070A             0110*  @buffer: ds 4
04070E             0111*  
04070E             0112*      MACRO hlu_mul256
04070E             0113*      add hl,hl ; * 2
04070E             0114*      add hl,hl ; * 4
04070E             0115*      add hl,hl ; * 8
04070E             0116*      add hl,hl ; * 16
04070E             0117*      add hl,hl ; * 32
04070E             0118*      add hl,hl ; * 64
04070E             0119*      add hl,hl ; * 128
04070E             0120*      add hl,hl ; * 256
04070E             0121*      ENDMACRO
04070E             0122*  
04070E             0123*  ; compute the modulo of hlu by deu
04070E             0124*  ; outputs: hlu = hlu % deu
04070E             0125*  ; destroys: f, hl
04070E             0126*  hlu_mod:
04070E B7          0127*      or a ; clear carry
04070F             0128*  @loop:
04070F ED 52       0129*      sbc hl,de
040711 DA 19 07 04 0130*      jp c, @end
040715 C3 0F 07 04 0131*      jp @loop
040719             0132*  @end:
040719 19          0133*      add hl,de
04071A C9          0134*      ret
04071B             0135*  
04071B             0136*  
04071B 00 00 00 00 0137*  add_bcd_arg1: db #00,#00,#00,#00
04071F 00 00 00 00 0138*  add_bcd_arg2: db #00,#00,#00,#00
040723             0139*  
040723             0140*  ; set bcd values in a scratch memory address from registers bcde
040723             0141*  ; input: hl; scratch address,bcde; 8-place bcd number
040723             0142*  ; destroys ; hl
040723             0143*  set_bcd:
040723 73          0144*      ld (hl),e
040724 23          0145*      inc hl
040725 72          0146*      ld (hl),d
040726 23          0147*      inc hl
040727 71          0148*      ld (hl),c
040728 23          0149*      inc hl
040729 70          0150*      ld (hl),b
04072A C9          0151*      ret
04072B             0152*  
04072B             0153*  ; load bcd values from a scratch memory address to bcde
04072B             0154*  ; input: hl; scratch address
04072B             0155*  ; output: bcde; 8-place bcd number
04072B             0156*  ; destroys: hl
04072B             0157*  get_bcd:
04072B 5E          0158*      ld e,(hl)
04072C 23          0159*      inc hl
04072D 56          0160*      ld d,(hl)
04072E 23          0161*      inc hl
04072F 4E          0162*      ld c,(hl)
040730 23          0163*      inc hl
040731 46          0164*      ld b,(hl)
040732 C9          0165*      ret
040733             0166*  
040733             0167*  ; BCD addition
040733             0168*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040733             0169*  ;       a is the number of bytes holding each number (number of places/2)
040733             0170*  ; outputs: (hl) + (de) --> (hl)
040733             0171*  ; destroys: a,b,de,hl
040733             0172*  add_bcd:
040733 47          0173*      ld b,a ; loop counter
040734 AF          0174*      xor a ; reset a, clear carry flag
040735             0175*  adcec:
040735 1A          0176*      ld a,(de) ; addend to acc
040736 8E          0177*      adc a,(hl) ; add (hl) to acc
040737 27          0178*      daa ; adjust result to bcd
040738 77          0179*      ld (hl),a ; store result
040739 23          0180*      inc hl ; advance memory pointers
04073A 13          0181*      inc de
04073B 10 F8       0182*      djnz adcec ; loop until b == 0
04073D C9          0183*      ret
04073E             0184*  
04073E             0185*  ; BCD subtraction
04073E             0186*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04073E             0187*  ;       a is the number of bytes holding each number (number of places/2)
04073E             0188*  ; outputs: (hl) - (de) --> (hl)
04073E             0189*  ; destroys: a,b,de,hl
04073E             0190*  sub_bcd:
04073E 47          0191*      ld b,a ; loop counter
04073F AF          0192*      xor a ; reset a,clear carry flag
040740             0193*  subdec:
040740 1A          0194*      ld a,(de) ; subtrahend to acc
040741 9E          0195*      sbc a,(hl) ; subtract (hl) from acc
040742 27          0196*      daa ; adjust result to bcd
040743 77          0197*      ld (hl),a ; store result
040744 23          0198*      inc hl ; advance memory pointers
040745 13          0199*      inc de
040746 10 F8       0200*      djnz subdec ; loop until b == 0
040748 C9          0201*      ret
040749             0202*  
040749             0203*  ; http://www.z80.info/pseudo-random.txt
040749             0204*  rand_8:
040749 C5          0205*      push bc
04074A 3A 5D 07 04 0206*      ld a,(r_seed)
04074E 4F          0207*      ld c,a
04074F             0208*  
04074F 0F          0209*      rrca ; multiply by 32
040750 0F          0210*      rrca
040751 0F          0211*      rrca
040752 EE 1F       0212*      xor 0x1f
040754             0213*  
040754 81          0214*      add a,c
040755 DE FF       0215*      sbc a,255 ; carry
040757             0216*  
040757 32 5D 07 04 0217*      ld (r_seed),a
04075B C1          0218*      pop bc
04075C C9          0219*      ret
04075D 50          0220*  r_seed: defb $50
04075E             0221*  
04075E             0222*  ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
04075E             0223*  prng24:
04075E             0224*  ;;Expects ADL mode.
04075E             0225*  ;;Output: HL
04075E             0226*  ;;50cc
04075E             0227*  ;;33 bytes
04075E             0228*  ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
04075E ED 5B 7F 07 0229*      ld de,(seed1)
       04          
040763 B7          0230*      or a
040764 ED 62       0231*      sbc hl,hl
040766 19          0232*      add hl,de
040767 29          0233*      add hl,hl
040768 29          0234*      add hl,hl
040769 2C          0235*      inc l
04076A 19          0236*      add hl,de
04076B 22 7F 07 04 0237*      ld (seed1),hl
04076F 2A 82 07 04 0238*      ld hl,(seed2)
040773 29          0239*      add hl,hl
040774 9F          0240*      sbc a,a
040775 E6 1B       0241*      and %00011011
040777 AD          0242*      xor l
040778 6F          0243*      ld l,a
040779 22 82 07 04 0244*      ld (seed2),hl
04077D 19          0245*      add hl,de
04077E C9          0246*      ret
04077F 00 00 00    0247*  seed1: dl 0
040782 00 00 00    0248*  seed2: dl 0
040785             0032       include "files.inc"
040785             0001*  ; load to onboard 8k sram
040785             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
040785             0033       include "fixed168.inc"
040785             0001*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040785             0002*  ; uses EZ80 MLT instruction for speed
040785             0003*  ; operation: UHL * A --> UHL
040785             0004*  ; destroys: AF, HL
040785             0005*  smul24x8:
040785             0006*  ; make hl positive and store sign flag
040785 CD 94 06 04 0007*      call hlu_abs
040789 F5          0008*      push af
04078A             0009*  ; do the division
04078A CD 95 07 04 0010*      call mul24x8 ; hl = product
04078E             0011*  ; adjust sign of result
04078E F1          0012*      pop af ; sign de
04078F F0          0013*      ret p ; hl was positive, nothing to do
040790 CD A4 06 04 0014*      call neg_hlu ; result is negative
040794 C9          0015*      ret
040795             0016*  
040795             0017*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040795             0018*  ; uses EZ80 MLT instruction for speed
040795             0019*  ; operation: UHL * A --> AUHL
040795             0020*  ; destroys: AF, HL
040795             0021*  mul24x8:
040795 D5          0022*      push de ; preserve de
040796             0023*  ; low byte
040796 5D          0024*      ld e,l
040797 57          0025*      ld d,a
040798 ED 5C       0026*      mlt de
04079A 6B          0027*      ld l,e ; product low byte
04079B 08          0028*      ex af,af' ; save multiplier
04079C 7A          0029*      ld a,d ; carry
04079D 08          0030*      ex af,af' ; save carry, restore multiplier
04079E             0031*  ; high byte
04079E 5C          0032*      ld e,h
04079F 57          0033*      ld d,a
0407A0 ED 5C       0034*      mlt de
0407A2 08          0035*      ex af,af' ; save multiplier, restore carry
0407A3 83          0036*      add a,e ; add carry
0407A4 67          0037*      ld h,a ; product middle byte
0407A5 7A          0038*      ld a,d ; carry
0407A6 08          0039*      ex af,af' ; save carry, restore multiplier
0407A7             0040*  ; upper byte
0407A7 22 C2 07 04 0041*      ld (@scratch),hl ; 7 cycles
0407AB 5F          0042*      ld e,a
0407AC 3A C4 07 04 0043*      ld a,(@scratch+2)
0407B0 57          0044*      ld d,a
0407B1 ED 5C       0045*      mlt de
0407B3 08          0046*      ex af,af' ; restore carry
0407B4 8B          0047*      adc a,e ; add carry
0407B5 32 C4 07 04 0048*      ld (@scratch+2),a ; 5 cycles
0407B9 2A C2 07 04 0049*      ld hl,(@scratch) ; 7 cycles
0407BD             0050*  ; highest byte
0407BD 3E 00       0051*      ld a,0 ; preserve carry flag
0407BF 8A          0052*      adc a,d ; product highest byte
0407C0 D1          0053*      pop de ; restore de
0407C1 C9          0054*      ret
0407C2             0055*  @scratch: ds 3
0407C5             0056*  
0407C5 00 00 00 00 0057*  mul24out: blkb 6,0
       00 00       
0407CB             0058*  
0407CB             0059*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0407CB             0060*  ; operation: UHL * UDE --> mul24out
0407CB             0061*  mul24:
0407CB DD E5       0062*      push ix ; preserve
0407CD             0063*  ; point to output buffer and clear it
0407CD DD 21 C5 07 0064*      ld ix,mul24out
       04          
0407D2 C5          0065*      push bc
0407D3 01 00 00 00 0066*      ld bc,0
0407D7 DD 0F 00    0067*      ld (ix),bc
0407DA DD 0F 03    0068*      ld (ix+3),bc
0407DD C1          0069*      pop bc
0407DE             0070*  ; STEP 1: UHL * E
0407DE 7B          0071*      ld a,e
0407DF E5          0072*      push hl
0407E0 CD 95 07 04 0073*      call mul24x8
0407E4 DD 2F 00    0074*      ld (ix+0),hl
0407E7 DD 77 03    0075*      ld (ix+3),a
0407EA             0076*  ; STEP 2: UHL * D
0407EA E1          0077*      pop hl
0407EB E5          0078*      push hl
0407EC 7A          0079*      ld a,d
0407ED CD 95 07 04 0080*      call mul24x8
0407F1 CD 0A 08 04 0081*      call @accumulate
0407F5             0082*  ; STEP 3: UHL * DEU
0407F5 E1          0083*      pop hl
0407F6 ED 53 3A 08 0084*      ld (@de),de
       04          
0407FB 3A 3C 08 04 0085*      ld a,(@de+2)
0407FF CD 95 07 04 0086*      call mul24x8
040803 CD 0A 08 04 0087*      call @accumulate
040807             0088*  ; all done
040807 DD E1       0089*      pop ix ; restore
040809 C9          0090*      ret
04080A             0091*  @accumulate:
04080A DD 23       0092*      inc ix
04080C             0093*  ; highest byte of product to carry
04080C DD 77 03    0094*      ld (ix+3),a
04080F             0095*  ; low byte of product
04080F 7D          0096*      ld a,l
040810 DD 86 00    0097*      add a,(ix+0)
040813 DD 77 00    0098*      ld (ix+0),a
040816             0099*  ; high byte of product
040816 7C          0100*      ld a,h
040817 DD 8E 01    0101*      adc a,(ix+1)
04081A DD 77 01    0102*      ld (ix+1),a
04081D             0103*  ; uppper byte of product
04081D 22 37 08 04 0104*      ld (@hl),hl
040821 3A 39 08 04 0105*      ld a,(@hl+2)
040825 DD 8E 02    0106*      adc a,(ix+2)
040828 DD 77 02    0107*      ld (ix+2),a
04082B             0108*  ; carry
04082B 3E 00       0109*      ld a,0 ; preserve flags
04082D DD 8E 03    0110*      adc a,(ix+3)
040830 DD 77 03    0111*      ld (ix+3),a
040833 C9          0112*      ret
040834             0113*  
040834 00 00 00    0114*  @ix: dl 0
040837 00 00 00    0115*  @hl: dl 0
04083A 00 00 00    0116*  @de: dl 0
04083D             0117*  
04083D             0118*  ; UHL * UDE --> UHL (unsigned)
04083D             0119*  umul24:
04083D CD CB 07 04 0120*      call mul24
040841 2A C5 07 04 0121*      ld hl,(mul24out)
040845 C9          0122*      ret
040846             0123*  
040846             0124*  ; UH.L = UH.L*UD.E (unsigned)
040846             0125*  umul168:
040846 CD CB 07 04 0126*      call mul24
04084A 2A C6 07 04 0127*      ld hl,(mul24out+1)
04084E C9          0128*      ret
04084F             0129*  
04084F             0130*  ; UH.L * UD.E --> UH.L (signed)
04084F             0131*  smul168:
04084F             0132*  ; make everything positive and store sign flags
04084F CD 94 06 04 0133*      call hlu_abs
040853 F5          0134*      push af
040854 EB          0135*      ex de,hl
040855 CD 94 06 04 0136*      call hlu_abs
040859 EB          0137*      ex de,hl
04085A F5          0138*      push af
04085B             0139*  ; do the division
04085B CD 46 08 04 0140*      call umul168 ; hl = product
04085F             0141*  ; adjust sign of result
04085F F1          0142*      pop af ; sign de
040860 FA 6B 08 04 0143*      jp m,@de_neg
040864 F1          0144*      pop af ; sign hl
040865 F0          0145*      ret p ; both positive, nothing to do
040866             0146*  @hl_neg:
040866 CD A4 06 04 0147*      call neg_hlu ; de pos, hl neg, result is negative
04086A C9          0148*      ret
04086B             0149*  @de_neg:
04086B F1          0150*      pop af
04086C F8          0151*      ret m ; both negative, nothing to do
04086D CD A4 06 04 0152*      call neg_hlu ; result is negative
040871 C9          0153*      ret
040872             0154*  
040872             0155*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
040872             0156*  ; perform unsigned division of 16.8 fixed place values
040872             0157*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
040872             0158*  udiv168:
040872             0159*  ; back up divisor
040872 ED 53 A9 08 0160*      ld (@ude),de
       04          
040877             0161*  ; get the 16-bit integer part of the quotient
040877 CD DA 08 04 0162*      call udiv24 ; de = quotient, hl = remainder
04087B             0163*  ; load quotient to upper three bytes of output
04087B ED 53 B0 08 0164*      ld (div168_out+1),de
       04          
040880             0165*  @div256:
040880             0166*  ; multiply remainder by 256
040880             0167*      hlu_mul256
040880 29          0001*M     add hl,hl ; * 2
040881 29          0002*M     add hl,hl ; * 4
040882 29          0003*M     add hl,hl ; * 8
040883 29          0004*M     add hl,hl ; * 16
040884 29          0005*M     add hl,hl ; * 32
040885 29          0006*M     add hl,hl ; * 64
040886 29          0007*M     add hl,hl ; * 128
040887 29          0008*M     add hl,hl ; * 256
040888             0168*  ; skip fractional computation if remainder is zero
040888             0169*      sign_hlu
040888 19          0001*M     add hl,de
040889 B7          0002*M     or a ; clear flags
04088A ED 52       0003*M     sbc hl,de
04088C 20 03       0170*      jr nz,@div_frac
04088E AF          0171*      xor a
04088F 18 0A       0172*      jr @write_frac
040891             0173*  ; now divide the shifted remainder by the divisor
040891             0174*  @div_frac:
040891 ED 5B A9 08 0175*      ld de,(@ude) ; get back divisor
       04          
040896 CD DA 08 04 0176*      call udiv24 ; de = quotient, hl = remainder
04089A             0177*  ; load low byte of quotient to low byte of output
04089A 7B          0178*      ld a,e
04089B             0179*  @write_frac:
04089B 32 AF 08 04 0180*      ld (div168_out),a
04089F             0181*  ; load de with return value
04089F ED 5B AF 08 0182*      ld de,(div168_out)
       04          
0408A4             0183*  ; load a with any overflow
0408A4 3A B2 08 04 0184*      ld a,(div168_out+3)
0408A8 C9          0185*      ret ; ud.e is the 16.8 result
0408A9             0186*  @ude: ds 6
0408AF             0187*  div168_out: ds 4 ; the extra byte is for overflow
0408B3             0188*  
0408B3             0189*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0408B3             0190*  ; perform signed division of 16.8 fixed place values
0408B3             0191*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0408B3             0192*  sdiv168:
0408B3             0193*  ; make everything positive and store sign flags
0408B3 CD 94 06 04 0194*      call hlu_abs
0408B7 F5          0195*      push af
0408B8 EB          0196*      ex de,hl
0408B9 CD 94 06 04 0197*      call hlu_abs
0408BD EB          0198*      ex de,hl
0408BE F5          0199*      push af
0408BF             0200*  ; do the division
0408BF CD 72 08 04 0201*      call udiv168 ; de = quotient, hl = remainder
0408C3             0202*  ; adjust sign of result
0408C3 F1          0203*      pop af ; sign de
0408C4 FA D1 08 04 0204*      jp m,@de_neg
0408C8 F1          0205*      pop af ; sign hl
0408C9 F0          0206*      ret p ; both positive, nothing to do
0408CA             0207*  @hl_neg:
0408CA EB          0208*      ex de,hl ; hl = quotient, de = remainder
0408CB CD A4 06 04 0209*      call neg_hlu ; de pos, hl neg, result is negative
0408CF EB          0210*      ex de,hl ; de = negated quotient, hl = remainder
0408D0 C9          0211*      ret
0408D1             0212*  @de_neg:
0408D1 F1          0213*      pop af
0408D2 F8          0214*      ret m ; both negative, nothing to do
0408D3 EB          0215*      ex de,hl ; hl = quotient, de = remainder
0408D4 CD A4 06 04 0216*      call neg_hlu ; result is negative
0408D8 EB          0217*      ex de,hl ; de = negated quotient, hl = remainder
0408D9 C9          0218*      ret
0408DA             0219*  
0408DA             0220*  ;------------------------------------------------------------------------
0408DA             0221*  ;  arith24.asm
0408DA             0222*  ;  24-bit ez80 arithmetic routines
0408DA             0223*  ;  Copyright (c) Shawn Sijnstra 2024
0408DA             0224*  ;  MIT license
0408DA             0225*  ;
0408DA             0226*  ;  This library was created as a tool to help make ez80
0408DA             0227*  ;  24-bit native assembly routines for simple mathematical problems
0408DA             0228*  ;  more widely available.
0408DA             0229*  ;
0408DA             0230*  ;------------------------------------------------------------------------
0408DA             0231*  ;
0408DA             0232*  ;------------------------------------------------------------------------
0408DA             0233*  ; udiv24
0408DA             0234*  ; Unsigned 24-bit division
0408DA             0235*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0408DA             0236*  ;
0408DA             0237*  ; Uses AF BC DE HL
0408DA             0238*  ; Uses Restoring Division algorithm
0408DA             0239*  ;------------------------------------------------------------------------
0408DA             0240*  
0408DA             0241*  udiv24:
0408DA E5          0242*      push hl
0408DB C1          0243*      pop bc ;move dividend to BCU
0408DC 21 00 00 00 0244*      ld hl,0 ;result
0408E0 A7          0245*      and a
0408E1 ED 52       0246*      sbc hl,de ;test for div by 0
0408E3 C8          0247*      ret z ;it's zero, carry flag is clear
0408E4 19          0248*      add hl,de ;HL is 0 again
0408E5 3E 18       0249*      ld a,24 ;number of loops through.
0408E7             0250*  udiv1:
0408E7 C5          0251*      push bc ;complicated way of doing this because of lack of access to top bits
0408E8 E3          0252*      ex (sp),hl
0408E9 37          0253*      scf
0408EA ED 6A       0254*      adc hl,hl
0408EC E3          0255*      ex (sp),hl
0408ED C1          0256*      pop bc ;we now have bc = (bc * 2) + 1
0408EE             0257*  
0408EE ED 6A       0258*      adc hl,hl
0408F0 A7          0259*      and a ;is this the bug
0408F1 ED 52       0260*      sbc hl,de
0408F3 30 02       0261*      jr nc,udiv2
0408F5 19          0262*      add hl,de
0408F6             0263*  ;	dec	c
0408F6 0B          0264*      dec bc
0408F7             0265*  udiv2:
0408F7 3D          0266*      dec a
0408F8 20 ED       0267*      jr nz,udiv1
0408FA 37          0268*      scf ;flag used for div0 error
0408FB C5          0269*      push bc
0408FC D1          0270*      pop de ;remainder
0408FD C9          0271*      ret
0408FE             0272*  
0408FE             0273*  ;------------------------------------------------------------------------
0408FE             0274*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
0408FE             0275*  ;------------------------------------------------------------------------
0408FE             0276*  
0408FE             0277*  
0408FE             0278*      ; include "trig24fast.inc"
0408FE             0279*  
0408FE             0280*  
0408FE             0281*  ; convert signed angles from a 360 to 256 degree circle
0408FE             0282*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0408FE             0283*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0408FE             0284*  ; destroys: TODO
0408FE             0285*  deg_360_to_256:
0408FE D5          0286*      push de ; preserve de
0408FF             0287*  ; make angle positive and store sign flag
0408FF CD 94 06 04 0288*      call hlu_abs
040903 F5          0289*      push af
040904             0290*  ; multiply by coversion factor of 256/360
040904 11 B6 00 00 0291*      ld de,0x0000B6 ; 0.711
040908 CD 46 08 04 0292*      call umul168 ; uh.l = uh.l * 0.711
04090C             0293*  ; restore sign flag and adjust output accordingly
04090C F1          0294*      pop af
04090D F2 15 09 04 0295*      jp p,@pos ; positive number
040911 CD A4 06 04 0296*      call neg_hlu
040915             0297*  @pos:
040915             0298*  ; restore de and return uh.l as the result
040915 D1          0299*      pop de
040916 C9          0300*      ret
040917             0301*  
040917             0302*  ; convert signed angles from a 256 to 360 degree circle
040917             0303*  ; inputs: uh.l is the angle256 in 16.8 fixed format
040917             0304*  ; outputs: uh.l is the angle360 in 16.8 fixed format
040917             0305*  ; destroys: TODO
040917             0306*  deg_256_to_360:
040917 D5          0307*      push de ; preserve de
040918             0308*  ; make angle positive and store sign flag
040918 CD 94 06 04 0309*      call hlu_abs
04091C F5          0310*      push af
04091D             0311*  ; multiply by coversion factor of 360/256
04091D 11 68 01 00 0312*      ld de,0x000168 ; 1.406
040921 CD 46 08 04 0313*      call umul168 ; uh.l = uh.l * 1.406
040925             0314*  ; restore sign flag and adjust output accordingly
040925 F1          0315*      pop af
040926 F2 2E 09 04 0316*      jp p,@pos ; positive number
04092A CD A4 06 04 0317*      call neg_hlu
04092E             0318*  @pos:
04092E             0319*  ; restore de and return uh.l as the result
04092E D1          0320*      pop de
04092F C9          0321*      ret
040930             0322*  
040930             0323*  ; fixed 16.8 routine
040930             0324*  ; cos(uh.l) --> uh.l
040930             0325*  ; destroys: f, hl
040930             0326*  cos168:
040930 D5          0327*      push de ; preserve de
040931             0328*  ; for cos we simply increment the angle by 90 degrees
040931             0329*  ; or 0x004000 in 16.8 degrees256
040931             0330*  ; which makes it a sin problem
040931 11 00 40 00 0331*      ld de,0x004000
040935 19          0332*      add hl,de ; modulo 256 happens below
040936 D1          0333*      pop de ; restore de
040937             0334*  ; fall through to sin168
040937             0335*  
040937             0336*  ; ---------------------
040937             0337*  ; fixed 16.8 routine
040937             0338*  ; sin(uh.l) --> uh.l
040937             0339*  ; destroys: f, hl
040937             0340*  sin168:
040937 D5          0341*      push de
040938             0342*  ; handle negative angles appropriately
040938 CD 94 06 04 0343*      call hlu_abs
04093C F2 45 09 04 0344*      jp p,@F
040940 11 00 00 FF 0345*      ld de,-256*256
040944 19          0346*      add hl,de
040945             0347*  @@:
040945 2E 03       0348*      ld l,3 ; multiply by 3 to get our lookup index
040947 ED 6C       0349*      mlt hl
040949 11 94 0B 04 0350*      ld de,sin_lut_168 ; grab the lut address
04094D 19          0351*      add hl,de ; bump hl by the index
04094E ED 27       0352*      ld hl,(hl) ; don't try this on a z80!
040950 D1          0353*      pop de
040951 C9          0354*      ret
040952             0355*  
040952             0356*  ; 16.8 fixed inputs / outputs
040952             0357*  ; takes: uh.l as angle in degrees 256
040952             0358*  ;        ud.e as radius
040952             0359*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
040952             0360*  ;        displacements from origin (0,0)
040952             0361*  ; destroys: everything except indexes
040952             0362*  polar_to_cartesian:
040952             0363*  ; back up input parameters
040952 22 81 09 04 0364*      ld (@angle), hl
040956 ED 53 84 09 0365*      ld (@radius), de
       04          
04095B             0366*  ; compute dx = sin(uh.l) * ud.e
04095B CD 37 09 04 0367*      call sin168 ; uh.l = sin(uh.l)
04095F ED 5B 84 09 0368*      ld de,(@radius)
       04          
040964 CD 4F 08 04 0369*      call smul168 ; uh.l = dx
040968 E5          0370*      push hl
040969             0371*  ; compute dy = -cos(uh.l) * ud.e
040969 2A 81 09 04 0372*      ld hl,(@angle)
04096D CD 30 09 04 0373*      call cos168 ; uh.l = cos(uh.l)
040971 ED 5B 84 09 0374*      ld de,(@radius)
       04          
040976 CD 4F 08 04 0375*      call smul168 ; uh.l = dy
04097A CD A4 06 04 0376*      call neg_hlu ; invert dy for screen coords convention
04097E EB          0377*      ex de,hl ; de = dy for output
04097F C1          0378*      pop bc ; bc = dx for output
040980             0379*  ; and out
040980 C9          0380*      ret
040981             0381*  @angle: ds 3
040984             0382*  @radius: ds 3
040987             0383*  
040987             0384*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040987             0385*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040987             0386*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040987             0387*  ;         also populates scratch locations dx168 and dy168
040987             0388*  ; destroys: a,hl,bc,de
040987             0389*  dxy168:
040987             0390*  ; compute dx = x1-x0
040987 AF          0391*      xor a ; clear carry
040988 DD E5       0392*      push ix ; move ix to hl via the stack
04098A E1          0393*      pop hl ; hl = x1
04098B ED 42       0394*      sbc hl,bc ; hl = dx
04098D 22 A2 09 04 0395*      ld (dx168),hl ; dx to scratch
040991             0396*  ; compute dy = y1-y0
040991 AF          0397*      xor a ; clear carry
040992 FD E5       0398*      push iy ; move iy to hl via the stack
040994 E1          0399*      pop hl ; hl = y1
040995 ED 52       0400*      sbc hl,de ; hl = dy
040997 22 A8 09 04 0401*      ld (dy168),hl ; dy to scratch
04099B             0402*  ; populate output registers and return
04099B EB          0403*      ex de,hl ; ud.e = dy
04099C ED 4B A2 09 0404*      ld bc,(dx168) ; ub.c = dx
       04          
0409A1 C9          0405*      ret
0409A2 00 00 00 00 0406*  dx168: blkb 6,0
       00 00       
0409A8 00 00 00 00 0407*  dy168: blkb 6,0
       00 00       
0409AE             0408*  
0409AE             0409*  ; compute the euclidian distance between two cartesian coordinates
0409AE             0410*  ; using the formula d = sqrt(dx^2+dy^2)
0409AE             0411*  ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
0409AE             0412*  ; output; uh.l is the 16.8 fixed format distance
0409AE             0413*  ;         also populates scratch locations dx168 and dy168
0409AE             0414*  ; destroys: a,hl,bc,de
0409AE             0415*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0409AE             0416*  ;       thus the result will always be an integer, albeit in 16.8 format
0409AE             0417*  distance168:
0409AE             0418*  ; compute dy^2
0409AE 2A A8 09 04 0419*      ld hl,(dy168)
0409B2 CD 94 06 04 0420*      call hlu_abs
0409B6 CD FB 06 04 0421*      call hlu_udiv256 ; make integer to avoid overflow
0409BA E5          0422*      push hl
0409BB D1          0423*      pop de
0409BC CD 3D 08 04 0424*      call umul24 ; hl = dy^2
0409C0 E5          0425*      push hl ; save dy^2
0409C1             0426*  ; compute dx^2
0409C1 2A A2 09 04 0427*      ld hl,(dx168)
0409C5 CD 94 06 04 0428*      call hlu_abs
0409C9 CD FB 06 04 0429*      call hlu_udiv256 ; make integer to avoid overflow
0409CD E5          0430*      push hl
0409CE D1          0431*      pop de
0409CF CD 3D 08 04 0432*      call umul24 ; hl = dx^2
0409D3             0433*  ; add dx^2 and dy^2
0409D3 D1          0434*      pop de ; de = dy^2 (was hl)
0409D4 19          0435*      add hl,de ; hl = dx^2 + dy^2
0409D5             0436*  ; compute the square root
0409D5 CD AE 0A 04 0437*      call sqrt24 ; de = sqrt(dx^2 + dy^2)
0409D9 EB          0438*      ex de,hl ; hl = distance
0409DA             0439*      hlu_mul256 ; convert back to 16.8 fixed
0409DA 29          0001*M     add hl,hl ; * 2
0409DB 29          0002*M     add hl,hl ; * 4
0409DC 29          0003*M     add hl,hl ; * 8
0409DD 29          0004*M     add hl,hl ; * 16
0409DE 29          0005*M     add hl,hl ; * 32
0409DF 29          0006*M     add hl,hl ; * 64
0409E0 29          0007*M     add hl,hl ; * 128
0409E1 29          0008*M     add hl,hl ; * 256
0409E2 C9          0440*      ret
0409E3             0441*  
0409E3             0442*  ; atan2_(ub.c,ud.e) --> uh.l
0409E3             0443*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0409E3             0444*  ;   whether inputs are integers or fractional doesn't matter
0409E3             0445*  ;   so long as the sign bit of the upper byte is correct
0409E3             0446*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0409E3             0447*  ; angles are COMPASS HEADINGS based on
0409E3             0448*  ; screen coordinate conventions,where the y axis is flipped
0409E3             0449*  ; #E0 224      0       32 #20
0409E3             0450*  ;        -x,-y | +x,-y
0409E3             0451*  ; #C0 192------+------ 64 #40
0409E3             0452*  ;        -x,+y | +x,+y
0409E3             0453*  ; #A0 160   128 #80   96 #60
0409E3             0454*  atan2_168fast:
0409E3             0455*  ; get signs and make everything positive
0409E3             0456*  ; get abs(x) and store its original sign
0409E3 C5          0457*      push bc
0409E4 E1          0458*      pop hl
0409E5 CD 94 06 04 0459*      call hlu_abs ; if x was negative this also sets the sign flag
0409E9 E5          0460*      push hl ; store abs(x)
0409EA C1          0461*      pop bc ; bc = abs(x)
0409EB F5          0462*      push af ; store sign of x
0409EC             0463*  ; get abs(y) and store its original sign
0409EC EB          0464*      ex de,hl ; hl = y
0409ED CD 94 06 04 0465*      call hlu_abs ; if y was negative this also sets the sign flag
0409F1 EB          0466*      ex de,hl ; de = abs(y)
0409F2 F5          0467*      push af ; store sign of y
0409F3             0468*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0409F3             0469*  ; this ensures that our lookup value is between 0 and 1 inclusive
0409F3 AF          0470*      xor a ; clear the carry flag
0409F4 D5          0471*      push de
0409F5 E1          0472*      pop hl
0409F6 ED 42       0473*      sbc hl,bc
0409F8 F5          0474*      push af ; save sign of de - bc
0409F9 F2 02 0A 04 0475*      jp p,@1 ; bc <= de, so we skip ahead
0409FD             0476*  ; otherwise we swap bc and de
0409FD C5          0477*      push bc
0409FE E1          0478*      pop hl
0409FF EB          0479*      ex de,hl
040A00 E5          0480*      push hl
040A01 C1          0481*      pop bc
040A02             0482*  @1:
040A02             0483*  ; now we're ready to snag our preliminary result
040A02 C5          0484*      push bc
040A03 E1          0485*      pop hl
040A04 CD 72 0A 04 0486*      call atan_168fast ; uh.l comes back with prelim result
040A08             0487*  ; now we adjust uh.l based on sign of de - bc
040A08 F1          0488*      pop af
040A09 F2 15 0A 04 0489*      jp p,@2 ; bc <= de,so we skip ahead
040A0D EB          0490*      ex de,hl
040A0E 21 00 40 00 0491*      ld hl,64*256 ; subtract from 64 (90) degrees
040A12 AF          0492*      xor a ; clear the carry flag
040A13 ED 52       0493*      sbc hl,de
040A15             0494*  @2:
040A15             0495*  ; adjust the result based on quadrant
040A15             0496*  ; #E0 224      0       32 #20
040A15             0497*  ;        -x,-y | +x,-y
040A15             0498*  ; #C0 192------+------ 64 #40
040A15             0499*  ;        -x,+y | +x,+y
040A15             0500*  ; #A0 160   128 #80   96 #60
040A15 F1          0501*      pop af ; sign of y
040A16 CA 53 0A 04 0502*      jp z,@y_zero
040A1A F2 33 0A 04 0503*      jp p,@y_pos
040A1E             0504*  ; y neg,check x
040A1E F1          0505*      pop af ; sign of x
040A1F CA 2D 0A 04 0506*      jp z,@y_neg_x_zero
040A23 F2 32 0A 04 0507*      jp p,@y_neg_x_pos
040A27             0508*  ; y neg,x neg
040A27             0509*  ; angle is 128 to 256 (270 to 360)
040A27             0510*  ; negating the intermediate does the trick
040A27 CD A4 06 04 0511*      call neg_hlu
040A2B 18 31       0512*      jr @zero_hlu
040A2D             0513*  
040A2D             0514*  @y_neg_x_zero:
040A2D             0515*  ; y neg,x zero
040A2D             0516*  ; angle is 0
040A2D 21 00 00 00 0517*      ld hl,0
040A31 C9          0518*      ret
040A32             0519*  @y_neg_x_pos:
040A32             0520*  ; y neg,x pos
040A32             0521*  ; angle is 0 to 64 (0 to 90)
040A32             0522*  ; so we're good
040A32 C9          0523*      ret
040A33             0524*  
040A33             0525*  @y_pos:
040A33 F1          0526*      pop af ; sign of x
040A34 CA 43 0A 04 0527*      jp z,@y_pos_x_zero
040A38 F2 48 0A 04 0528*      jp p,@y_pos_x_pos
040A3C             0529*  ; y pos,x neg
040A3C             0530*  ; angle is 128 to 192 (180-270)
040A3C             0531*  ; so we add 128 to intermediate
040A3C 11 00 80 00 0532*      ld de,128*256
040A40 19          0533*      add hl,de
040A41 18 1B       0534*      jr @zero_hlu
040A43             0535*  @y_pos_x_zero:
040A43             0536*  ; y pos,x zero
040A43             0537*  ; angle is 128 (180)
040A43 21 00 80 00 0538*      ld hl,128*256
040A47 C9          0539*      ret
040A48             0540*  @y_pos_x_pos:
040A48             0541*  ; y pos,x pos
040A48             0542*  ; angle is 64 to 128 (90 to 180)
040A48             0543*  ; neg the intermediate and add 180 degrees
040A48 CD A4 06 04 0544*      call neg_hlu
040A4C 11 00 80 00 0545*      ld de,128*256
040A50 19          0546*      add hl,de
040A51 18 0B       0547*      jr @zero_hlu
040A53             0548*  
040A53             0549*  @y_zero:
040A53 F1          0550*      pop af ; sign of x
040A54 FA 59 0A 04 0551*      jp m,@y_zero_x_neg
040A58             0552*  ; y zero,x pos
040A58             0553*  ; angle is 64 (90),nothing to do
040A58 C9          0554*      ret
040A59             0555*  @y_zero_x_neg:
040A59             0556*  ; y zero ,x neg
040A59             0557*  ; angle is 192 (270)
040A59 21 00 C0 00 0558*      ld hl,192*256
040A5D C9          0559*      ret
040A5E             0560*  @zero_hlu:
040A5E AF          0561*      xor a
040A5F 22 6C 0A 04 0562*      ld (@scratch),hl
040A63 32 6E 0A 04 0563*      ld (@scratch+2),a
040A67 2A 6C 0A 04 0564*      ld hl,(@scratch)
040A6B C9          0565*      ret
040A6C             0566*  @scratch: ds 6
040A72             0567*  
040A72             0568*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040A72             0569*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
040A72             0570*  ; destroys: a,hl,bc,de
040A72             0571*  ; note: only works for angles from 0 to 32 (45) degrees
040A72             0572*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040A72             0573*  atan_168fast:
040A72             0574*  ; because we use compass headings instead of geometric angles
040A72             0575*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040A72             0576*  ; we can do faster unsigned division here because we know dx and dy are positive
040A72 CD 72 08 04 0577*      call udiv168 ; ud.e = dx/dy
040A76 EB          0578*      ex de,hl ; uh.l = dx/dy
040A77             0579*  ; test uh.l for 0
040A77 19          0580*      add hl,de
040A78 B7          0581*      or a
040A79 ED 52       0582*      sbc hl,de
040A7B 28 22       0583*      jr z,@is_zero
040A7D             0584*  ; test uh.l for 1
040A7D AF          0585*      xor a ; clear carry
040A7E EB          0586*      ex de,hl
040A7F 21 00 01 00 0587*      ld hl,1*256 ; 1 in 16.8 fixed format
040A83 ED 52       0588*      sbc hl,de
040A85 28 13       0589*      jr z,@is_45
040A87 EB          0590*      ex de,hl
040A88             0591*  ; no special cases so we move on
040A88             0592*  ; l contains the fractional portion of tan(uh.l)
040A88             0593*  ; we multiply it by three to get our lookup table index
040A88 26 03       0594*      ld h,3
040A8A ED 6C       0595*      mlt hl ; index into lut
040A8C 11 00 00 00 0596*      ld de,0 ; clear deu
040A90 54          0597*      ld d,h ; copy hl to de
040A91 5D          0598*      ld e,l ; de contains our index
040A92 21 97 0E 04 0599*      ld hl,atan_lut_168 ; grab the lut address
040A96 19          0600*      add hl,de ; bump hl by the index
040A97 ED 27       0601*      ld hl,(hl) ; don't try this on a z80!
040A99 C9          0602*      ret ; and out
040A9A             0603*  @is_45:
040A9A 21 00 40 00 0604*      ld hl,64*256
040A9E C9          0605*      ret
040A9F             0606*  ; for the case tan(0)
040A9F             0607*  @is_zero:
040A9F 21 00 00 00 0608*      ld hl,0*256
040AA3 C9          0609*      ret
040AA4             0610*  
040AA4             0611*  ; Expects  ADL mode
040AA4             0612*  ; Inputs:  UH.L
040AA4             0613*  ; Outputs: UH.L is the 16.8 square root
040AA4             0614*  ;          UDE is the integer difference inputHL-DE^2
040AA4             0615*  sqrt168:
040AA4 CD AE 0A 04 0616*      call sqrt24
040AA8 EB          0617*      ex de,hl
040AA9 29          0618*      add hl,hl
040AAA 29          0619*      add hl,hl
040AAB 29          0620*      add hl,hl
040AAC 29          0621*      add hl,hl
040AAD C9          0622*      ret
040AAE             0623*  
040AAE             0624*  ; credit: xeda112358
040AAE             0625*  ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040AAE             0626*  sqrt24:
040AAE             0627*  ; Expects ADL mode
040AAE             0628*  ; Inputs: HL
040AAE             0629*  ; Outputs: DE is the integer square root
040AAE             0630*  ;  HL is the difference inputHL-DE^2
040AAE             0631*  ;  c flag reset
040AAE 01 00 00 00 0632*      ld bc,0 ; clear bcu
040AB2 11 00 00 00 0633*      ld de,0 ; clear deu
040AB6 AF          0634*      xor a
040AB7 45          0635*      ld b,l
040AB8 C5          0636*      push bc
040AB9 47          0637*      ld b,a
040ABA 6F          0638*      ld l,a
040ABB             0639*  ; Iteration 1
040ABB 29          0640*      add hl,hl
040ABC CB 11       0641*      rl c
040ABE 29          0642*      add hl,hl
040ABF CB 11       0643*      rl c
040AC1 91          0644*      sub c
040AC2 30 04       0645*      jr nc,$+6
040AC4 1C          0646*      inc e
040AC5 1C          0647*      inc e
040AC6 2F          0648*      cpl
040AC7 4F          0649*      ld c,a
040AC8             0650*  ; Iteration 2
040AC8 29          0651*      add hl,hl
040AC9 CB 11       0652*      rl c
040ACB 29          0653*      add hl,hl
040ACC CB 11       0654*      rl c
040ACE CB 13       0655*      rl e
040AD0 7B          0656*      ld a,e
040AD1 91          0657*      sub c
040AD2 30 04       0658*      jr nc,$+6
040AD4 1C          0659*      inc e
040AD5 1C          0660*      inc e
040AD6 2F          0661*      cpl
040AD7 4F          0662*      ld c,a
040AD8             0663*  ; Iteration 3
040AD8 29          0664*      add hl,hl
040AD9 CB 11       0665*      rl c
040ADB 29          0666*      add hl,hl
040ADC CB 11       0667*      rl c
040ADE CB 13       0668*      rl e
040AE0 7B          0669*      ld a,e
040AE1 91          0670*      sub c
040AE2 30 04       0671*      jr nc,$+6
040AE4 1C          0672*      inc e
040AE5 1C          0673*      inc e
040AE6 2F          0674*      cpl
040AE7 4F          0675*      ld c,a
040AE8             0676*  ; Iteration 4
040AE8 29          0677*      add hl,hl
040AE9 CB 11       0678*      rl c
040AEB 29          0679*      add hl,hl
040AEC CB 11       0680*      rl c
040AEE CB 13       0681*      rl e
040AF0 7B          0682*      ld a,e
040AF1 91          0683*      sub c
040AF2 30 04       0684*      jr nc,$+6
040AF4 1C          0685*      inc e
040AF5 1C          0686*      inc e
040AF6 2F          0687*      cpl
040AF7 4F          0688*      ld c,a
040AF8             0689*  ; Iteration 5
040AF8 29          0690*      add hl,hl
040AF9 CB 11       0691*      rl c
040AFB 29          0692*      add hl,hl
040AFC CB 11       0693*      rl c
040AFE CB 13       0694*      rl e
040B00 7B          0695*      ld a,e
040B01 91          0696*      sub c
040B02 30 04       0697*      jr nc,$+6
040B04 1C          0698*      inc e
040B05 1C          0699*      inc e
040B06 2F          0700*      cpl
040B07 4F          0701*      ld c,a
040B08             0702*  ; Iteration 6
040B08 29          0703*      add hl,hl
040B09 CB 11       0704*      rl c
040B0B 29          0705*      add hl,hl
040B0C CB 11       0706*      rl c
040B0E CB 13       0707*      rl e
040B10 7B          0708*      ld a,e
040B11 91          0709*      sub c
040B12 30 04       0710*      jr nc,$+6
040B14 1C          0711*      inc e
040B15 1C          0712*      inc e
040B16 2F          0713*      cpl
040B17 4F          0714*      ld c,a
040B18             0715*  ; Iteration 7
040B18 29          0716*      add hl,hl
040B19 CB 11       0717*      rl c
040B1B 29          0718*      add hl,hl
040B1C CB 11       0719*      rl c
040B1E CB 10       0720*      rl b
040B20 EB          0721*      ex de,hl
040B21 29          0722*      add hl,hl
040B22 E5          0723*      push hl
040B23 ED 42       0724*      sbc hl,bc
040B25 30 06       0725*      jr nc,$+8
040B27 7C          0726*      ld a,h
040B28 2F          0727*      cpl
040B29 47          0728*      ld b,a
040B2A 7D          0729*      ld a,l
040B2B 2F          0730*      cpl
040B2C 4F          0731*      ld c,a
040B2D E1          0732*      pop hl
040B2E 30 02       0733*      jr nc,$+4
040B30 23          0734*      inc hl
040B31 23          0735*      inc hl
040B32 EB          0736*      ex de,hl
040B33             0737*  ; Iteration 8
040B33 29          0738*      add hl,hl
040B34 69          0739*      ld l,c
040B35 60          0740*      ld h,b
040B36 ED 6A       0741*      adc hl,hl
040B38 ED 6A       0742*      adc hl,hl
040B3A EB          0743*      ex de,hl
040B3B 29          0744*      add hl,hl
040B3C ED 52       0745*      sbc hl,de
040B3E 19          0746*      add hl,de
040B3F EB          0747*      ex de,hl
040B40 30 04       0748*      jr nc,$+6
040B42 ED 52       0749*      sbc hl,de
040B44 13          0750*      inc de
040B45 13          0751*      inc de
040B46             0752*  ; Iteration 9
040B46 F1          0753*      pop af
040B47 17          0754*      rla
040B48 ED 6A       0755*      adc hl,hl
040B4A 17          0756*      rla
040B4B ED 6A       0757*      adc hl,hl
040B4D EB          0758*      ex de,hl
040B4E 29          0759*      add hl,hl
040B4F ED 52       0760*      sbc hl,de
040B51 19          0761*      add hl,de
040B52 EB          0762*      ex de,hl
040B53 30 04       0763*      jr nc,$+6
040B55 ED 52       0764*      sbc hl,de
040B57 13          0765*      inc de
040B58 13          0766*      inc de
040B59             0767*  ; Iteration 10
040B59 17          0768*      rla
040B5A ED 6A       0769*      adc hl,hl
040B5C 17          0770*      rla
040B5D ED 6A       0771*      adc hl,hl
040B5F EB          0772*      ex de,hl
040B60 29          0773*      add hl,hl
040B61 ED 52       0774*      sbc hl,de
040B63 19          0775*      add hl,de
040B64 EB          0776*      ex de,hl
040B65 30 04       0777*      jr nc,$+6
040B67 ED 52       0778*      sbc hl,de
040B69 13          0779*      inc de
040B6A 13          0780*      inc de
040B6B             0781*  ; Iteration 11
040B6B 17          0782*      rla
040B6C ED 6A       0783*      adc hl,hl
040B6E 17          0784*      rla
040B6F ED 6A       0785*      adc hl,hl
040B71 EB          0786*      ex de,hl
040B72 29          0787*      add hl,hl
040B73 ED 52       0788*      sbc hl,de
040B75 19          0789*      add hl,de
040B76 EB          0790*      ex de,hl
040B77 30 04       0791*      jr nc,$+6
040B79 ED 52       0792*      sbc hl,de
040B7B 13          0793*      inc de
040B7C 13          0794*      inc de
040B7D             0795*  ; Iteration 12
040B7D 17          0796*      rla
040B7E ED 6A       0797*      adc hl,hl
040B80 17          0798*      rla
040B81 ED 6A       0799*      adc hl,hl
040B83 EB          0800*      ex de,hl
040B84 29          0801*      add hl,hl
040B85 ED 52       0802*      sbc hl,de
040B87 19          0803*      add hl,de
040B88 EB          0804*      ex de,hl
040B89 30 04       0805*      jr nc,$+6
040B8B ED 52       0806*      sbc hl,de
040B8D 13          0807*      inc de
040B8E 13          0808*      inc de
040B8F CB 1A       0809*      rr d
040B91 CB 1B       0810*      rr e
040B93 C9          0811*      ret
040B94             0812*  
040B94             0813*  sin_lut_168:
040B94 00 00 00    0814*      dl 0x000000 ; 0.000 00, 0.000
040B97 06 00 00    0815*      dl 0x000006 ; 1.406 01, 0.025
040B9A 0C 00 00    0816*      dl 0x00000C ; 2.813 02, 0.049
040B9D 12 00 00    0817*      dl 0x000012 ; 4.219 03, 0.074
040BA0 19 00 00    0818*      dl 0x000019 ; 5.625 04, 0.098
040BA3 1F 00 00    0819*      dl 0x00001F ; 7.031 05, 0.122
040BA6 25 00 00    0820*      dl 0x000025 ; 8.438 06, 0.147
040BA9 2B 00 00    0821*      dl 0x00002B ; 9.844 07, 0.171
040BAC 31 00 00    0822*      dl 0x000031 ; 11.250 08, 0.195
040BAF 38 00 00    0823*      dl 0x000038 ; 12.656 09, 0.219
040BB2 3E 00 00    0824*      dl 0x00003E ; 14.063 0A, 0.243
040BB5 44 00 00    0825*      dl 0x000044 ; 15.469 0B, 0.267
040BB8 4A 00 00    0826*      dl 0x00004A ; 16.875 0C, 0.290
040BBB 50 00 00    0827*      dl 0x000050 ; 18.281 0D, 0.314
040BBE 56 00 00    0828*      dl 0x000056 ; 19.688 0E, 0.337
040BC1 5C 00 00    0829*      dl 0x00005C ; 21.094 0F, 0.360
040BC4 61 00 00    0830*      dl 0x000061 ; 22.500 10, 0.383
040BC7 67 00 00    0831*      dl 0x000067 ; 23.906 11, 0.405
040BCA 6D 00 00    0832*      dl 0x00006D ; 25.313 12, 0.428
040BCD 73 00 00    0833*      dl 0x000073 ; 26.719 13, 0.450
040BD0 78 00 00    0834*      dl 0x000078 ; 28.125 14, 0.471
040BD3 7E 00 00    0835*      dl 0x00007E ; 29.531 15, 0.493
040BD6 83 00 00    0836*      dl 0x000083 ; 30.938 16, 0.514
040BD9 88 00 00    0837*      dl 0x000088 ; 32.344 17, 0.535
040BDC 8E 00 00    0838*      dl 0x00008E ; 33.750 18, 0.556
040BDF 93 00 00    0839*      dl 0x000093 ; 35.156 19, 0.576
040BE2 98 00 00    0840*      dl 0x000098 ; 36.563 1A, 0.596
040BE5 9D 00 00    0841*      dl 0x00009D ; 37.969 1B, 0.615
040BE8 A2 00 00    0842*      dl 0x0000A2 ; 39.375 1C, 0.634
040BEB A7 00 00    0843*      dl 0x0000A7 ; 40.781 1D, 0.653
040BEE AB 00 00    0844*      dl 0x0000AB ; 42.188 1E, 0.672
040BF1 B0 00 00    0845*      dl 0x0000B0 ; 43.594 1F, 0.690
040BF4 B5 00 00    0846*      dl 0x0000B5 ; 45.000 20, 0.707
040BF7 B9 00 00    0847*      dl 0x0000B9 ; 46.406 21, 0.724
040BFA BD 00 00    0848*      dl 0x0000BD ; 47.813 22, 0.741
040BFD C1 00 00    0849*      dl 0x0000C1 ; 49.219 23, 0.757
040C00 C5 00 00    0850*      dl 0x0000C5 ; 50.625 24, 0.773
040C03 C9 00 00    0851*      dl 0x0000C9 ; 52.031 25, 0.788
040C06 CD 00 00    0852*      dl 0x0000CD ; 53.438 26, 0.803
040C09 D1 00 00    0853*      dl 0x0000D1 ; 54.844 27, 0.818
040C0C D4 00 00    0854*      dl 0x0000D4 ; 56.250 28, 0.831
040C0F D8 00 00    0855*      dl 0x0000D8 ; 57.656 29, 0.845
040C12 DB 00 00    0856*      dl 0x0000DB ; 59.063 2A, 0.858
040C15 DE 00 00    0857*      dl 0x0000DE ; 60.469 2B, 0.870
040C18 E1 00 00    0858*      dl 0x0000E1 ; 61.875 2C, 0.882
040C1B E4 00 00    0859*      dl 0x0000E4 ; 63.281 2D, 0.893
040C1E E7 00 00    0860*      dl 0x0000E7 ; 64.688 2E, 0.904
040C21 EA 00 00    0861*      dl 0x0000EA ; 66.094 2F, 0.914
040C24 EC 00 00    0862*      dl 0x0000EC ; 67.500 30, 0.924
040C27 EE 00 00    0863*      dl 0x0000EE ; 68.906 31, 0.933
040C2A F1 00 00    0864*      dl 0x0000F1 ; 70.313 32, 0.942
040C2D F3 00 00    0865*      dl 0x0000F3 ; 71.719 33, 0.950
040C30 F4 00 00    0866*      dl 0x0000F4 ; 73.125 34, 0.957
040C33 F6 00 00    0867*      dl 0x0000F6 ; 74.531 35, 0.964
040C36 F8 00 00    0868*      dl 0x0000F8 ; 75.938 36, 0.970
040C39 F9 00 00    0869*      dl 0x0000F9 ; 77.344 37, 0.976
040C3C FB 00 00    0870*      dl 0x0000FB ; 78.750 38, 0.981
040C3F FC 00 00    0871*      dl 0x0000FC ; 80.156 39, 0.985
040C42 FD 00 00    0872*      dl 0x0000FD ; 81.563 3A, 0.989
040C45 FE 00 00    0873*      dl 0x0000FE ; 82.969 3B, 0.992
040C48 FE 00 00    0874*      dl 0x0000FE ; 84.375 3C, 0.995
040C4B FF 00 00    0875*      dl 0x0000FF ; 85.781 3D, 0.997
040C4E FF 00 00    0876*      dl 0x0000FF ; 87.188 3E, 0.999
040C51 FF 00 00    0877*      dl 0x0000FF ; 88.594 3F, 1.000
040C54 00 01 00    0878*      dl 0x000100 ; 90.000 40, 1.000
040C57 FF 00 00    0879*      dl 0x0000FF ; 91.406 41, 1.000
040C5A FF 00 00    0880*      dl 0x0000FF ; 92.813 42, 0.999
040C5D FF 00 00    0881*      dl 0x0000FF ; 94.219 43, 0.997
040C60 FE 00 00    0882*      dl 0x0000FE ; 95.625 44, 0.995
040C63 FE 00 00    0883*      dl 0x0000FE ; 97.031 45, 0.992
040C66 FD 00 00    0884*      dl 0x0000FD ; 98.438 46, 0.989
040C69 FC 00 00    0885*      dl 0x0000FC ; 99.844 47, 0.985
040C6C FB 00 00    0886*      dl 0x0000FB ; 101.250 48, 0.981
040C6F F9 00 00    0887*      dl 0x0000F9 ; 102.656 49, 0.976
040C72 F8 00 00    0888*      dl 0x0000F8 ; 104.063 4A, 0.970
040C75 F6 00 00    0889*      dl 0x0000F6 ; 105.469 4B, 0.964
040C78 F4 00 00    0890*      dl 0x0000F4 ; 106.875 4C, 0.957
040C7B F3 00 00    0891*      dl 0x0000F3 ; 108.281 4D, 0.950
040C7E F1 00 00    0892*      dl 0x0000F1 ; 109.688 4E, 0.942
040C81 EE 00 00    0893*      dl 0x0000EE ; 111.094 4F, 0.933
040C84 EC 00 00    0894*      dl 0x0000EC ; 112.500 50, 0.924
040C87 EA 00 00    0895*      dl 0x0000EA ; 113.906 51, 0.914
040C8A E7 00 00    0896*      dl 0x0000E7 ; 115.313 52, 0.904
040C8D E4 00 00    0897*      dl 0x0000E4 ; 116.719 53, 0.893
040C90 E1 00 00    0898*      dl 0x0000E1 ; 118.125 54, 0.882
040C93 DE 00 00    0899*      dl 0x0000DE ; 119.531 55, 0.870
040C96 DB 00 00    0900*      dl 0x0000DB ; 120.938 56, 0.858
040C99 D8 00 00    0901*      dl 0x0000D8 ; 122.344 57, 0.845
040C9C D4 00 00    0902*      dl 0x0000D4 ; 123.750 58, 0.831
040C9F D1 00 00    0903*      dl 0x0000D1 ; 125.156 59, 0.818
040CA2 CD 00 00    0904*      dl 0x0000CD ; 126.563 5A, 0.803
040CA5 C9 00 00    0905*      dl 0x0000C9 ; 127.969 5B, 0.788
040CA8 C5 00 00    0906*      dl 0x0000C5 ; 129.375 5C, 0.773
040CAB C1 00 00    0907*      dl 0x0000C1 ; 130.781 5D, 0.757
040CAE BD 00 00    0908*      dl 0x0000BD ; 132.188 5E, 0.741
040CB1 B9 00 00    0909*      dl 0x0000B9 ; 133.594 5F, 0.724
040CB4 B5 00 00    0910*      dl 0x0000B5 ; 135.000 60, 0.707
040CB7 B0 00 00    0911*      dl 0x0000B0 ; 136.406 61, 0.690
040CBA AB 00 00    0912*      dl 0x0000AB ; 137.813 62, 0.672
040CBD A7 00 00    0913*      dl 0x0000A7 ; 139.219 63, 0.653
040CC0 A2 00 00    0914*      dl 0x0000A2 ; 140.625 64, 0.634
040CC3 9D 00 00    0915*      dl 0x00009D ; 142.031 65, 0.615
040CC6 98 00 00    0916*      dl 0x000098 ; 143.438 66, 0.596
040CC9 93 00 00    0917*      dl 0x000093 ; 144.844 67, 0.576
040CCC 8E 00 00    0918*      dl 0x00008E ; 146.250 68, 0.556
040CCF 88 00 00    0919*      dl 0x000088 ; 147.656 69, 0.535
040CD2 83 00 00    0920*      dl 0x000083 ; 149.063 6A, 0.514
040CD5 7E 00 00    0921*      dl 0x00007E ; 150.469 6B, 0.493
040CD8 78 00 00    0922*      dl 0x000078 ; 151.875 6C, 0.471
040CDB 73 00 00    0923*      dl 0x000073 ; 153.281 6D, 0.450
040CDE 6D 00 00    0924*      dl 0x00006D ; 154.688 6E, 0.428
040CE1 67 00 00    0925*      dl 0x000067 ; 156.094 6F, 0.405
040CE4 61 00 00    0926*      dl 0x000061 ; 157.500 70, 0.383
040CE7 5C 00 00    0927*      dl 0x00005C ; 158.906 71, 0.360
040CEA 56 00 00    0928*      dl 0x000056 ; 160.313 72, 0.337
040CED 50 00 00    0929*      dl 0x000050 ; 161.719 73, 0.314
040CF0 4A 00 00    0930*      dl 0x00004A ; 163.125 74, 0.290
040CF3 44 00 00    0931*      dl 0x000044 ; 164.531 75, 0.267
040CF6 3E 00 00    0932*      dl 0x00003E ; 165.938 76, 0.243
040CF9 38 00 00    0933*      dl 0x000038 ; 167.344 77, 0.219
040CFC 31 00 00    0934*      dl 0x000031 ; 168.750 78, 0.195
040CFF 2B 00 00    0935*      dl 0x00002B ; 170.156 79, 0.171
040D02 25 00 00    0936*      dl 0x000025 ; 171.563 7A, 0.147
040D05 1F 00 00    0937*      dl 0x00001F ; 172.969 7B, 0.122
040D08 19 00 00    0938*      dl 0x000019 ; 174.375 7C, 0.098
040D0B 12 00 00    0939*      dl 0x000012 ; 175.781 7D, 0.074
040D0E 0C 00 00    0940*      dl 0x00000C ; 177.188 7E, 0.049
040D11 06 00 00    0941*      dl 0x000006 ; 178.594 7F, 0.025
040D14 00 00 00    0942*      dl 0x000000 ; 180.000 80, 0.000
040D17 FA FF FF    0943*      dl 0xFFFFFA ; 181.406 81, -0.025
040D1A F4 FF FF    0944*      dl 0xFFFFF4 ; 182.813 82, -0.049
040D1D EE FF FF    0945*      dl 0xFFFFEE ; 184.219 83, -0.074
040D20 E7 FF FF    0946*      dl 0xFFFFE7 ; 185.625 84, -0.098
040D23 E1 FF FF    0947*      dl 0xFFFFE1 ; 187.031 85, -0.122
040D26 DB FF FF    0948*      dl 0xFFFFDB ; 188.438 86, -0.147
040D29 D5 FF FF    0949*      dl 0xFFFFD5 ; 189.844 87, -0.171
040D2C CF FF FF    0950*      dl 0xFFFFCF ; 191.250 88, -0.195
040D2F C8 FF FF    0951*      dl 0xFFFFC8 ; 192.656 89, -0.219
040D32 C2 FF FF    0952*      dl 0xFFFFC2 ; 194.063 8A, -0.243
040D35 BC FF FF    0953*      dl 0xFFFFBC ; 195.469 8B, -0.267
040D38 B6 FF FF    0954*      dl 0xFFFFB6 ; 196.875 8C, -0.290
040D3B B0 FF FF    0955*      dl 0xFFFFB0 ; 198.281 8D, -0.314
040D3E AA FF FF    0956*      dl 0xFFFFAA ; 199.688 8E, -0.337
040D41 A4 FF FF    0957*      dl 0xFFFFA4 ; 201.094 8F, -0.360
040D44 9F FF FF    0958*      dl 0xFFFF9F ; 202.500 90, -0.383
040D47 99 FF FF    0959*      dl 0xFFFF99 ; 203.906 91, -0.405
040D4A 93 FF FF    0960*      dl 0xFFFF93 ; 205.313 92, -0.428
040D4D 8D FF FF    0961*      dl 0xFFFF8D ; 206.719 93, -0.450
040D50 88 FF FF    0962*      dl 0xFFFF88 ; 208.125 94, -0.471
040D53 82 FF FF    0963*      dl 0xFFFF82 ; 209.531 95, -0.493
040D56 7D FF FF    0964*      dl 0xFFFF7D ; 210.938 96, -0.514
040D59 78 FF FF    0965*      dl 0xFFFF78 ; 212.344 97, -0.535
040D5C 72 FF FF    0966*      dl 0xFFFF72 ; 213.750 98, -0.556
040D5F 6D FF FF    0967*      dl 0xFFFF6D ; 215.156 99, -0.576
040D62 68 FF FF    0968*      dl 0xFFFF68 ; 216.563 9A, -0.596
040D65 63 FF FF    0969*      dl 0xFFFF63 ; 217.969 9B, -0.615
040D68 5E FF FF    0970*      dl 0xFFFF5E ; 219.375 9C, -0.634
040D6B 59 FF FF    0971*      dl 0xFFFF59 ; 220.781 9D, -0.653
040D6E 55 FF FF    0972*      dl 0xFFFF55 ; 222.188 9E, -0.672
040D71 50 FF FF    0973*      dl 0xFFFF50 ; 223.594 9F, -0.690
040D74 4B FF FF    0974*      dl 0xFFFF4B ; 225.000 A0, -0.707
040D77 47 FF FF    0975*      dl 0xFFFF47 ; 226.406 A1, -0.724
040D7A 43 FF FF    0976*      dl 0xFFFF43 ; 227.813 A2, -0.741
040D7D 3F FF FF    0977*      dl 0xFFFF3F ; 229.219 A3, -0.757
040D80 3B FF FF    0978*      dl 0xFFFF3B ; 230.625 A4, -0.773
040D83 37 FF FF    0979*      dl 0xFFFF37 ; 232.031 A5, -0.788
040D86 33 FF FF    0980*      dl 0xFFFF33 ; 233.438 A6, -0.803
040D89 2F FF FF    0981*      dl 0xFFFF2F ; 234.844 A7, -0.818
040D8C 2C FF FF    0982*      dl 0xFFFF2C ; 236.250 A8, -0.831
040D8F 28 FF FF    0983*      dl 0xFFFF28 ; 237.656 A9, -0.845
040D92 25 FF FF    0984*      dl 0xFFFF25 ; 239.063 AA, -0.858
040D95 22 FF FF    0985*      dl 0xFFFF22 ; 240.469 AB, -0.870
040D98 1F FF FF    0986*      dl 0xFFFF1F ; 241.875 AC, -0.882
040D9B 1C FF FF    0987*      dl 0xFFFF1C ; 243.281 AD, -0.893
040D9E 19 FF FF    0988*      dl 0xFFFF19 ; 244.688 AE, -0.904
040DA1 16 FF FF    0989*      dl 0xFFFF16 ; 246.094 AF, -0.914
040DA4 14 FF FF    0990*      dl 0xFFFF14 ; 247.500 B0, -0.924
040DA7 12 FF FF    0991*      dl 0xFFFF12 ; 248.906 B1, -0.933
040DAA 0F FF FF    0992*      dl 0xFFFF0F ; 250.313 B2, -0.942
040DAD 0D FF FF    0993*      dl 0xFFFF0D ; 251.719 B3, -0.950
040DB0 0C FF FF    0994*      dl 0xFFFF0C ; 253.125 B4, -0.957
040DB3 0A FF FF    0995*      dl 0xFFFF0A ; 254.531 B5, -0.964
040DB6 08 FF FF    0996*      dl 0xFFFF08 ; 255.938 B6, -0.970
040DB9 07 FF FF    0997*      dl 0xFFFF07 ; 257.344 B7, -0.976
040DBC 05 FF FF    0998*      dl 0xFFFF05 ; 258.750 B8, -0.981
040DBF 04 FF FF    0999*      dl 0xFFFF04 ; 260.156 B9, -0.985
040DC2 03 FF FF    1000*      dl 0xFFFF03 ; 261.563 BA, -0.989
040DC5 02 FF FF    1001*      dl 0xFFFF02 ; 262.969 BB, -0.992
040DC8 02 FF FF    1002*      dl 0xFFFF02 ; 264.375 BC, -0.995
040DCB 01 FF FF    1003*      dl 0xFFFF01 ; 265.781 BD, -0.997
040DCE 01 FF FF    1004*      dl 0xFFFF01 ; 267.188 BE, -0.999
040DD1 01 FF FF    1005*      dl 0xFFFF01 ; 268.594 BF, -1.000
040DD4 00 FF FF    1006*      dl 0xFFFF00 ; 270.000 C0, -1.000
040DD7 01 FF FF    1007*      dl 0xFFFF01 ; 271.406 C1, -1.000
040DDA 01 FF FF    1008*      dl 0xFFFF01 ; 272.813 C2, -0.999
040DDD 01 FF FF    1009*      dl 0xFFFF01 ; 274.219 C3, -0.997
040DE0 02 FF FF    1010*      dl 0xFFFF02 ; 275.625 C4, -0.995
040DE3 02 FF FF    1011*      dl 0xFFFF02 ; 277.031 C5, -0.992
040DE6 03 FF FF    1012*      dl 0xFFFF03 ; 278.438 C6, -0.989
040DE9 04 FF FF    1013*      dl 0xFFFF04 ; 279.844 C7, -0.985
040DEC 05 FF FF    1014*      dl 0xFFFF05 ; 281.250 C8, -0.981
040DEF 07 FF FF    1015*      dl 0xFFFF07 ; 282.656 C9, -0.976
040DF2 08 FF FF    1016*      dl 0xFFFF08 ; 284.063 CA, -0.970
040DF5 0A FF FF    1017*      dl 0xFFFF0A ; 285.469 CB, -0.964
040DF8 0C FF FF    1018*      dl 0xFFFF0C ; 286.875 CC, -0.957
040DFB 0D FF FF    1019*      dl 0xFFFF0D ; 288.281 CD, -0.950
040DFE 0F FF FF    1020*      dl 0xFFFF0F ; 289.688 CE, -0.942
040E01 12 FF FF    1021*      dl 0xFFFF12 ; 291.094 CF, -0.933
040E04 14 FF FF    1022*      dl 0xFFFF14 ; 292.500 D0, -0.924
040E07 16 FF FF    1023*      dl 0xFFFF16 ; 293.906 D1, -0.914
040E0A 19 FF FF    1024*      dl 0xFFFF19 ; 295.313 D2, -0.904
040E0D 1C FF FF    1025*      dl 0xFFFF1C ; 296.719 D3, -0.893
040E10 1F FF FF    1026*      dl 0xFFFF1F ; 298.125 D4, -0.882
040E13 22 FF FF    1027*      dl 0xFFFF22 ; 299.531 D5, -0.870
040E16 25 FF FF    1028*      dl 0xFFFF25 ; 300.938 D6, -0.858
040E19 28 FF FF    1029*      dl 0xFFFF28 ; 302.344 D7, -0.845
040E1C 2C FF FF    1030*      dl 0xFFFF2C ; 303.750 D8, -0.831
040E1F 2F FF FF    1031*      dl 0xFFFF2F ; 305.156 D9, -0.818
040E22 33 FF FF    1032*      dl 0xFFFF33 ; 306.563 DA, -0.803
040E25 37 FF FF    1033*      dl 0xFFFF37 ; 307.969 DB, -0.788
040E28 3B FF FF    1034*      dl 0xFFFF3B ; 309.375 DC, -0.773
040E2B 3F FF FF    1035*      dl 0xFFFF3F ; 310.781 DD, -0.757
040E2E 43 FF FF    1036*      dl 0xFFFF43 ; 312.188 DE, -0.741
040E31 47 FF FF    1037*      dl 0xFFFF47 ; 313.594 DF, -0.724
040E34 4B FF FF    1038*      dl 0xFFFF4B ; 315.000 E0, -0.707
040E37 50 FF FF    1039*      dl 0xFFFF50 ; 316.406 E1, -0.690
040E3A 55 FF FF    1040*      dl 0xFFFF55 ; 317.813 E2, -0.672
040E3D 59 FF FF    1041*      dl 0xFFFF59 ; 319.219 E3, -0.653
040E40 5E FF FF    1042*      dl 0xFFFF5E ; 320.625 E4, -0.634
040E43 63 FF FF    1043*      dl 0xFFFF63 ; 322.031 E5, -0.615
040E46 68 FF FF    1044*      dl 0xFFFF68 ; 323.438 E6, -0.596
040E49 6D FF FF    1045*      dl 0xFFFF6D ; 324.844 E7, -0.576
040E4C 72 FF FF    1046*      dl 0xFFFF72 ; 326.250 E8, -0.556
040E4F 78 FF FF    1047*      dl 0xFFFF78 ; 327.656 E9, -0.535
040E52 7D FF FF    1048*      dl 0xFFFF7D ; 329.063 EA, -0.514
040E55 82 FF FF    1049*      dl 0xFFFF82 ; 330.469 EB, -0.493
040E58 88 FF FF    1050*      dl 0xFFFF88 ; 331.875 EC, -0.471
040E5B 8D FF FF    1051*      dl 0xFFFF8D ; 333.281 ED, -0.450
040E5E 93 FF FF    1052*      dl 0xFFFF93 ; 334.688 EE, -0.428
040E61 99 FF FF    1053*      dl 0xFFFF99 ; 336.094 EF, -0.405
040E64 9F FF FF    1054*      dl 0xFFFF9F ; 337.500 F0, -0.383
040E67 A4 FF FF    1055*      dl 0xFFFFA4 ; 338.906 F1, -0.360
040E6A AA FF FF    1056*      dl 0xFFFFAA ; 340.313 F2, -0.337
040E6D B0 FF FF    1057*      dl 0xFFFFB0 ; 341.719 F3, -0.314
040E70 B6 FF FF    1058*      dl 0xFFFFB6 ; 343.125 F4, -0.290
040E73 BC FF FF    1059*      dl 0xFFFFBC ; 344.531 F5, -0.267
040E76 C2 FF FF    1060*      dl 0xFFFFC2 ; 345.938 F6, -0.243
040E79 C8 FF FF    1061*      dl 0xFFFFC8 ; 347.344 F7, -0.219
040E7C CF FF FF    1062*      dl 0xFFFFCF ; 348.750 F8, -0.195
040E7F D5 FF FF    1063*      dl 0xFFFFD5 ; 350.156 F9, -0.171
040E82 DB FF FF    1064*      dl 0xFFFFDB ; 351.563 FA, -0.147
040E85 E1 FF FF    1065*      dl 0xFFFFE1 ; 352.969 FB, -0.122
040E88 E7 FF FF    1066*      dl 0xFFFFE7 ; 354.375 FC, -0.098
040E8B EE FF FF    1067*      dl 0xFFFFEE ; 355.781 FD, -0.074
040E8E F4 FF FF    1068*      dl 0xFFFFF4 ; 357.188 FE, -0.049
040E91 FA FF FF    1069*      dl 0xFFFFFA ; 358.594 FF, -0.025
040E94 00 00 00    1070*      dl 0x000000 ; 0.000 00, 0.000 for interpolation
040E97             1071*  
040E97             1072*  atan_lut_168:
040E97 00 00 00    1073*      dl 0x000000 ; 000000, 0.000
040E9A 28 00 00    1074*      dl 0x000028 ; 000001, 0.224
040E9D 51 00 00    1075*      dl 0x000051 ; 000002, 0.448
040EA0 7A 00 00    1076*      dl 0x00007A ; 000003, 0.671
040EA3 A2 00 00    1077*      dl 0x0000A2 ; 000004, 0.895
040EA6 CB 00 00    1078*      dl 0x0000CB ; 000005, 1.119
040EA9 F4 00 00    1079*      dl 0x0000F4 ; 000006, 1.343
040EAC 1D 01 00    1080*      dl 0x00011D ; 000007, 1.566
040EAF 45 01 00    1081*      dl 0x000145 ; 000008, 1.790
040EB2 6E 01 00    1082*      dl 0x00016E ; 000009, 2.013
040EB5 97 01 00    1083*      dl 0x000197 ; 00000A, 2.237
040EB8 BF 01 00    1084*      dl 0x0001BF ; 00000B, 2.460
040EBB E8 01 00    1085*      dl 0x0001E8 ; 00000C, 2.684
040EBE 11 02 00    1086*      dl 0x000211 ; 00000D, 2.907
040EC1 39 02 00    1087*      dl 0x000239 ; 00000E, 3.130
040EC4 62 02 00    1088*      dl 0x000262 ; 00000F, 3.353
040EC7 8B 02 00    1089*      dl 0x00028B ; 000010, 3.576
040ECA B3 02 00    1090*      dl 0x0002B3 ; 000011, 3.799
040ECD DC 02 00    1091*      dl 0x0002DC ; 000012, 4.022
040ED0 04 03 00    1092*      dl 0x000304 ; 000013, 4.245
040ED3 2D 03 00    1093*      dl 0x00032D ; 000014, 4.467
040ED6 55 03 00    1094*      dl 0x000355 ; 000015, 4.690
040ED9 7E 03 00    1095*      dl 0x00037E ; 000016, 4.912
040EDC A6 03 00    1096*      dl 0x0003A6 ; 000017, 5.134
040EDF CE 03 00    1097*      dl 0x0003CE ; 000018, 5.356
040EE2 F7 03 00    1098*      dl 0x0003F7 ; 000019, 5.578
040EE5 1F 04 00    1099*      dl 0x00041F ; 00001A, 5.799
040EE8 48 04 00    1100*      dl 0x000448 ; 00001B, 6.021
040EEB 70 04 00    1101*      dl 0x000470 ; 00001C, 6.242
040EEE 98 04 00    1102*      dl 0x000498 ; 00001D, 6.463
040EF1 C0 04 00    1103*      dl 0x0004C0 ; 00001E, 6.684
040EF4 E8 04 00    1104*      dl 0x0004E8 ; 00001F, 6.905
040EF7 11 05 00    1105*      dl 0x000511 ; 000020, 7.125
040EFA 39 05 00    1106*      dl 0x000539 ; 000021, 7.345
040EFD 61 05 00    1107*      dl 0x000561 ; 000022, 7.565
040F00 89 05 00    1108*      dl 0x000589 ; 000023, 7.785
040F03 B1 05 00    1109*      dl 0x0005B1 ; 000024, 8.005
040F06 D9 05 00    1110*      dl 0x0005D9 ; 000025, 8.224
040F09 01 06 00    1111*      dl 0x000601 ; 000026, 8.443
040F0C 28 06 00    1112*      dl 0x000628 ; 000027, 8.662
040F0F 50 06 00    1113*      dl 0x000650 ; 000028, 8.881
040F12 78 06 00    1114*      dl 0x000678 ; 000029, 9.099
040F15 A0 06 00    1115*      dl 0x0006A0 ; 00002A, 9.317
040F18 C7 06 00    1116*      dl 0x0006C7 ; 00002B, 9.535
040F1B EF 06 00    1117*      dl 0x0006EF ; 00002C, 9.752
040F1E 16 07 00    1118*      dl 0x000716 ; 00002D, 9.970
040F21 3E 07 00    1119*      dl 0x00073E ; 00002E, 10.187
040F24 65 07 00    1120*      dl 0x000765 ; 00002F, 10.403
040F27 8D 07 00    1121*      dl 0x00078D ; 000030, 10.620
040F2A B4 07 00    1122*      dl 0x0007B4 ; 000031, 10.836
040F2D DB 07 00    1123*      dl 0x0007DB ; 000032, 11.051
040F30 03 08 00    1124*      dl 0x000803 ; 000033, 11.267
040F33 2A 08 00    1125*      dl 0x00082A ; 000034, 11.482
040F36 51 08 00    1126*      dl 0x000851 ; 000035, 11.697
040F39 78 08 00    1127*      dl 0x000878 ; 000036, 11.911
040F3C 9F 08 00    1128*      dl 0x00089F ; 000037, 12.125
040F3F C6 08 00    1129*      dl 0x0008C6 ; 000038, 12.339
040F42 ED 08 00    1130*      dl 0x0008ED ; 000039, 12.553
040F45 13 09 00    1131*      dl 0x000913 ; 00003A, 12.766
040F48 3A 09 00    1132*      dl 0x00093A ; 00003B, 12.978
040F4B 61 09 00    1133*      dl 0x000961 ; 00003C, 13.191
040F4E 87 09 00    1134*      dl 0x000987 ; 00003D, 13.403
040F51 AE 09 00    1135*      dl 0x0009AE ; 00003E, 13.614
040F54 D4 09 00    1136*      dl 0x0009D4 ; 00003F, 13.825
040F57 FB 09 00    1137*      dl 0x0009FB ; 000040, 14.036
040F5A 21 0A 00    1138*      dl 0x000A21 ; 000041, 14.247
040F5D 47 0A 00    1139*      dl 0x000A47 ; 000042, 14.457
040F60 6D 0A 00    1140*      dl 0x000A6D ; 000043, 14.666
040F63 94 0A 00    1141*      dl 0x000A94 ; 000044, 14.876
040F66 BA 0A 00    1142*      dl 0x000ABA ; 000045, 15.085
040F69 E0 0A 00    1143*      dl 0x000AE0 ; 000046, 15.293
040F6C 05 0B 00    1144*      dl 0x000B05 ; 000047, 15.501
040F6F 2B 0B 00    1145*      dl 0x000B2B ; 000048, 15.709
040F72 51 0B 00    1146*      dl 0x000B51 ; 000049, 15.916
040F75 77 0B 00    1147*      dl 0x000B77 ; 00004A, 16.123
040F78 9C 0B 00    1148*      dl 0x000B9C ; 00004B, 16.329
040F7B C2 0B 00    1149*      dl 0x000BC2 ; 00004C, 16.535
040F7E E7 0B 00    1150*      dl 0x000BE7 ; 00004D, 16.740
040F81 0C 0C 00    1151*      dl 0x000C0C ; 00004E, 16.945
040F84 32 0C 00    1152*      dl 0x000C32 ; 00004F, 17.150
040F87 57 0C 00    1153*      dl 0x000C57 ; 000050, 17.354
040F8A 7C 0C 00    1154*      dl 0x000C7C ; 000051, 17.558
040F8D A1 0C 00    1155*      dl 0x000CA1 ; 000052, 17.761
040F90 C6 0C 00    1156*      dl 0x000CC6 ; 000053, 17.964
040F93 EB 0C 00    1157*      dl 0x000CEB ; 000054, 18.166
040F96 0F 0D 00    1158*      dl 0x000D0F ; 000055, 18.368
040F99 34 0D 00    1159*      dl 0x000D34 ; 000056, 18.569
040F9C 58 0D 00    1160*      dl 0x000D58 ; 000057, 18.770
040F9F 7D 0D 00    1161*      dl 0x000D7D ; 000058, 18.970
040FA2 A1 0D 00    1162*      dl 0x000DA1 ; 000059, 19.170
040FA5 C6 0D 00    1163*      dl 0x000DC6 ; 00005A, 19.370
040FA8 EA 0D 00    1164*      dl 0x000DEA ; 00005B, 19.569
040FAB 0E 0E 00    1165*      dl 0x000E0E ; 00005C, 19.767
040FAE 32 0E 00    1166*      dl 0x000E32 ; 00005D, 19.965
040FB1 56 0E 00    1167*      dl 0x000E56 ; 00005E, 20.163
040FB4 7A 0E 00    1168*      dl 0x000E7A ; 00005F, 20.360
040FB7 9E 0E 00    1169*      dl 0x000E9E ; 000060, 20.556
040FBA C1 0E 00    1170*      dl 0x000EC1 ; 000061, 20.752
040FBD E5 0E 00    1171*      dl 0x000EE5 ; 000062, 20.947
040FC0 08 0F 00    1172*      dl 0x000F08 ; 000063, 21.142
040FC3 2C 0F 00    1173*      dl 0x000F2C ; 000064, 21.337
040FC6 4F 0F 00    1174*      dl 0x000F4F ; 000065, 21.531
040FC9 72 0F 00    1175*      dl 0x000F72 ; 000066, 21.724
040FCC 95 0F 00    1176*      dl 0x000F95 ; 000067, 21.917
040FCF B8 0F 00    1177*      dl 0x000FB8 ; 000068, 22.109
040FD2 DB 0F 00    1178*      dl 0x000FDB ; 000069, 22.301
040FD5 FE 0F 00    1179*      dl 0x000FFE ; 00006A, 22.493
040FD8 21 10 00    1180*      dl 0x001021 ; 00006B, 22.683
040FDB 44 10 00    1181*      dl 0x001044 ; 00006C, 22.874
040FDE 66 10 00    1182*      dl 0x001066 ; 00006D, 23.063
040FE1 89 10 00    1183*      dl 0x001089 ; 00006E, 23.253
040FE4 AB 10 00    1184*      dl 0x0010AB ; 00006F, 23.441
040FE7 CD 10 00    1185*      dl 0x0010CD ; 000070, 23.629
040FEA EF 10 00    1186*      dl 0x0010EF ; 000071, 23.817
040FED 11 11 00    1187*      dl 0x001111 ; 000072, 24.004
040FF0 33 11 00    1188*      dl 0x001133 ; 000073, 24.191
040FF3 55 11 00    1189*      dl 0x001155 ; 000074, 24.376
040FF6 77 11 00    1190*      dl 0x001177 ; 000075, 24.562
040FF9 99 11 00    1191*      dl 0x001199 ; 000076, 24.747
040FFC BA 11 00    1192*      dl 0x0011BA ; 000077, 24.931
040FFF DC 11 00    1193*      dl 0x0011DC ; 000078, 25.115
041002 FD 11 00    1194*      dl 0x0011FD ; 000079, 25.298
041005 1E 12 00    1195*      dl 0x00121E ; 00007A, 25.481
041008 3F 12 00    1196*      dl 0x00123F ; 00007B, 25.663
04100B 60 12 00    1197*      dl 0x001260 ; 00007C, 25.844
04100E 81 12 00    1198*      dl 0x001281 ; 00007D, 26.025
041011 A2 12 00    1199*      dl 0x0012A2 ; 00007E, 26.206
041014 C3 12 00    1200*      dl 0x0012C3 ; 00007F, 26.386
041017 E4 12 00    1201*      dl 0x0012E4 ; 000080, 26.565
04101A 04 13 00    1202*      dl 0x001304 ; 000081, 26.744
04101D 25 13 00    1203*      dl 0x001325 ; 000082, 26.922
041020 45 13 00    1204*      dl 0x001345 ; 000083, 27.100
041023 65 13 00    1205*      dl 0x001365 ; 000084, 27.277
041026 85 13 00    1206*      dl 0x001385 ; 000085, 27.453
041029 A5 13 00    1207*      dl 0x0013A5 ; 000086, 27.629
04102C C5 13 00    1208*      dl 0x0013C5 ; 000087, 27.805
04102F E5 13 00    1209*      dl 0x0013E5 ; 000088, 27.979
041032 05 14 00    1210*      dl 0x001405 ; 000089, 28.154
041035 24 14 00    1211*      dl 0x001424 ; 00008A, 28.327
041038 44 14 00    1212*      dl 0x001444 ; 00008B, 28.501
04103B 63 14 00    1213*      dl 0x001463 ; 00008C, 28.673
04103E 83 14 00    1214*      dl 0x001483 ; 00008D, 28.845
041041 A2 14 00    1215*      dl 0x0014A2 ; 00008E, 29.017
041044 C1 14 00    1216*      dl 0x0014C1 ; 00008F, 29.187
041047 E0 14 00    1217*      dl 0x0014E0 ; 000090, 29.358
04104A FF 14 00    1218*      dl 0x0014FF ; 000091, 29.527
04104D 1E 15 00    1219*      dl 0x00151E ; 000092, 29.697
041050 3C 15 00    1220*      dl 0x00153C ; 000093, 29.865
041053 5B 15 00    1221*      dl 0x00155B ; 000094, 30.033
041056 79 15 00    1222*      dl 0x001579 ; 000095, 30.201
041059 98 15 00    1223*      dl 0x001598 ; 000096, 30.368
04105C B6 15 00    1224*      dl 0x0015B6 ; 000097, 30.534
04105F D4 15 00    1225*      dl 0x0015D4 ; 000098, 30.700
041062 F2 15 00    1226*      dl 0x0015F2 ; 000099, 30.865
041065 10 16 00    1227*      dl 0x001610 ; 00009A, 31.030
041068 2E 16 00    1228*      dl 0x00162E ; 00009B, 31.194
04106B 4C 16 00    1229*      dl 0x00164C ; 00009C, 31.357
04106E 6A 16 00    1230*      dl 0x00166A ; 00009D, 31.520
041071 87 16 00    1231*      dl 0x001687 ; 00009E, 31.682
041074 A5 16 00    1232*      dl 0x0016A5 ; 00009F, 31.844
041077 C2 16 00    1233*      dl 0x0016C2 ; 0000A0, 32.005
04107A DF 16 00    1234*      dl 0x0016DF ; 0000A1, 32.166
04107D FC 16 00    1235*      dl 0x0016FC ; 0000A2, 32.326
041080 19 17 00    1236*      dl 0x001719 ; 0000A3, 32.486
041083 36 17 00    1237*      dl 0x001736 ; 0000A4, 32.645
041086 53 17 00    1238*      dl 0x001753 ; 0000A5, 32.803
041089 70 17 00    1239*      dl 0x001770 ; 0000A6, 32.961
04108C 8C 17 00    1240*      dl 0x00178C ; 0000A7, 33.118
04108F A9 17 00    1241*      dl 0x0017A9 ; 0000A8, 33.275
041092 C5 17 00    1242*      dl 0x0017C5 ; 0000A9, 33.431
041095 E2 17 00    1243*      dl 0x0017E2 ; 0000AA, 33.587
041098 FE 17 00    1244*      dl 0x0017FE ; 0000AB, 33.742
04109B 1A 18 00    1245*      dl 0x00181A ; 0000AC, 33.896
04109E 36 18 00    1246*      dl 0x001836 ; 0000AD, 34.050
0410A1 52 18 00    1247*      dl 0x001852 ; 0000AE, 34.203
0410A4 6E 18 00    1248*      dl 0x00186E ; 0000AF, 34.356
0410A7 8A 18 00    1249*      dl 0x00188A ; 0000B0, 34.509
0410AA A5 18 00    1250*      dl 0x0018A5 ; 0000B1, 34.660
0410AD C1 18 00    1251*      dl 0x0018C1 ; 0000B2, 34.811
0410B0 DC 18 00    1252*      dl 0x0018DC ; 0000B3, 34.962
0410B3 F7 18 00    1253*      dl 0x0018F7 ; 0000B4, 35.112
0410B6 13 19 00    1254*      dl 0x001913 ; 0000B5, 35.262
0410B9 2E 19 00    1255*      dl 0x00192E ; 0000B6, 35.410
0410BC 49 19 00    1256*      dl 0x001949 ; 0000B7, 35.559
0410BF 64 19 00    1257*      dl 0x001964 ; 0000B8, 35.707
0410C2 7F 19 00    1258*      dl 0x00197F ; 0000B9, 35.854
0410C5 99 19 00    1259*      dl 0x001999 ; 0000BA, 36.001
0410C8 B4 19 00    1260*      dl 0x0019B4 ; 0000BB, 36.147
0410CB CE 19 00    1261*      dl 0x0019CE ; 0000BC, 36.293
0410CE E9 19 00    1262*      dl 0x0019E9 ; 0000BD, 36.438
0410D1 03 1A 00    1263*      dl 0x001A03 ; 0000BE, 36.582
0410D4 1D 1A 00    1264*      dl 0x001A1D ; 0000BF, 36.726
0410D7 37 1A 00    1265*      dl 0x001A37 ; 0000C0, 36.870
0410DA 51 1A 00    1266*      dl 0x001A51 ; 0000C1, 37.013
0410DD 6B 1A 00    1267*      dl 0x001A6B ; 0000C2, 37.155
0410E0 85 1A 00    1268*      dl 0x001A85 ; 0000C3, 37.297
0410E3 9F 1A 00    1269*      dl 0x001A9F ; 0000C4, 37.439
0410E6 B9 1A 00    1270*      dl 0x001AB9 ; 0000C5, 37.579
0410E9 D2 1A 00    1271*      dl 0x001AD2 ; 0000C6, 37.720
0410EC EC 1A 00    1272*      dl 0x001AEC ; 0000C7, 37.859
0410EF 05 1B 00    1273*      dl 0x001B05 ; 0000C8, 37.999
0410F2 1E 1B 00    1274*      dl 0x001B1E ; 0000C9, 38.137
0410F5 37 1B 00    1275*      dl 0x001B37 ; 0000CA, 38.276
0410F8 50 1B 00    1276*      dl 0x001B50 ; 0000CB, 38.413
0410FB 69 1B 00    1277*      dl 0x001B69 ; 0000CC, 38.550
0410FE 82 1B 00    1278*      dl 0x001B82 ; 0000CD, 38.687
041101 9B 1B 00    1279*      dl 0x001B9B ; 0000CE, 38.823
041104 B4 1B 00    1280*      dl 0x001BB4 ; 0000CF, 38.959
041107 CC 1B 00    1281*      dl 0x001BCC ; 0000D0, 39.094
04110A E5 1B 00    1282*      dl 0x001BE5 ; 0000D1, 39.228
04110D FD 1B 00    1283*      dl 0x001BFD ; 0000D2, 39.362
041110 16 1C 00    1284*      dl 0x001C16 ; 0000D3, 39.496
041113 2E 1C 00    1285*      dl 0x001C2E ; 0000D4, 39.629
041116 46 1C 00    1286*      dl 0x001C46 ; 0000D5, 39.762
041119 5E 1C 00    1287*      dl 0x001C5E ; 0000D6, 39.894
04111C 76 1C 00    1288*      dl 0x001C76 ; 0000D7, 40.025
04111F 8E 1C 00    1289*      dl 0x001C8E ; 0000D8, 40.156
041122 A5 1C 00    1290*      dl 0x001CA5 ; 0000D9, 40.286
041125 BD 1C 00    1291*      dl 0x001CBD ; 0000DA, 40.416
041128 D5 1C 00    1292*      dl 0x001CD5 ; 0000DB, 40.546
04112B EC 1C 00    1293*      dl 0x001CEC ; 0000DC, 40.675
04112E 04 1D 00    1294*      dl 0x001D04 ; 0000DD, 40.803
041131 1B 1D 00    1295*      dl 0x001D1B ; 0000DE, 40.931
041134 32 1D 00    1296*      dl 0x001D32 ; 0000DF, 41.059
041137 49 1D 00    1297*      dl 0x001D49 ; 0000E0, 41.186
04113A 60 1D 00    1298*      dl 0x001D60 ; 0000E1, 41.312
04113D 77 1D 00    1299*      dl 0x001D77 ; 0000E2, 41.438
041140 8E 1D 00    1300*      dl 0x001D8E ; 0000E3, 41.564
041143 A5 1D 00    1301*      dl 0x001DA5 ; 0000E4, 41.689
041146 BB 1D 00    1302*      dl 0x001DBB ; 0000E5, 41.814
041149 D2 1D 00    1303*      dl 0x001DD2 ; 0000E6, 41.938
04114C E9 1D 00    1304*      dl 0x001DE9 ; 0000E7, 42.061
04114F FF 1D 00    1305*      dl 0x001DFF ; 0000E8, 42.184
041152 15 1E 00    1306*      dl 0x001E15 ; 0000E9, 42.307
041155 2C 1E 00    1307*      dl 0x001E2C ; 0000EA, 42.429
041158 42 1E 00    1308*      dl 0x001E42 ; 0000EB, 42.551
04115B 58 1E 00    1309*      dl 0x001E58 ; 0000EC, 42.672
04115E 6E 1E 00    1310*      dl 0x001E6E ; 0000ED, 42.793
041161 84 1E 00    1311*      dl 0x001E84 ; 0000EE, 42.913
041164 99 1E 00    1312*      dl 0x001E99 ; 0000EF, 43.033
041167 AF 1E 00    1313*      dl 0x001EAF ; 0000F0, 43.152
04116A C5 1E 00    1314*      dl 0x001EC5 ; 0000F1, 43.271
04116D DA 1E 00    1315*      dl 0x001EDA ; 0000F2, 43.390
041170 F0 1E 00    1316*      dl 0x001EF0 ; 0000F3, 43.508
041173 05 1F 00    1317*      dl 0x001F05 ; 0000F4, 43.625
041176 1B 1F 00    1318*      dl 0x001F1B ; 0000F5, 43.742
041179 30 1F 00    1319*      dl 0x001F30 ; 0000F6, 43.859
04117C 45 1F 00    1320*      dl 0x001F45 ; 0000F7, 43.975
04117F 5A 1F 00    1321*      dl 0x001F5A ; 0000F8, 44.091
041182 6F 1F 00    1322*      dl 0x001F6F ; 0000F9, 44.206
041185 84 1F 00    1323*      dl 0x001F84 ; 0000FA, 44.321
041188 99 1F 00    1324*      dl 0x001F99 ; 0000FB, 44.435
04118B AD 1F 00    1325*      dl 0x001FAD ; 0000FC, 44.549
04118E C2 1F 00    1326*      dl 0x001FC2 ; 0000FD, 44.662
041191 D7 1F 00    1327*      dl 0x001FD7 ; 0000FE, 44.775
041194 EB 1F 00    1328*      dl 0x001FEB ; 0000FF, 44.888
041197 00 20 00    1329*      dl 0x002000 ; 000100, 45.000 only needed for interpolation
04119A             0034       include "images.inc"
04119A             0001*  image_type: equ 0
04119A             0002*  image_width: equ image_type+3
04119A             0003*  image_height: equ image_width+3
04119A             0004*  image_filesize: equ image_height+3
04119A             0005*  image_filename: equ image_filesize+3
04119A             0006*  image_bufferId: equ image_filename+3
04119A             0007*  image_record_size: equ image_bufferId+3
04119A             0008*  
04119A 00 00 00    0009*  cur_image_list: dl 0
04119D 00 00 00    0010*  cur_file_idx: dl 0
0411A0 00 00 00    0011*  cur_filename: dl 0
0411A3 00 00 00    0012*  cur_buffer_id: dl 0
0411A6             0013*  
0411A6             0014*  ; load_ui_images:
0411A6             0015*  ; ; initialize image loading variables
0411A6             0016*  ;     ld hl,0
0411A6             0017*  ;     ld (cur_file_idx),hl
0411A6             0018*  ;     ld hl,ui_image_list
0411A6             0019*  ;     ld (cur_image_list),hl
0411A6             0020*  ; ; load images
0411A6             0021*  ;     ld b,ui_num_images
0411A6             0022*  ; @loop:
0411A6             0023*  ;     push bc
0411A6             0024*  ;     call load_next_image
0411A6             0025*  ;     pop bc
0411A6             0026*  ;     djnz @loop
0411A6             0027*  ;     ret
0411A6             0028*  
0411A6             0029*  load_sprite_images:
0411A6             0030*  ; initialize image loading variables
0411A6 21 00 00 00 0031*      ld hl,0
0411AA 22 9D 11 04 0032*      ld (cur_file_idx),hl
0411AE 21 12 1B 04 0033*      ld hl,sprites_image_list
0411B2 22 9A 11 04 0034*      ld (cur_image_list),hl
0411B6 01 71 00 00 0035*      ld bc,sprites_num_images
0411BA             0036*  ; load images
0411BA CD BF 11 04 0037*      call img_load_main
0411BE C9          0038*      ret
0411BF             0039*  
0411BF             0040*  ; inputs: bc is the number of images to load, cur_image_list set
0411BF             0041*  img_load_main:
0411BF AF          0042*      xor a
0411C0 32 9D 11 04 0043*      ld (cur_file_idx),a
0411C4             0044*  
0411C4             0045*  img_load_main_loop:
0411C4             0046*  ; back up loop counter
0411C4 C5          0047*      push bc
0411C5             0048*  
0411C5             0049*  ; load the next image
0411C5 CD E0 11 04 0050*      call load_next_image
0411C9             0051*  
0411C9             0052*  ; ; plot the background
0411C9             0053*  ;     call vdu_cls
0411C9             0054*  ;     ld hl,BUF_SPLASH_BG
0411C9             0055*  ;     call vdu_buff_select
0411C9             0056*  ;     ld bc,0
0411C9             0057*  ;     ld de,0
0411C9             0058*  ;     call vdu_plot_bmp
0411C9             0059*  
0411C9             0060*  ; ; draw the most recently loaded image
0411C9             0061*  ; 	ld hl,(cur_buffer_id)
0411C9             0062*  ; 	call vdu_buff_select
0411C9             0063*  ; 	ld bc,0
0411C9             0064*  ; 	ld de,0
0411C9             0065*  ; 	call vdu_plot_bmp
0411C9             0066*  
0411C9             0067*  ; ; move logo
0411C9             0068*  ;     call move_logo
0411C9             0069*  
0411C9             0070*  ; print current filename
0411C9 2A A0 11 04 0071*      ld hl,(cur_filename)
0411CD CD 77 00 04 0072*      call printString
0411D1             0073*  
0411D1             0074*  ; flip the framebuffer
0411D1             0075*      ; call vdu_flip
0411D1             0076*  
0411D1             0077*  ; decrement loop counter
0411D1 C1          0078*      pop bc
0411D2 0B          0079*      dec bc
0411D3 79          0080*      ld a,c
0411D4 B7          0081*      or a
0411D5 C2 C4 11 04 0082*      jp nz,img_load_main_loop
0411D9 78          0083*      ld a,b
0411DA B7          0084*      or a
0411DB C2 C4 11 04 0085*      jp nz,img_load_main_loop
0411DF C9          0086*      ret
0411E0             0087*  
0411E0             0088*  load_next_image:
0411E0 16 12       0089*      ld d,image_record_size
0411E2 3A 9D 11 04 0090*      ld a,(cur_file_idx)
0411E6 5F          0091*      ld e,a
0411E7 ED 5C       0092*      mlt de
0411E9 FD 2A 9A 11 0093*      ld iy,(cur_image_list)
       04          
0411EE FD 19       0094*      add iy,de
0411F0             0095*  
0411F0 FD 7E 00    0096*      ld a,(iy+image_type) ; get image type
0411F3 FD 07 03    0097*      ld bc,(iy+image_width) ; get image width
0411F6 FD 17 06    0098*      ld de,(iy+image_height) ; get image height
0411F9 FD 31 09    0099*      ld ix,(iy+image_filesize) ; get image file size
0411FC FD 27 0F    0100*      ld hl,(iy+image_bufferId) ; get image bufferId
0411FF 22 A3 11 04 0101*      ld (cur_buffer_id),hl
041203 FD 37 0C    0102*      ld iy,(iy+image_filename) ; get image filename
041206 FD 22 A0 11 0103*      ld (cur_filename),iy
       04          
04120B CD E0 15 04 0104*      call vdu_load_img
04120F FD 21 9D 11 0105*      ld iy,cur_file_idx
       04          
041214 FD 34 00    0106*      inc (iy)
041217 C9          0107*      ret
041218             0108*  
041218             0109*  ; img_load_init:
041218             0110*  ; ; initialize logo's position parameters
041218             0111*  ;     ld hl,0
041218             0112*  ;     ld (logo_xvel),hl
041218             0113*  ;     ld (logo_xpos),hl
041218             0114*  ; ; begin 16.8 maths to determine logo's y position and velocity
041218             0115*  ;     ld hl,240-16*256 ; allow space for text at bottom of screen
041218             0116*  ;     ld (logo_ypos),hl
041218             0117*  ;     ex de,hl
041218             0118*  ;     ld hl,-8*256 ; 8 pixels from top of screen
041218             0119*  ;     add hl,de ; distance for logo to travel
041218             0120*  ;     ld de,-sprites_num_images*256
041218             0121*  ;     call sdiv168 ; ud.e = distance / num images = y velocity
041218             0122*  ;     ld (logo_yvel),de
041218             0123*  ; ; all done
041218             0124*  ;     ret
041218             0125*  
041218             0126*  ; move_logo:
041218             0127*  ; ; activate logo bitmap
041218             0128*  ;     ld hl, BUF_SPLASH_LOGO
041218             0129*  ;     call vdu_buff_select
041218             0130*  ; ; update position based on velocity parameters
041218             0131*  ;     ld hl,(logo_ypos)
041218             0132*  ;     ld de,(logo_yvel)
041218             0133*  ;     add hl,de
041218             0134*  ;     ld (logo_ypos),hl
041218             0135*  ; ; draw logo
041218             0136*  ;     ld bc,(logo_xpos)
041218             0137*  ;     ld de,(logo_ypos)
041218             0138*  ;     call vdu_plot_bmp168
041218             0139*  ;     ret
041218             0140*  
041218             0141*  ; logo_xvel: dl 0
041218             0142*  ; logo_xpos: dl 0
041218             0143*  
041218             0144*  ; logo_yvel: dl 0
041218             0145*  ; logo_ypos: dl 0
041218             0035       include "timer.inc"
041218             0001*  ; Table 32. Timer Control Registers
041218             0002*  ; this constant is the base address of the timer control registers
041218             0003*  ; each timer takes three bytes:
041218             0004*  ;   0: control register
041218             0005*  ;   1: low byte of timer reset value
041218             0006*  ;   2: high byte of timer reset value
041218             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041218             0008*  ; which correctly force the high and upper bytes of the address bus to zero
041218             0009*  TMR_CTL:     equ 80h
041218             0010*  
041218             0011*  ; Timer Control Register Bit Definitions
041218             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041218             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
041218             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041218             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
041218             0016*                              ; the TMRx_CTL register is read.
041218             0017*  
041218             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041218             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041218             0020*  
041218             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041218             0022*                              ;  0,and counting stops when the end-of-count value is reached.
041218             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041218             0024*                              ; written to the counter when the end-of-count value is reached.
041218             0025*  
041218             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041218             0027*  CLK_DIV_256:  equ %00001100 ;
041218             0028*  CLK_DIV_64:   equ %00001000 ;
041218             0029*  CLK_DIV_16:   equ %00000100 ;
041218             0030*  CLK_DIV_4:    equ %00000000 ;
041218             0031*  
041218             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041218             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041218             0034*                              ; When a 1 is written to this bit,the values in the reload registers
041218             0035*                              ;  are loaded into the downcounter when the timer restarts. The
041218             0036*                              ; programmer must ensure that this bit is set to 1 each time
041218             0037*                              ; SINGLE-PASS mode is used.
041218             0038*  
041218             0039*  ; disable/enable the programmable reload timer
041218             0040*  PRT_EN_0:     equ %00000000 ;
041218             0041*  PRT_EN_1:     equ %00000001 ;
041218             0042*  
041218             0043*  ; Table 37. Timer Input Source Select Register
041218             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
041218             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041218             0046*  ;   00: System clock / CLK_DIV
041218             0047*  ;   01: RTC / CLK_DIV
041218             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
041218             0049*  ;   10: GPIO port B pin 1.
041218             0050*  ;   11: GPIO port B pin 1.
041218             0051*  TMR_ISS:   equ 92h ; register address
041218             0052*  
041218             0053*  ; Table 51. Real-Time Clock Control Register
041218             0054*  RTC_CTRL: equ EDh ; register address
041218             0055*  
041218             0056*  ; alarm interrupt disable/enable
041218             0057*  RTC_ALARM_0:    equ %00000000
041218             0058*  RTC_ALARM_1:    equ %10000000
041218             0059*  
041218             0060*  ; interrupt on alarm disable/enable
041218             0061*  RTC_INT_ENT_0:  equ %00000000
041218             0062*  RTC_INT_ENT_1:  equ %01000000
041218             0063*  
041218             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041218             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041218             0066*  
041218             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041218             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
041218             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041218             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
041218             0071*  
041218             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041218             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041218             0074*  
041218             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041218             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041218             0077*  
041218             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041218             0079*                                  ; RTC counter is enabled.
041218             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041218             0081*                                  ; RTC counter is disabled.
041218             0082*  
041218             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041218             0084*  
041218             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041218             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041218 00 00 00    0087*  prt_reload: dl 0x000000
04121B             0088*  
04121B             0089*  ; set PRT timer
04121B             0090*  prt_set:
04121B 21 00 00 00 0091*      ld hl,0
04121F 22 69 12 04 0092*      ld (prt_irq_counter),hl
041223 2A 18 12 04 0093*      ld hl,(prt_reload)
041227 ED 29 84    0094*      out0 ($84),l
04122A ED 21 85    0095*  	out0 ($85),h
04122D             0096*  ; disable timer
04122D 3E 06       0097*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04122F ED 39 83    0098*  	out0 ($83),a
041232             0099*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
041232 3E 57       0100*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
041234 ED 39 83    0101*  	out0 ($83),a
041237 C9          0102*      ret
041238             0103*  
041238             0104*  ; ===============================================
041238             0105*  ; PRT Timer Interrupt Handling
041238             0106*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
041238             0107*  ; -----------------------------------------------
041238             0108*  prt_irq_init:
041238             0109*      ; set up interrupt vector table 2
041238 21 00 00 00 0110*  	ld hl,0
04123C 3A 0C 01 00 0111*  	ld a,($10c)
041240 6F          0112*  	ld l,a
041241 3A 0D 01 00 0113*  	ld a,($10d)
041245 67          0114*  	ld h,a
041246             0115*  
041246             0116*  	; skip over CALL ($c3)
041246 23          0117*  	inc hl
041247             0118*  	; load address of jump into vector table 2 (in ram)
041247 ED 27       0119*  	ld hl,(hl)
041249             0120*  
041249             0121*  	; write CALL prt_irq_handler to vector table 2
041249 3E C3       0122*  	ld a,$c3
04124B 77          0123*  	ld (hl),a
04124C 23          0124*  	inc hl
04124D 11 54 12 04 0125*  	ld de,prt_irq_handler
041251 ED 1F       0126*  	ld (hl),de
041253             0127*  
041253 C9          0128*      ret
041254             0129*  
041254             0130*  prt_irq_handler:
041254 F3          0131*  	di
041255 F5          0132*  	push af
041256 E5          0133*      push hl
041257 ED 38 83    0134*  	in0 a,($83)
04125A 2A 69 12 04 0135*  	ld hl,(prt_irq_counter)
04125E 23          0136*  	inc hl
04125F 22 69 12 04 0137*  	ld (prt_irq_counter),hl
041263 E1          0138*      pop hl
041264 F1          0139*  	pop af
041265 FB          0140*  	ei
041266 5B ED 4D    0141*  	reti.l
041269             0142*  
041269             0143*  prt_irq_counter:
041269 00 00 00    0144*  	.dl 0
04126C             0145*  prt_irq_counter_saved:
04126C 00 00 00    0146*      .dl 0
04126F             0147*  
04126F             0148*  prt_loop_reset:
04126F E5          0149*      push hl
041270 21 00 00 00 0150*  	ld hl,0
041274 22 69 12 04 0151*  	ld (prt_irq_counter),hl
041278 22 DA 12 04 0152*      ld (prt_loop_counter),hl
04127C 22 DD 12 04 0153*      ld (prt_loops),hl
041280 CD 1B 12 04 0154*      call prt_set
041284 E1          0155*      pop hl
041285 C9          0156*      ret
041286             0157*  
041286             0158*  prt_loop_start:
041286 E5          0159*      push hl
041287 21 00 00 00 0160*  	ld hl,0
04128B 22 69 12 04 0161*  	ld (prt_irq_counter),hl
04128F E1          0162*      pop hl
041290 C9          0163*      ret
041291             0164*  
041291             0165*  prt_loop_stop:
041291 E5          0166*      push hl
041292 D5          0167*      push de
041293 2A 69 12 04 0168*      ld hl,(prt_irq_counter)
041297 ED 5B DA 12 0169*      ld de,(prt_loop_counter)
       04          
04129C 19          0170*      add hl,de
04129D 22 DA 12 04 0171*      ld (prt_loop_counter),hl
0412A1 21 00 00 00 0172*      ld hl,0
0412A5 22 69 12 04 0173*      ld (prt_irq_counter),hl
0412A9 2A DD 12 04 0174*      ld hl,(prt_loops)
0412AD 23          0175*      inc hl
0412AE 22 DD 12 04 0176*      ld (prt_loops),hl
0412B2 D1          0177*      pop de
0412B3 E1          0178*      pop hl
0412B4 C9          0179*      ret
0412B5             0180*  
0412B5             0181*  ; inputs: bc = y,x text coordinates to print
0412B5             0182*  prt_loop_print:
0412B5 F5          0183*      push af
0412B6 E5          0184*      push hl
0412B7 C5          0185*      push bc
0412B8 D5          0186*      push de
0412B9 DD E5       0187*      push ix
0412BB FD E5       0188*      push iy
0412BD CD C1 13 04 0189*      call vdu_move_cursor
0412C1             0190*  
0412C1 2A DA 12 04 0191*      ld hl,(prt_loop_counter)
0412C5 CD 76 01 04 0192*      call printDec
0412C9             0193*  
0412C9 2A DD 12 04 0194*      ld hl,(prt_loops)
0412CD CD 76 01 04 0195*      call printDec
0412D1             0196*  
0412D1 FD E1       0197*      pop iy
0412D3 DD E1       0198*      pop ix
0412D5 D1          0199*      pop de
0412D6 C1          0200*      pop bc
0412D7 E1          0201*      pop hl
0412D8 F1          0202*      pop af
0412D9 C9          0203*      ret
0412DA             0204*  
0412DA             0205*  prt_loop_counter:
0412DA 00 00 00    0206*      .dl 0
0412DD             0207*  prt_loops:
0412DD 00 00 00    0208*      .dl 0
0412E0             0209*  
0412E0             0210*  ; ===============================================
0412E0             0211*  ; Timer functions
0412E0             0212*  ; -----------------------------------------------
0412E0             0213*  ; set a countdown timer
0412E0             0214*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412E0             0215*  ; returns: hl = current time
0412E0             0216*  tmr_set:
0412E0 FD 2F 03    0217*      ld (iy+3),hl            ; set time remaining
0412E3             0218*      MOSCALL mos_sysvars     ; ix points to syvars table
0412E3 3E 08       0001*M 			LD	A, function
0412E5 5B CF       0002*M 			RST.LIL	08h
0412E7 DD 27 00    0219*      ld hl,(ix+sysvar_time)  ; get current time
0412EA FD 2F 00    0220*      ld (iy+0),hl            ; set start time
0412ED C9          0221*      ret
0412EE             0222*  
0412EE             0223*  ; gets time remaining on a countdown timer
0412EE             0224*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0412EE             0225*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0412EE             0226*  ;          sign flags: pos = time not expired,zero or neg = time expired
0412EE             0227*  tmr_get:
0412EE             0228*      MOSCALL mos_sysvars     ; ix points to syvars table
0412EE 3E 08       0001*M 			LD	A, function
0412F0 5B CF       0002*M 			RST.LIL	08h
0412F2 DD 17 00    0229*      ld de,(ix+sysvar_time)  ; get current time
0412F5 FD 27 00    0230*      ld hl,(iy+0)            ; get start time
0412F8 AF          0231*      xor a                   ; clear carry
0412F9 ED 52       0232*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0412FB FD 17 03    0233*      ld de,(iy+3)            ; get timer set value
0412FE AF          0234*      xor a                   ; clear carry
0412FF ED 5A       0235*      adc hl,de               ; hl = time remaining
041301             0236*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
041301 C9          0237*      ret
041302             0238*  
041302             0239*  tmr_test: ds 6 ; example of a buffer to hold timer data
041308             0240*  
041308 00 00 00    0241*  timestamp_now: dl 0
04130B 00 00 00    0242*  timestamp_old: dl 0
04130E 00 00 00    0243*  timestamp_chg: dl 0
041311             0244*  
041311             0245*  ; update the global timestamp from the system clock
041311             0246*  ; inputs: none
041311             0247*  ; returns: hl = time elapsed in 1/120ths of a second
041311             0248*  ;          ix = pointer to syvars table
041311             0249*  ; destroys: af,hl,de,ix
041311             0250*  timestamp_tick:
041311 ED 5B 08 13 0251*      ld de,(timestamp_now)   ; get previous time
       04          
041316 ED 53 0B 13 0252*      ld (timestamp_old),de   ; save previous time
       04          
04131B             0253*      MOSCALL mos_sysvars     ; ix points to syvars table
04131B 3E 08       0001*M 			LD	A, function
04131D 5B CF       0002*M 			RST.LIL	08h
04131F DD 27 00    0254*      ld hl,(ix+sysvar_time)  ; get current time
041322 22 08 13 04 0255*      ld (timestamp_now),hl   ; save current time
041326 AF          0256*      xor a                   ; clear carry
041327 ED 52       0257*      sbc hl,de               ; hl = time elapsed
041329 22 0E 13 04 0258*      ld (timestamp_chg),hl   ; save elapsed time
04132D C9          0259*      ret
04132E             0260*  
04132E             0261*  ; set a countdown timer
04132E             0262*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04132E             0263*  ; requires: timestamp_tick to be called at least once before this function
04132E             0264*  ; returns: hl = current time
04132E             0265*  ; destroys: hl
04132E             0266*  timestamp_tmr_set:
04132E FD 2F 03    0267*      ld (iy+3),hl            ; set time remaining
041331 2A 08 13 04 0268*      ld hl,(timestamp_now)   ; get current timestamp
041335 FD 2F 00    0269*      ld (iy+0),hl            ; set start time
041338 C9          0270*      ret
041339             0271*  
041339             0272*  ; gets time remaining on a countdown timer following the global timestamp
041339             0273*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041339             0274*  ; requires: timestamp_tick to be called at least once before this function
041339             0275*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041339             0276*  ;          sign flags: pos = time not expired,zero or neg = time expired
041339             0277*  ; destroys: af,hl,de
041339             0278*  timestamp_tmr_get:
041339 ED 5B 08 13 0279*      ld de,(timestamp_now)   ; get current timestamp
       04          
04133E FD 27 00    0280*      ld hl,(iy+0)            ; get start time
041341 AF          0281*      xor a                   ; clear carry
041342 ED 52       0282*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041344 FD 17 03    0283*      ld de,(iy+3)            ; get timer set value
041347 AF          0284*      xor a                   ; clear carry
041348 ED 5A       0285*      adc hl,de               ; hl = time remaining
04134A             0286*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04134A C9          0287*      ret
04134B             0288*  
04134B             0289*  ; set a stopwatch
04134B             0290*  ; returns: hl = start time
04134B             0291*  ; destroys: hl,ix
04134B             0292*  stopwatch_set:
04134B             0293*      MOSCALL mos_sysvars     ; ix points to syvars table
04134B 3E 08       0001*M 			LD	A, function
04134D 5B CF       0002*M 			RST.LIL	08h
04134F DD 27 00    0294*      ld hl,(ix+sysvar_time)  ; get current time
041352 22 67 13 04 0295*      ld (stopwatch_started),hl            ; set start time
041356 C9          0296*      ret
041357             0297*  
041357             0298*  ; gets time elapsed on a stopwatch
041357             0299*  ; returns: hl = time elapsed in 1/120ths of a second
041357             0300*  ; destroys: af,hl,de,ix
041357             0301*  stopwatch_get:
041357             0302*      MOSCALL mos_sysvars     ; ix points to syvars table
041357 3E 08       0001*M 			LD	A, function
041359 5B CF       0002*M 			RST.LIL	08h
04135B DD 27 00    0303*      ld hl,(ix+sysvar_time)  ; get current time
04135E ED 5B 67 13 0304*      ld de,(stopwatch_started)            ; get start time
       04          
041363 AF          0305*      xor a                   ; clear carry
041364 ED 52       0306*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
041366 C9          0307*      ret
041367             0308*  
041367             0309*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
04136A             0310*  
04136A             0311*  ; ------------------
04136A             0312*  ; delay routine
04136A             0313*  ; Author: Richard Turrnidge
04136A             0314*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
04136A             0315*  ; routine waits a fixed time,then returns
04136A             0316*  ; arrive with A =  the delay byte. One bit to be set only.
04136A             0317*  ; eg. ld A,00000100b
04136A             0318*  
04136A             0319*  multiPurposeDelay:
04136A F5          0320*      push af
04136B C5          0321*      push bc
04136C DD E5       0322*      push ix
04136E 47          0323*      ld b,a
04136F 3E 08       0324*      ld a,$08
041371 5B CF       0325*      RST.LIL	08h                 ; get IX pointer to sysvars
041373             0326*  
041373             0327*  waitLoop:
041373             0328*  
041373 DD 7E 00    0329*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
041376             0330*  
041376             0331*                                  ;   we check if bit set is same as last time we checked.
041376             0332*                                  ;   bit 0 - don't use
041376             0333*                                  ;   bit 1 - changes 64 times per second
041376             0334*                                  ;   bit 2 - changes 32 times per second
041376             0335*                                  ;   bit 3 - changes 16 times per second
041376             0336*  
041376             0337*                                  ;   bit 4 - changes 8 times per second
041376             0338*                                  ;   bit 5 - changes 4 times per second
041376             0339*                                  ;   bit 6 - changes 2 times per second
041376             0340*                                  ;   bit 7 - changes 1 times per second
041376 A0          0341*      and b
041377 4F          0342*      ld c,a
041378 3A 89 13 04 0343*      ld a,(oldTimeStamp)
04137C B9          0344*      cp c                        ; is A same as last value?
04137D 28 F4       0345*      jr z,waitLoop              ; loop here if it is
04137F 79          0346*      ld a,c
041380 32 89 13 04 0347*      ld (oldTimeStamp),a        ; set new value
041384             0348*  
041384 DD E1       0349*      pop ix
041386 C1          0350*      pop bc
041387 F1          0351*      pop af
041388 C9          0352*      ret
041389             0353*  
041389 00          0354*  oldTimeStamp:   .db 00h
04138A             0036       include "vdu.inc"
04138A             0001*  
04138A             0002*  ; VDU 30: Home cursor
04138A             0003*  vdu_home_cursor:
04138A 3E 1E       0004*      ld a,30
04138C 5B D7       0005*  	rst.lil $10
04138E C9          0006*  	ret
04138F             0007*  
04138F             0008*  vdu_cursor_on:
04138F 21 9A 13 04 0009*  	ld hl,@cmd
041393 01 03 00 00 0010*  	ld bc,@end-@cmd
041397 5B DF       0011*  	rst.lil $18
041399 C9          0012*  	ret
04139A             0013*  @cmd:
04139A 17 01 01    0014*  	db 23,1,1
04139D             0015*  @end:
04139D             0016*  
04139D             0017*  vdu_cursor_off:
04139D 21 A8 13 04 0018*  	ld hl,@cmd
0413A1 01 03 00 00 0019*  	ld bc,@end-@cmd
0413A5 5B DF       0020*  	rst.lil $18
0413A7 C9          0021*  	ret
0413A8             0022*  @cmd:
0413A8 17 01 00    0023*  	db 23,1,0
0413AB             0024*  @end:
0413AB             0025*  
0413AB             0026*  ; VDU 5: Write text at graphics cursor
0413AB             0027*  ; inputs: a is the character to write to the screen
0413AB             0028*  ; prerequisites: the graphics cursor at the intended position on screen
0413AB             0029*  ; outputs: see the name of the function
0413AB             0030*  ; destroys: a, hl, bc
0413AB             0031*  vdu_char_to_gfx_cursor:
0413AB 32 BB 13 04 0032*  	ld (@arg),a
0413AF 21 BA 13 04 0033*  	ld hl,@cmd
0413B3 01 02 00 00 0034*  	ld bc,@end-@cmd
0413B7 5B DF       0035*  	rst.lil $18
0413B9 C9          0036*  	ret
0413BA 05          0037*  @cmd: db 5
0413BB 00          0038*  @arg: db 0
0413BC             0039*  @end:
0413BC             0040*  ; VDU 9: Move cursor forward one character
0413BC             0041*  vdu_cursor_forward:
0413BC 3E 09       0042*      ld a,9
0413BE 5B D7       0043*  	rst.lil $10
0413C0 C9          0044*  	ret
0413C1             0045*  
0413C1             0046*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0413C1             0047*  ; inputs: c=x, b=y 8-bit unsigned integers
0413C1             0048*  vdu_move_cursor:
0413C1 ED 43 D2 13 0049*      ld (@x0),bc
       04          
0413C6 21 D1 13 04 0050*  	ld hl,@cmd
0413CA 01 03 00 00 0051*  	ld bc,@end-@cmd
0413CE 5B DF       0052*  	rst.lil $18
0413D0 C9          0053*  	ret
0413D1 1F          0054*  @cmd: 	db 31
0413D2 00          0055*  @x0:	db 0
0413D3 00          0056*  @y0: 	db 0
0413D4 00          0057*  @end: 	db 0 ; padding
0413D5             0058*  
0413D5             0059*  ; VDU 12: Clear text area (CLS)
0413D5             0060*  vdu_cls:
0413D5 3E 0C       0061*      ld a,12
0413D7 5B D7       0062*  	rst.lil $10
0413D9 C9          0063*  	ret
0413DA             0064*  
0413DA             0065*  vdu_flip:
0413DA 21 E5 13 04 0066*  	ld hl,@cmd
0413DE 01 03 00 00 0067*  	ld bc,@end-@cmd
0413E2 5B DF       0068*  	rst.lil $18
0413E4 C9          0069*  	ret
0413E5 17 00 C3    0070*  @cmd: db 23,0,0xC3
0413E8             0071*  @end:
0413E8             0072*  
0413E8             0073*  ; VDU 16: Clear graphics area (CLG)
0413E8             0074*  vdu_clg:
0413E8 3E 10       0075*      ld a,16
0413EA 5B D7       0076*  	rst.lil $10
0413EC C9          0077*  	ret
0413ED             0078*  
0413ED             0079*  ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
0413ED             0080*  ; VDU 23, 7: Scrolling
0413ED             0081*  ;     VDU 23, 7, extent, direction, speed: Scroll the screen
0413ED             0082*  ; inputs: a, extent; l, direction; h; speed
0413ED             0083*  vdu_scroll_down:
0413ED 32 02 14 04 0084*  	ld (@extent),a
0413F1 22 03 14 04 0085*  	ld (@dir),hl ; implicitly populates @speed
0413F5 21 00 14 04 0086*  	ld hl,@cmd
0413F9 01 05 00 00 0087*  	ld bc,@end-@cmd
0413FD 5B DF       0088*  	rst.lil $18     ;; Sending command to VDP
0413FF C9          0089*  	ret
041400 17 07       0090*  @cmd:       db 23,7
041402 00          0091*  @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041403 00          0092*  @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
041404 00          0093*  @speed:     db 0x00 ; pixels
041405 00          0094*  @end:		db 0x00 ; padding
041406             0095*  
041406             0096*  ; COLOUR MODES
041406             0097*  ; Mode	Effect
041406             0098*  ; 0	Set on-screen pixel to target colour value
041406             0099*  ; 1	OR value with the on-screen pixel
041406             0100*  ; 2	AND value with the on-screen pixel
041406             0101*  ; 3	XOR value with the on-screen pixel
041406             0102*  ; 4	Invert the on-screen pixel
041406             0103*  ; 5	No operation
041406             0104*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041406             0105*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041406             0106*  
041406             0107*  ; VDU 17, colour: Define text colour (COLOUR)
041406             0108*  vdu_colour_text:
041406 32 16 14 04 0109*  	ld (@arg),a
04140A 21 15 14 04 0110*  	ld hl,@cmd
04140E 01 02 00 00 0111*  	ld bc,@end-@cmd
041412 5B DF       0112*  	rst.lil $18
041414 C9          0113*  	ret
041415 11          0114*  @cmd: db 17
041416 00          0115*  @arg: db 0
041417             0116*  @end:
041417             0117*  
041417             0118*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041417             0119*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041417             0120*  vdu_gcol:
041417 32 2C 14 04 0121*  	ld (@mode),a
04141B 79          0122*      ld a,c
04141C 32 2D 14 04 0123*      ld (@col),a
041420 21 2B 14 04 0124*  	ld hl,@cmd
041424 01 03 00 00 0125*  	ld bc,@end-@cmd
041428 5B DF       0126*  	rst.lil $18
04142A C9          0127*  	ret
04142B 12          0128*  @cmd:  db 18
04142C 00          0129*  @mode: db 0
04142D 00          0130*  @col:  db 0
04142E             0131*  @end:
04142E             0132*  
04142E             0133*  
04142E             0134*  ; VDU 28, left, bottom, right, top: Set text viewport **
04142E             0135*  ; MIND THE LITTLE-ENDIANESS
04142E             0136*  ; inputs: c=left,b=bottom,e=right,d=top
04142E             0137*  ; outputs; nothing
04142E             0138*  ; destroys: a might make it out alive
04142E             0139*  vdu_set_txt_viewport:
04142E ED 43 44 14 0140*      ld (@lb),bc
       04          
041433 ED 53 46 14 0141*  	ld (@rt),de
       04          
041438 21 43 14 04 0142*  	ld hl,@cmd
04143C 01 05 00 00 0143*  	ld bc,@end-@cmd
041440 5B DF       0144*  	rst.lil $18
041442 C9          0145*  	ret
041443 1C          0146*  @cmd:   db 28 ; set text viewport command
041444 00 00       0147*  @lb: 	dw 0x0000 ; set by bc
041446 00 00       0148*  @rt: 	dw 0x0000 ; set by de
041448 00          0149*  @end:   db 0x00	  ; padding
041449             0150*  
041449             0151*  ; Wait for VBLANK interrupt
041449             0152*  vdu_vblank:
041449 DD E5       0153*      PUSH 	IX
04144B             0154*  	MOSCALL	mos_sysvars
04144B 3E 08       0001*M 			LD	A, function
04144D 5B CF       0002*M 			RST.LIL	08h
04144F DD 7E 00    0155*  	LD	A, (IX + sysvar_time + 0)
041452             0156*  @wait:
041452 DD BE 00    0157*      CP 	A, (IX + sysvar_time + 0)
041455 28 FB       0158*      JR	Z, @wait
041457 DD E1       0159*      POP	IX
041459 C9          0160*      RET
04145A             0161*  
04145A             0162*  ; VDU 29, x; y;: Set graphics origin
04145A             0163*  ; This command sets the graphics origin.
04145A             0164*  ; The origin is the point on the screen where the coordinates (0,0) are located.
04145A             0165*  ; inputs: bc=x0,de=y0
04145A             0166*  ; outputs; nothing
04145A             0167*  ; destroys: a might make it out alive
04145A             0168*  vdu_set_gfx_origin:
04145A ED 43 70 14 0169*      ld (@x0),bc
       04          
04145F ED 53 72 14 0170*      ld (@y0),de
       04          
041464 21 6F 14 04 0171*      ld hl,@cmd
041468 01 05 00 00 0172*      ld bc,@end-@cmd
04146C 5B DF       0173*      rst.lil $18
04146E C9          0174*      ret
04146F 1D          0175*  @cmd:   db 29 ; set graphics origin command
041470 00 00       0176*  @x0: 	dw 0x0000 ; set by bc
041472 00 00       0177*  @y0: 	dw 0x0000 ; set by de
041474 00          0178*  @end:   db 0x00	  ; padding
041475             0179*  
041475             0180*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041475             0181*  ; NOTE: the order of the y-coordinate parameters are inverted
041475             0182*  ; 	because we have turned off logical screen scaling
041475             0183*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041475             0184*  ; outputs; nothing
041475             0185*  ; destroys: a might make it out alive
041475             0186*  vdu_set_gfx_viewport:
041475 ED 43 95 14 0187*      ld (@x0),bc
       04          
04147A FD 22 97 14 0188*      ld (@y1),iy
       04          
04147F DD 22 99 14 0189*  	ld (@x1),ix
       04          
041484 ED 53 9B 14 0190*  	ld (@y0),de
       04          
041489 21 94 14 04 0191*  	ld hl,@cmd
04148D 01 09 00 00 0192*  	ld bc,@end-@cmd
041491 5B DF       0193*  	rst.lil $18
041493 C9          0194*  	ret
041494 18          0195*  @cmd:   db 24 ; set graphics viewport command
041495 00 00       0196*  @x0: 	dw 0x0000 ; set by bc
041497 00 00       0197*  @y1: 	dw 0x0000 ; set by iy
041499 00 00       0198*  @x1: 	dw 0x0000 ; set by ix
04149B 00 00       0199*  @y0: 	dw 0x0000 ; set by de
04149D 00          0200*  @end:   db 0x00	  ; padding
04149E             0201*  
04149E             0202*  ; SCREEN MODES
04149E             0203*  ; ===============================
04149E             0204*  ; Mode  Horz  Vert  Cols  Refresh
04149E             0205*  ; ---   ----  ----  ----  -------
04149E             0206*  ; 11    320   240   2     60hz
04149E             0207*  ; 139   320   240   2     60hz
04149E             0208*  ; 23    512   384   2     60hz
04149E             0209*  ; 151   512   384   2     60hz
04149E             0210*  ; 6     640   240   2     60hz
04149E             0211*  ; 134   640   240   2     60hz
04149E             0212*  ; 2     640   480   2     60hz
04149E             0213*  ; 130   640   480   2     60hz
04149E             0214*  ; 17    800   600   2     60hz
04149E             0215*  ; 145   800   600   2     60hz
04149E             0216*  ; 18    1024  768   2     60hz
04149E             0217*  ; 146   1024  768   2     60hz
04149E             0218*  ; ---   ----  ----  ----  -------
04149E             0219*  ; 10    320   240   4     60hz
04149E             0220*  ; 138   320   240   4     60hz
04149E             0221*  ; 22    512   384   4     60hz
04149E             0222*  ; 150   512   384   4     60hz
04149E             0223*  ; 5     640   240   4     60hz
04149E             0224*  ; 133   640   240   4     60hz
04149E             0225*  ; 1     640   480   4     60hz
04149E             0226*  ; 129   640   480   4     60hz
04149E             0227*  ; 16    800   600   4     60hz
04149E             0228*  ; 19    1024  768   4     60hz
04149E             0229*  ; ---   ----  ----  ----  -------
04149E             0230*  ; 9     320   240   16    60hz
04149E             0231*  ; 137   320   240   16    60hz
04149E             0232*  ; 21    512   384   16    60hz
04149E             0233*  ; 149   512   384   16    60hz
04149E             0234*  ; 4     640   240   16    60hz
04149E             0235*  ; 132   640   240   16    60hz
04149E             0236*  ; 0     640   480   16    60hz
04149E             0237*  ; 7     n/a   n/a   16    60hz
04149E             0238*  ; ---   ----  ----  ----  -------
04149E             0239*  ; 8     320   240   64    60hz
04149E             0240*  ; 136   320   240   64    60hz
04149E             0241*  ; 20    512   384   64    60hz
04149E             0242*  ; 3     640   240   64    60hz
04149E             0243*  ; ---   ----  ----  ----  -------
04149E             0244*  vdu_set_screen_mode:
04149E 32 AE 14 04 0245*  	ld (@arg),a
0414A2 21 AD 14 04 0246*  	ld hl,@cmd
0414A6 01 02 00 00 0247*  	ld bc,@end-@cmd
0414AA 5B DF       0248*  	rst.lil $18
0414AC C9          0249*  	ret
0414AD 16          0250*  @cmd: db 22 ; set screen mode
0414AE 00          0251*  @arg: db 0  ; screen mode parameter
0414AF             0252*  @end:
0414AF             0253*  
0414AF             0254*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0414AF             0255*  ; inputs: a is scaling mode, 1=on, 0=off
0414AF             0256*  ; note: default setting on boot is scaling ON
0414AF             0257*  vdu_set_scaling:
0414AF 32 C1 14 04 0258*  	ld (@arg),a
0414B3 21 BE 14 04 0259*  	ld hl,@cmd
0414B7 01 04 00 00 0260*  	ld bc,@end-@cmd
0414BB 5B DF       0261*  	rst.lil $18
0414BD C9          0262*  	ret
0414BE 17 00 C0    0263*  @cmd: db 23,0,0xC0
0414C1 00          0264*  @arg: db 0  ; scaling on/off
0414C2             0265*  @end:
0414C2             0266*  
0414C2             0267*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0414C2             0268*  ; inputs: hl=bufferId
0414C2             0269*  vdu_buff_select:
0414C2 22 D4 14 04 0270*  	ld (@bufferId),hl
0414C6 21 D1 14 04 0271*  	ld hl,@cmd
0414CA 01 05 00 00 0272*  	ld bc,@end-@cmd
0414CE 5B DF       0273*  	rst.lil $18
0414D0 C9          0274*  	ret
0414D1 17 1B 20    0275*  @cmd: db 23,27,0x20
0414D4 00 00       0276*  @bufferId: dw 0x0000
0414D6 00          0277*  @end: db 0x00 ; padding
0414D7             0278*  
0414D7             0279*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0414D7             0280*  ; inputs: a=format; bc=width; de=height
0414D7             0281*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0414D7             0282*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0414D7             0283*  ; 0 	RGBA8888 (4-bytes per pixel)
0414D7             0284*  ; 1 	RGBA2222 (1-bytes per pixel)
0414D7             0285*  ; 2 	Mono/Mask (1-bit per pixel)
0414D7             0286*  ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
0414D7             0287*  vdu_bmp_create:
0414D7 ED 43 F3 14 0288*      ld (@width),bc
       04          
0414DC ED 53 F5 14 0289*      ld (@height),de
       04          
0414E1 32 F7 14 04 0290*      ld (@fmt),a
0414E5 21 F0 14 04 0291*  	ld hl,@cmd
0414E9 01 08 00 00 0292*  	ld bc,@end-@cmd
0414ED 5B DF       0293*  	rst.lil $18
0414EF C9          0294*  	ret
0414F0 17 1B 21    0295*  @cmd:       db 23,27,0x21
0414F3 00 00       0296*  @width:     dw 0x0000
0414F5 00 00       0297*  @height:    dw 0x0000
0414F7 00          0298*  @fmt:       db 0x00
0414F8             0299*  @end:
0414F8             0300*  
0414F8             0301*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0414F8             0302*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0414F8             0303*  vdu_load_img_rgba2_to_8:
0414F8             0304*  ; backup the target buffer id and image dimensions
0414F8 E5          0305*      push hl
0414F9 D5          0306*      push de
0414FA C5          0307*      push bc
0414FB             0308*  ; load the rgba2 image to working buffer 65534
0414FB 21 FE FF 00 0309*      ld hl,65534 ; temporary working buffer id
0414FF CD 02 16 04 0310*  	call vdu_load_buffer_from_file
041503             0311*  ; restore the image dimensions and target buffer id
041503 C1          0312*      pop bc
041504 D1          0313*      pop de
041505 E1          0314*      pop hl
041506             0315*  ; fall through to vdu_rgba2_to_8
041506             0316*  
041506             0317*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041506             0318*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041506             0319*  ; the "expand bitmap" command is:
041506             0320*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041506             0321*  ; and then to reverse the byte order to fix endian-ness:
041506             0322*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041506             0323*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041506             0324*  ; VDU 23,27,&20,targetBufferID%;
041506             0325*  ; VDU 23,27,&21,width%;height%;0
041506             0326*  ; -------------------------------------------------------------------
041506             0327*  ; inputs: bc,de image width,height ; hl = targetBufferId
041506             0328*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041506             0329*  vdu_rgba2_to_8:
041506             0330*  ; load the image dimensions and buffer id parameters
041506 ED 43 62 15 0331*      ld (@width),bc
       04          
04150B ED 53 64 15 0332*      ld (@height),de
       04          
041510 22 47 15 04 0333*      ld (@bufferId0),hl
041514 22 54 15 04 0334*      ld (@bufferId2),hl
041518 22 5D 15 04 0335*      ld (@bufferId1),hl
04151C             0336*  ; clean up bytes that got stomped on by the ID loads
04151C 3E 48       0337*      ld a,0x48
04151E 32 49 15 04 0338*      ld (@bufferId0+2),a
041522 3E 17       0339*      ld a,23
041524 32 5F 15 04 0340*      ld (@bufferId1+2),a
041528 3E 18       0341*      ld a,24
04152A 32 56 15 04 0342*      ld (@bufferId2+2),a
04152E AF          0343*      xor a
04152F 32 66 15 04 0344*      ld (@height+2),a
041533             0345*  ; send the vdu command strings
041533 21 3E 15 04 0346*      ld hl,@beg
041537 01 29 00 00 0347*      ld bc,@end-@beg
04153B 5B DF       0348*      rst.lil $18
04153D C9          0349*      ret
04153E             0350*  @beg:
04153E             0351*  ; Command 14: Consolidate blocks in a buffer
04153E             0352*  ; VDU 23, 0, &A0, bufferId; 14
04153E 17 00 A0    0353*      db 23,0,0xA0
041541 FE FF       0354*      dw 65534 ; workingBufferId
041543 0E          0355*      db 14 ; consolidate blocks
041544             0356*  ; the "expand bitmap" command is:
041544             0357*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041544 17 00 A0    0358*      db 23,0,0xA0
041547 00 00       0359*  @bufferId0: dw 0x0000 ; targetBufferId
041549 48          0360*      db 0x48 ; given as decimal command 72 in the docs
04154A 02          0361*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
04154B FE FF       0362*      dw 65534 ; sourceBufferId
04154D 00 7F BF FF 0363*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
041551             0364*  ; reverse the byte order to fix endian-ness:
041551             0365*  ; Command 24: Reverse the order of data of blocks within a buffer
041551             0366*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
041551             0367*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041551 17 00 A0    0368*      db 23,0,0xA0
041554 00 00       0369*  @bufferId2:    dw 0x0000 ; targetBufferId
041556 18          0370*      db 24 ; reverse byte order
041557 04          0371*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041558 04 00       0372*      dw 4 ; size (4 bytes)
04155A             0373*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04155A             0374*  ; VDU 23,27,&20,targetBufferID%;
04155A 17 1B 20    0375*      db 23,27,0x20 ; select bitmap
04155D 00 00       0376*  @bufferId1: dw 0x0000 ; targetBufferId
04155F             0377*  ; VDU 23,27,&21,width%;height%;0
04155F 17 1B 21    0378*      db 23,27,0x21 ; create bitmap from buffer
041562 00 00       0379*  @width: dw 0x0000
041564 00 00       0380*  @height: dw 0x0000
041566 00          0381*      db 0x00 ; rgba8888 format
041567             0382*  @end:
041567             0383*  
041567             0384*  ; scratch variables
041567 00 00 00    0385*  bufferId0: dl 0x000000
04156A 00 00 00    0386*  bufferId1: dl 0x000000
04156D             0387*  
04156D             0388*  ; load a vdu buffer from local memory
04156D             0389*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04156D             0390*  vdu_load_buffer:
04156D ED 43 96 15 0391*      ld (@length),bc
       04          
041572 D5          0392*      push de ; save data pointer
041573             0393*  ; send the vdu command string
041573 7D          0394*      ld a,l
041574 32 93 15 04 0395*      ld (@bufferId),a
041578 7C          0396*      ld a,h
041579 32 94 15 04 0397*      ld (@bufferId+1),a
04157D 21 90 15 04 0398*      ld hl,@cmd
041581 01 08 00 00 0399*      ld bc,@end-@cmd
041585 5B DF       0400*      rst.lil $18
041587             0401*  ; send the buffer data
041587 E1          0402*      pop hl ; pointer to data
041588 ED 4B 96 15 0403*      ld bc,(@length)
       04          
04158D 5B DF       0404*      rst.lil $18 ; send it
04158F C9          0405*      ret
041590             0406*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041590 17 00 A0    0407*  @cmd:       db 23,0,0xA0
041593 00 00       0408*  @bufferId:	dw 0x0000
041595 00          0409*  		    db 0 ; load buffer
041596 00 00       0410*  @length:	dw 0x0000
041598 00          0411*  @end: db 0 ; padding
041599             0412*  
041599             0413*  ; clear a buffer
041599             0414*  ; inputs: hl = bufferId
041599             0415*  vdu_clear_buffer:
041599 7D          0416*      ld a,l
04159A 32 B1 15 04 0417*      ld (@bufferId),a
04159E 7C          0418*      ld a,h
04159F 32 B2 15 04 0419*      ld (@bufferId+1),a
0415A3 21 AE 15 04 0420*      ld hl,@cmd
0415A7 01 06 00 00 0421*      ld bc,@end-@cmd
0415AB 5B DF       0422*      rst.lil $18
0415AD C9          0423*      ret
0415AE 17 00 A0    0424*  @cmd:       db 23,0,0xA0
0415B1 00 00       0425*  @bufferId:	dw 0x0000
0415B3 02          0426*  		    db 2 ; clear buffer
0415B4             0427*  @end:
0415B4             0428*  
0415B4             0429*  vdu_clear_all_buffers:
0415B4             0430*  ; clear all buffers
0415B4 21 BF 15 04 0431*      ld hl,@beg
0415B8 01 06 00 00 0432*      ld bc,@end-@beg
0415BC 5B DF       0433*      rst.lil $18
0415BE C9          0434*      ret
0415BF 17 00 A0    0435*  @beg: db 23,0,$A0
0415C2 FF FF       0436*        dw -1 ; clear all buffers
0415C4 02          0437*        db 2  ; command 2: clear a buffer
0415C5             0438*  @end:
0415C5             0439*  
0415C5             0440*  ; Command 14: Consolidate blocks in a buffer
0415C5             0441*  vdu_consolidate_buffer:
0415C5             0442*  ; set parameters for vdu call
0415C5 7D          0443*      ld a,l
0415C6 32 DD 15 04 0444*      ld (@bufferId),a
0415CA 7C          0445*      ld a,h
0415CB 32 DE 15 04 0446*      ld (@bufferId+1),a
0415CF 21 DA 15 04 0447*      ld hl,@beg
0415D3 01 06 00 00 0448*      ld bc,@end-@beg
0415D7 5B DF       0449*      rst.lil $18
0415D9 C9          0450*      ret
0415DA             0451*  ; VDU 23, 0, &A0, bufferId; 14
0415DA 17 00 A0    0452*  @beg: db 23,0,0xA0
0415DD 00 00       0453*  @bufferId: dw 0x0000
0415DF 0E          0454*             db 14
0415E0             0455*  @end:
0415E0             0456*  
0415E0             0457*  ; load an image file to a buffer and make it a bitmap
0415E0             0458*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0415E0             0459*  vdu_load_img:
0415E0             0460*  ; back up image type and dimension parameters
0415E0 22 67 15 04 0461*      ld (bufferId0),hl
0415E4 F5          0462*      push af
0415E5 C5          0463*  	push bc
0415E6 D5          0464*  	push de
0415E7             0465*  ; load the image
0415E7 CD 02 16 04 0466*  	call vdu_load_buffer_from_file
0415EB             0467*  ; now make it a bitmap
0415EB 2A 67 15 04 0468*      ld hl,(bufferId0)
0415EF CD C5 15 04 0469*      call vdu_consolidate_buffer
0415F3 2A 67 15 04 0470*      ld hl,(bufferId0)
0415F7 CD C2 14 04 0471*      call vdu_buff_select
0415FB D1          0472*  	pop de ; image height
0415FC C1          0473*  	pop bc ; image width
0415FD F1          0474*  	pop af ; image type
0415FE C3 D7 14 04 0475*  	jp vdu_bmp_create ; will return to caller from there
041602             0476*  
041602             0477*  ; inputs: hl = bufferId; iy = pointer to filename
041602             0478*  vdu_load_buffer_from_file:
041602 22 67 15 04 0479*      ld (bufferId0),hl
041606             0480*  
041606             0481*  ; clear target buffer
041606 CD 99 15 04 0482*      call vdu_clear_buffer
04160A             0483*  
04160A             0484*  ; open the file in read mode
04160A             0485*  ; Open a file
04160A             0486*  ; HLU: Filename
04160A             0487*  ;   C: Mode
04160A             0488*  ; Returns:
04160A             0489*  ;   A: Filehandle, or 0 if couldn't open
04160A FD E5       0490*  	push iy ; pointer to filename
04160C E1          0491*  	pop hl
04160D 0E 01       0492*  	ld c,fa_read
04160F             0493*      MOSCALL mos_fopen
04160F 3E 0A       0001*M 			LD	A, function
041611 5B CF       0002*M 			RST.LIL	08h
041613 32 4E 16 04 0494*      ld (@filehandle),a
041617             0495*  
041617             0496*  @read_file:
041617             0497*  ; Read a block of data from a file
041617             0498*  ;   C: Filehandle
041617             0499*  ; HLU: Pointer to where to write the data to
041617             0500*  ; DEU: Number of bytes to read
041617             0501*  ; Returns:
041617             0502*  ; DEU: Number of bytes read
041617 3A 4E 16 04 0503*      ld a,(@filehandle)
04161B 4F          0504*      ld c,a
04161C 21 00 E0 B7 0505*      ld hl,filedata
041620 11 00 20 00 0506*      ld de,8192 ; max we can read into onboard sram at one time
041624             0507*      MOSCALL mos_fread
041624 3E 1A       0001*M 			LD	A, function
041626 5B CF       0002*M 			RST.LIL	08h
041628             0508*  
041628             0509*  ; test de for zero bytes read
041628 21 00 00 00 0510*      ld hl,0
04162C AF          0511*      xor a ; clear carry
04162D ED 52       0512*      sbc hl,de
04162F CA 45 16 04 0513*      jp z,@close_file
041633             0514*  
041633             0515*  ; load a vdu buffer from local memory
041633             0516*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041633 2A 67 15 04 0517*      ld hl,(bufferId0)
041637 D5          0518*      push de ; chunksize
041638 C1          0519*      pop bc
041639 11 00 E0 B7 0520*      ld de,filedata
04163D CD 6D 15 04 0521*      call vdu_load_buffer
041641             0522*  
041641             0523*  ; read the next block
041641 C3 17 16 04 0524*      jp @read_file
041645             0525*  
041645             0526*  ; close the file
041645             0527*  @close_file:
041645 3A 4E 16 04 0528*      ld a,(@filehandle)
041649             0529*      MOSCALL mos_fclose
041649 3E 0B       0001*M 			LD	A, function
04164B 5B CF       0002*M 			RST.LIL	08h
04164D C9          0530*      ret ; vdu_load_buffer_from_file
04164E             0531*  
04164E 00          0532*  @filehandle: db 0 ; file handle
04164F 00 00 00    0533*  @fil: dl 0 ; pointer to FIL struct
041652             0534*  
041652 00 00 00    0535*  @chunkpointer: dl 0 ; pointer to current chunk
041655             0536*  
041655             0537*  ; File information structure (FILINFO)
041655             0538*  @filinfo:
041655 00 00 00 00 0539*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041659 00 00       0540*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
04165B 00 00       0541*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
04165D 00          0542*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
04165E 00 00 00 00 0543*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
04166B 00 00 00 00 0544*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04176B             0037       include "vdu_fonts.inc"
04176B             0001*  ; select font
04176B             0002*  ; inputs: hl = bufferId, a = font flags
04176B             0003*  ; Flags:
04176B             0004*  ; Bit	Description
04176B             0005*  ; 0	Adjust cursor position to ensure text baseline is aligned
04176B             0006*  ;   0: Do not adjust cursor position (best for changing font on a new line)
04176B             0007*  ;   1: Adjust cursor position (best for changing font in the middle of a line)
04176B             0008*  ; 1-7	Reserved for future use
04176B             0009*  ; VDU 23, 0, &95, 0, bufferId; flags: Select font
04176B             0010*  vdu_font_select:
04176B 22 82 17 04 0011*      ld (@bufferId),hl
04176F 32 84 17 04 0012*      ld (@flags),a
041773 21 7E 17 04 0013*      ld hl,@cmd
041777 01 07 00 00 0014*      ld bc,@end-@cmd
04177B 5B DF       0015*      rst.lil $18
04177D C9          0016*      ret
04177E 17 00 95 00 0017*  @cmd: db 23, 0, 0x95, 0
041782 00 00       0018*  @bufferId: dw 0x0000
041784 00          0019*  @flags: db 0x00
041785             0020*  @end:
041785             0021*  
041785             0022*  ; create font from buffer
041785             0023*  ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
041785             0024*  ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
041785             0025*  vdu_font_create:
041785 22 AA 17 04 0026*      ld (@bufferId),hl
041789 ED 53 AC 17 0027*      ld (@width),de ; also loads height
       04          
04178E 32 AF 17 04 0028*      ld (@flags),a
041792 7A          0029*      ld a,d ; height
041793 32 AE 17 04 0030*      ld (@ascent),a ; ascent = height
041797             0031*  ; consolidate buffer
041797 CD C5 15 04 0032*      call vdu_consolidate_buffer
04179B             0033*  ; create font
04179B 21 A6 17 04 0034*      ld hl,@cmd
04179F 01 0A 00 00 0035*      ld bc,@end-@cmd
0417A3 5B DF       0036*      rst.lil $18
0417A5 C9          0037*      ret
0417A6 17 00 95 01 0038*  @cmd: db 23, 0, 0x95, 1
0417AA 00 00       0039*  @bufferId: dw 0x0000
0417AC 00          0040*  @width: db 0x00
0417AD 00          0041*  @height: db 0x00
0417AE 00          0042*  @ascent: db 0x00
0417AF 00          0043*  @flags: db 0x00
0417B0             0044*  @end:
0417B0             0045*  
0417B0             0046*  ; set or adjust font property
0417B0             0047*  ; inputs: hl = bufferId, a = field, de = value
0417B0             0048*  ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
0417B0             0049*  vdu_font_property:
0417B0 22 CC 17 04 0050*      ld (@bufferId),hl
0417B4 32 CE 17 04 0051*      ld (@field),a
0417B8 ED 53 CF 17 0052*      ld (@value),de
       04          
0417BD 21 C8 17 04 0053*      ld hl,@cmd
0417C1 01 09 00 00 0054*      ld bc,@end-@cmd
0417C5 5B DF       0055*      rst.lil $18
0417C7 C9          0056*      ret
0417C8 17 00 95 02 0057*  @cmd: db 23, 0, 0x95, 2
0417CC 00 00       0058*  @bufferId: dw 0x0000
0417CE 00          0059*  @field: db 0x00
0417CF 00 00       0060*  @value: dw 0x0000
0417D1 00          0061*  @end: db 0x00 ; padding
0417D2             0062*  
0417D2             0063*  ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
0417D2             0064*  
0417D2             0065*  ; Clear/Delete font
0417D2             0066*  ; inputs: hl = bufferId
0417D2             0067*  ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
0417D2             0068*  vdu_font_clear:
0417D2 22 E5 17 04 0069*      ld (@bufferId),hl
0417D6 21 E1 17 04 0070*      ld hl,@cmd
0417DA 01 06 00 00 0071*      ld bc,@end-@cmd
0417DE 5B DF       0072*      rst.lil $18
0417E0 C9          0073*      ret
0417E1 17 00 95 04 0074*  @cmd: db 23, 0, 0x95, 4
0417E5 00 00       0075*  @bufferId: dw 0x0000
0417E7 00          0076*  @end: db 0x00 ; padding
0417E8             0077*  
0417E8             0078*  ; Copy system font to buffer
0417E8             0079*  ; inputs: hl = bufferId
0417E8             0080*  ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
0417E8             0081*  vdu_font_copy_system:
0417E8 22 FB 17 04 0082*      ld (@bufferId),hl
0417EC 21 F7 17 04 0083*      ld hl,@cmd
0417F0 01 06 00 00 0084*      ld bc,@end-@cmd
0417F4 5B DF       0085*      rst.lil $18
0417F6 C9          0086*      ret
0417F7 17 00 95 05 0087*  @cmd: db 23, 0, 0x95, 5
0417FB 00 00       0088*  @bufferId: dw 0x0000
0417FD 00          0089*  @end: db 0x00 ; padding
0417FE             0038       include "vdu_plot.inc"
0417FE             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0417FE             0002*  ; PLOT code 	(Decimal) 	Effect
0417FE             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0417FE             0004*  plot_sl_both: equ 0x00
0417FE             0005*  
0417FE             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0417FE             0007*  plot_sl_first: equ 0x08
0417FE             0008*  
0417FE             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0417FE             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0417FE             0011*  
0417FE             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0417FE             0013*  plot_sl_last: equ 0x20
0417FE             0014*  
0417FE             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0417FE             0016*  plot_sl_none: equ 0x28
0417FE             0017*  
0417FE             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0417FE             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0417FE             0020*  
0417FE             0021*  ; &40-&47 	64-71 	Point plot
0417FE             0022*  plot_pt: equ 0x40
0417FE             0023*  
0417FE             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
0417FE             0025*  plot_lf_lr_non_bg: equ 0x48
0417FE             0026*  
0417FE             0027*  ; &50-&57 	80-87 	Triangle fill
0417FE             0028*  plot_tf: equ 0x50
0417FE             0029*  
0417FE             0030*  ; &58-&5F 	88-95 	Line fill right to background Â§Â§
0417FE             0031*  plot_lf_r_bg: equ 0x58
0417FE             0032*  
0417FE             0033*  ; &60-&67 	96-103 	Rectangle fill
0417FE             0034*  plot_rf: equ 0x60
0417FE             0035*  
0417FE             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
0417FE             0037*  plot_lf_lr_fg: equ 0x60
0417FE             0038*  
0417FE             0039*  ; &70-&77 	112-119 	Parallelogram fill
0417FE             0040*  plot_pf: equ 0x70
0417FE             0041*  
0417FE             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
0417FE             0043*  plot_lf_r_non_fg: equ 0x78
0417FE             0044*  
0417FE             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0417FE             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0417FE             0047*  
0417FE             0048*  ; &90-&97 	144-151 	Circle outline
0417FE             0049*  plot_co: equ 0x90
0417FE             0050*  
0417FE             0051*  ; &98-&9F 	152-159 	Circle fill
0417FE             0052*  plot_cf: equ 0x98
0417FE             0053*  
0417FE             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0417FE             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0417FE             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0417FE             0057*  
0417FE             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0417FE             0059*  plot_rcm: equ 0xB8
0417FE             0060*  
0417FE             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0417FE             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0417FE             0063*  ; &D0-&D7 	208-215 	Not defined
0417FE             0064*  ; &D8-&DF 	216-223 	Not defined
0417FE             0065*  ; &E0-&E7 	224-231 	Not defined
0417FE             0066*  
0417FE             0067*  ; &E8-&EF 	232-239 	Bitmap plot Â§
0417FE             0068*  plot_bmp: equ 0xE8
0417FE             0069*  
0417FE             0070*  ; &F0-&F7 	240-247 	Not defined
0417FE             0071*  ; &F8-&FF 	248-255 	Not defined
0417FE             0072*  
0417FE             0073*  ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
0417FE             0074*  ; Agon Console8 VDP 2.2.0
0417FE             0075*  
0417FE             0076*  ; Within each group of eight plot codes, the effects are as follows:
0417FE             0077*  ; Plot code 	Effect
0417FE             0078*  ; 0 	Move relative
0417FE             0079*  mv_rel: equ 0
0417FE             0080*  
0417FE             0081*  ; 1 	Plot relative in current foreground colour
0417FE             0082*  dr_rel_fg: equ 1
0417FE             0083*  
0417FE             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0417FE             0085*  ; 3 	Plot relative in current background colour
0417FE             0086*  dr_rel_bg: equ 3
0417FE             0087*  
0417FE             0088*  ; 4 	Move absolute
0417FE             0089*  mv_abs: equ 4
0417FE             0090*  
0417FE             0091*  ; 5 	Plot absolute in current foreground colour
0417FE             0092*  dr_abs_fg: equ 5
0417FE             0093*  
0417FE             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0417FE             0095*  ; 7 	Plot absolute in current background colour
0417FE             0096*  dr_abs_bg: equ 7
0417FE             0097*  
0417FE             0098*  ; Codes 0-3 use the position data provided as part of the command
0417FE             0099*  ; as a relative position, adding the position given to the current
0417FE             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0417FE             0101*  ; as part of the command as an absolute position, setting the current
0417FE             0102*  ; graphical cursor position to the position given.
0417FE             0103*  
0417FE             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0417FE             0105*  ; current pixel colour. These operations cannot currently be supported
0417FE             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0417FE             0107*  ; supported. Support for these codes may be added in a future version
0417FE             0108*  ; of the VDP firmware.
0417FE             0109*  
0417FE             0110*  ; 16 colour palette constants
0417FE             0111*  c_black: equ 0
0417FE             0112*  c_red_dk: equ 1
0417FE             0113*  c_green_dk: equ 2
0417FE             0114*  c_yellow_dk: equ 3
0417FE             0115*  c_blue_dk: equ 4
0417FE             0116*  c_magenta_dk: equ 5
0417FE             0117*  c_cyan_dk: equ 6
0417FE             0118*  c_grey: equ 7
0417FE             0119*  c_grey_dk: equ 8
0417FE             0120*  c_red: equ 9
0417FE             0121*  c_green: equ 10
0417FE             0122*  c_yellow: equ 11
0417FE             0123*  c_blue: equ 12
0417FE             0124*  c_magenta: equ 13
0417FE             0125*  c_cyan: equ 14
0417FE             0126*  c_white: equ 15
0417FE             0127*  
0417FE             0128*  ; VDU 25, mode, x; y;: PLOT command
0417FE             0129*  ; inputs: a=mode, bc=x0, de=y0
0417FE             0130*  vdu_plot:
0417FE 32 18 18 04 0131*      ld (@mode),a
041802 ED 43 19 18 0132*      ld (@x0),bc
       04          
041807 ED 53 1B 18 0133*      ld (@y0),de
       04          
04180C 21 17 18 04 0134*  	ld hl,@cmd
041810 01 06 00 00 0135*  	ld bc,@end-@cmd
041814 5B DF       0136*  	rst.lil $18
041816 C9          0137*  	ret
041817 19          0138*  @cmd:   db 25
041818 00          0139*  @mode:  db 0
041819 00 00       0140*  @x0: 	dw 0
04181B 00 00       0141*  @y0: 	dw 0
04181D 00          0142*  @end:   db 0 ; extra byte to soak up deu
04181E             0143*  
04181E             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04181E             0145*  ; &E8-&EF 	232-239 	Bitmap plot Â§
04181E             0146*  ; VDU 25, mode, x; y;: PLOT command
04181E             0147*  ; inputs: bc=x0, de=y0
04181E             0148*  ; prerequisites: vdu_buff_select
04181E             0149*  vdu_plot_bmp:
04181E ED 43 35 18 0150*      ld (@x0),bc
       04          
041823 ED 53 37 18 0151*      ld (@y0),de
       04          
041828 21 33 18 04 0152*  	ld hl,@cmd
04182C 01 06 00 00 0153*  	ld bc,@end-@cmd
041830 5B DF       0154*  	rst.lil $18
041832 C9          0155*  	ret
041833 19          0156*  @cmd:   db 25
041834 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041835 00 00       0158*  @x0: 	dw 0x0000
041837 00 00       0159*  @y0: 	dw 0x0000
041839 00          0160*  @end:   db 0x00 ; padding
04183A             0161*  
04183A             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04183A             0163*  ; &E8-&EF 	232-239 	Bitmap plot Â§
04183A             0164*  ; VDU 25, mode, x; y;: PLOT command
04183A             0165*  ; inputs: bc=x0, de=y0
04183A             0166*  ; USING 16.8 FIXED POINT COORDINATES
04183A             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
04183A             0168*  ;   the fractional portiion of the inputs are truncated
04183A             0169*  ;   leaving only the 16-bit integer portion
04183A             0170*  ; prerequisites: vdu_buff_select
04183A             0171*  vdu_plot_bmp168:
04183A             0172*  ; populate in the reverse of normal to keep the
04183A             0173*  ; inputs from stomping on each other
04183A ED 53 58 18 0174*      ld (@y0-1),de
       04          
04183F ED 43 56 18 0175*      ld (@x0-1),bc
       04          
041844 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
041846 32 56 18 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
04184A 21 55 18 04 0178*  	ld hl,@cmd
04184E 01 06 00 00 0179*  	ld bc,@end-@cmd
041852 5B DF       0180*  	rst.lil $18
041854 C9          0181*  	ret
041855 19          0182*  @cmd:   db 25
041856 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041857 00 00       0184*  @x0: 	dw 0x0000
041859 00 00       0185*  @y0: 	dw 0x0000
04185B             0186*  @end:  ; no padding required b/c we shifted de right
04185B             0187*  
04185B             0188*  ; draw a filled rectangle
04185B             0189*  vdu_plot_rf:
04185B ED 43 82 18 0190*      ld (@x0),bc
       04          
041860 ED 53 84 18 0191*      ld (@y0),de
       04          
041865 DD 22 88 18 0192*      ld (@x1),ix
       04          
04186A FD 22 8A 18 0193*      ld (@y1),iy
       04          
04186F 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041871 32 86 18 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041875 21 80 18 04 0196*  	ld hl,@cmd0
041879 01 0C 00 00 0197*  	ld bc,@end-@cmd0
04187D 5B DF       0198*  	rst.lil $18
04187F C9          0199*      ret
041880 19          0200*  @cmd0:  db 25 ; plot
041881 04          0201*  @arg0:  db plot_sl_both+mv_abs
041882 00 00       0202*  @x0:    dw 0x0000
041884 00 00       0203*  @y0:    dw 0x0000
041886 19          0204*  @cmd1:  db 25 ; plot
041887 65          0205*  @arg1:  db plot_rf+dr_abs_fg
041888 00 00       0206*  @x1:    dw 0x0000
04188A 00 00       0207*  @y1:    dw 0x0000
04188C 00          0208*  @end:   db 0x00 ; padding
04188D             0209*  
04188D             0210*  ; draw a filled circle
04188D             0211*  vdu_plot_cf:
04188D ED 43 B4 18 0212*      ld (@x0),bc
       04          
041892 ED 53 B6 18 0213*      ld (@y0),de
       04          
041897 DD 22 BA 18 0214*      ld (@x1),ix
       04          
04189C FD 22 BC 18 0215*      ld (@y1),iy
       04          
0418A1 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0418A3 32 B8 18 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0418A7 21 B2 18 04 0218*  	ld hl,@cmd0
0418AB 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0418AF 5B DF       0220*  	rst.lil $18
0418B1 C9          0221*      ret
0418B2 19          0222*  @cmd0:  db 25 ; plot
0418B3 04          0223*  @arg0:  db plot_sl_both+mv_abs
0418B4 00 00       0224*  @x0:    dw 0x0000
0418B6 00 00       0225*  @y0:    dw 0x0000
0418B8 19          0226*  @cmd1:  db 25 ; plot
0418B9 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0418BA 00 00       0228*  @x1:    dw 0x0000
0418BC 00 00       0229*  @y1:    dw 0x0000
0418BE 00          0230*  @end:   db 0x00 ; padding
0418BF             0039       include "vdu_sprites.inc"
0418BF             0001*  ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
0418BF             0002*  ; the VDP can support up to 256 sprites. They must be defined
0418BF             0003*  ; contiguously, and so the first sprite is sprite 0.
0418BF             0004*  ; (In contrast, bitmaps can have any ID from 0 to 65534.)
0418BF             0005*  ; Once a selection of sprites have been defined, you can activate
0418BF             0006*  ; them using the VDU 23, 27, 7, n command, where n is the number
0418BF             0007*  ; of sprites to activate. This will activate the first n sprites,
0418BF             0008*  ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
0418BF             0009*  
0418BF             0010*  ; A single sprite can have multiple "frames", referring to
0418BF             0011*  ; different bitmaps.
0418BF             0012*  ; (These bitmaps do not need to be the same size.)
0418BF             0013*  ; This allows a sprite to include an animation sequence,
0418BF             0014*  ; which can be stepped through one frame at a time, or picked
0418BF             0015*  ; in any order.
0418BF             0016*  
0418BF             0017*  ; Any format of bitmap can be used as a sprite frame. It should
0418BF             0018*  ; be noted however that "native" format bitmaps are not
0418BF             0019*  ; recommended for use as sprite frames, as they cannot get
0418BF             0020*  ; erased from the screen. (As noted above, the "native" bitmap
0418BF             0021*  ; format is not really intended for general use.) This is part
0418BF             0022*  ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
0418BF             0023*  ; screen are now stored in RGBA2222 format.
0418BF             0024*  
0418BF             0025*  ; An "active" sprite can be hidden, so it will stop being drawn,
0418BF             0026*  ; and then later shown again.
0418BF             0027*  
0418BF             0028*  ; Moving sprites around the screen is done by changing the
0418BF             0029*  ; position of the sprite. This can be done either by setting
0418BF             0030*  ; the absolute position of the sprite, or by moving the sprite
0418BF             0031*  ; by a given number of pixels. (Sprites are positioned using
0418BF             0032*  ; pixel coordinates, and not by the logical OS coordinate system.)
0418BF             0033*  ; In the current sprite system, sprites will not update their
0418BF             0034*  ; position on-screen until either another drawing operation is
0418BF             0035*  ; performed or an explicit VDU 23, 27, 15 command is performed.
0418BF             0036*  
0418BF             0037*  ; VDU 23, 27, 4, n: Select sprite n
0418BF             0038*  ; inputs: a is the 8-bit sprite id
0418BF             0039*  vdu_sprite_select:
0418BF 32 D1 18 04 0040*      ld (@sprite),a
0418C3 21 CE 18 04 0041*      ld hl,@cmd
0418C7 01 04 00 00 0042*      ld bc,@end-@cmd
0418CB 5B DF       0043*      rst.lil $18
0418CD C9          0044*      ret
0418CE 17 1B 04    0045*  @cmd:    db 23,27,4
0418D1 00          0046*  @sprite: db 0x00
0418D2             0047*  @end:
0418D2             0048*  
0418D2             0049*  ; VDU 23, 27, 5: Clear frames in current sprite
0418D2             0050*  ; inputs: none
0418D2             0051*  ; prerequisites: vdu_sprite_select
0418D2             0052*  vdu_sprite_clear_frames:
0418D2 21 DD 18 04 0053*      ld hl,@cmd
0418D6 01 03 00 00 0054*      ld bc,@end-@cmd
0418DA 5B DF       0055*      rst.lil $18
0418DC C9          0056*      ret
0418DD 17 1B 05    0057*  @cmd: db 23,27,5
0418E0             0058*  @end:
0418E0             0059*  
0418E0             0060*  ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
0418E0             0061*  ; inputs: a is the 8-bit bitmap number
0418E0             0062*  ; prerequisites: vdu_sprite_select
0418E0             0063*  vdu_sprite_add_bmp:
0418E0 32 F2 18 04 0064*      ld (@bmp),a
0418E4 21 EF 18 04 0065*      ld hl,@cmd
0418E8 01 04 00 00 0066*      ld bc,@end-@cmd
0418EC 5B DF       0067*      rst.lil $18
0418EE C9          0068*      ret
0418EF 17 1B 06    0069*  @cmd: db 23,27,6
0418F2 00          0070*  @bmp: db 0x00
0418F3             0071*  @end:
0418F3             0072*  
0418F3             0073*  ; VDU 23, 27, 7, n: Activate n sprites
0418F3             0074*  ; inputs: a is the number of sprites to activate
0418F3             0075*  ; prerequisites: each sprite activated must have at least one frame attached to it
0418F3             0076*  vdu_sprite_activate:
0418F3 32 05 19 04 0077*      ld (@num),a
0418F7 21 02 19 04 0078*      ld hl,@cmd
0418FB 01 04 00 00 0079*      ld bc,@end-@cmd
0418FF 5B DF       0080*      rst.lil $18
041901 C9          0081*      ret
041902 17 1B 07    0082*  @cmd: db 23,27,7
041905 00          0083*  @num: db 0x00
041906             0084*  @end:
041906             0085*  
041906             0086*  ; VDU 23, 27, 8: Select next frame of current sprite
041906             0087*  ; inputs: none
041906             0088*  ; prerequisites: vdu_sprite_select
041906             0089*  vdu_sprite_next_frame:
041906 21 11 19 04 0090*      ld hl,@cmd
04190A 01 03 00 00 0091*      ld bc,@end-@cmd
04190E 5B DF       0092*      rst.lil $18
041910 C9          0093*      ret
041911 17 1B 08    0094*  @cmd: db 23,27,8
041914             0095*  @end:
041914             0096*  
041914             0097*  ; VDU 23, 27, 9: Select previous frame of current sprite
041914             0098*  ; inputs: none
041914             0099*  ; prerequisites: vdu_sprite_select
041914             0100*  vdu_sprite_prev_frame:
041914 21 1F 19 04 0101*      ld hl,@cmd
041918 01 03 00 00 0102*      ld bc,@end-@cmd
04191C 5B DF       0103*      rst.lil $18
04191E C9          0104*      ret
04191F 17 1B 09    0105*  @cmd: db 23,27,9
041922             0106*  @end:
041922             0107*  
041922             0108*  ; VDU 23, 27, 10, n: Select the nth frame of current sprite
041922             0109*  ; inputs: a is frame number to select
041922             0110*  ; prerequisites: vdu_sprite_select
041922             0111*  vdu_sprite_select_frame:
041922 32 34 19 04 0112*      ld (@frame),a
041926 21 31 19 04 0113*      ld hl,@cmd
04192A 01 04 00 00 0114*      ld bc,@end-@cmd
04192E 5B DF       0115*      rst.lil $18
041930 C9          0116*      ret
041931 17 1B 0A    0117*  @cmd:    db 23,27,10
041934 00          0118*  @frame:  db 0x00
041935             0119*  @end:
041935             0120*  
041935             0121*  ; VDU 23, 27, 11: Show current sprite
041935             0122*  ; inputs: none
041935             0123*  ; prerequisites: vdu_sprite_select
041935             0124*  vdu_sprite_show:
041935 21 40 19 04 0125*      ld hl,@cmd
041939 01 03 00 00 0126*      ld bc,@end-@cmd
04193D 5B DF       0127*      rst.lil $18
04193F C9          0128*      ret
041940 17 1B 0B    0129*  @cmd: db 23,27,11
041943             0130*  @end:
041943             0131*  
041943             0132*  ; VDU 23, 27, 12: Hide current sprite
041943             0133*  ; inputs: none
041943             0134*  ; prerequisites: vdu_sprite_select
041943             0135*  vdu_sprite_hide:
041943 21 4E 19 04 0136*      ld hl,@cmd
041947 01 03 00 00 0137*      ld bc,@end-@cmd
04194B 5B DF       0138*      rst.lil $18
04194D C9          0139*      ret
04194E 17 1B 0C    0140*  @cmd: db 23,27,12
041951             0141*  @end:
041951             0142*  
041951             0143*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
041951             0144*  ; inputs: bc is x coordinate, de is y coordinate
041951             0145*  ; prerequisites: vdu_sprite_select
041951             0146*  vdu_sprite_move_abs:
041951 ED 43 69 19 0147*      ld (@xpos),bc
       04          
041956 ED 53 6B 19 0148*      ld (@ypos),de
       04          
04195B 21 66 19 04 0149*      ld hl,@cmd
04195F 01 07 00 00 0150*      ld bc,@end-@cmd
041963 5B DF       0151*      rst.lil $18
041965 C9          0152*      ret
041966 17 1B 0D    0153*  @cmd:  db 23,27,13
041969 00 00       0154*  @xpos: dw 0x0000
04196B 00 00       0155*  @ypos: dw 0x0000
04196D 00          0156*  @end:  db 0x00 ; padding
04196E             0157*  
04196E             0158*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
04196E             0159*  ; inputs: bc is x coordinate, de is y coordinate
04196E             0160*  ; prerequisites: vdu_sprite_select
04196E             0161*  vdu_sprite_move_rel:
04196E ED 43 86 19 0162*      ld (@dx),bc
       04          
041973 ED 53 88 19 0163*      ld (@dy),de
       04          
041978 21 83 19 04 0164*      ld hl,@cmd
04197C 01 07 00 00 0165*      ld bc,@end-@cmd
041980 5B DF       0166*      rst.lil $18
041982 C9          0167*      ret
041983 17 1B 0E    0168*  @cmd: db 23,27,14
041986 00 00       0169*  @dx:  dw 0x0000
041988 00 00       0170*  @dy:  dw 0x0000
04198A 00          0171*  @end: db 0x00 ; padding
04198B             0172*  
04198B             0173*  ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
04198B             0174*  ; USING 16.8 FIXED POINT COORDINATES
04198B             0175*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
04198B             0176*  ;   the fractional portiion of the inputs are truncated
04198B             0177*  ;   leaving only the 16-bit integer portion
04198B             0178*  ; prerequisites: vdu_sprite_select
04198B             0179*  vdu_sprite_move_abs168:
04198B             0180*  ; offset inputs by the gfx origin
04198B             0181*  ; y coordinate
04198B 21 00 00 00 0182*      ld hl,origin_top*256
04198F 19          0183*      add hl,de
041990 22 B2 19 04 0184*      ld (@ypos-1),hl
041994             0185*  ; x coordinate
041994 21 00 80 00 0186*      ld hl,origin_left*256
041998 09          0187*      add hl,bc
041999 22 B0 19 04 0188*      ld (@xpos-1),hl
04199D             0189*  ; prepare vdu command
04199D 3E 0D       0190*      ld a,13       ; restore the final byte of the command
04199F 32 B0 19 04 0191*      ld (@cmd+2),a ; string that got stomped on by bcu
0419A3 21 AE 19 04 0192*      ld hl,@cmd
0419A7 01 07 00 00 0193*      ld bc,@end-@cmd
0419AB 5B DF       0194*      rst.lil $18
0419AD C9          0195*      ret
0419AE 17 1B 0D    0196*  @cmd:  db 23,27,13
0419B1 00 00       0197*  @xpos: dw 0x0000
0419B3 00 00       0198*  @ypos: dw 0x0000
0419B5             0199*  @end:  ; no padding required b/c we shifted de right
0419B5             0200*  
0419B5             0201*  ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0419B5             0202*  ; USING 16.8 FIXED POINT COORDINATES
0419B5             0203*  ; inputs: ub.c is dx, ud.e is dy
0419B5             0204*  ;   the fractional portiion of the inputs are truncated
0419B5             0205*  ;   leaving only the 16-bit integer portion
0419B5             0206*  ; prerequisites: vdu_sprite_select
0419B5             0207*  vdu_sprite_move_rel168:
0419B5             0208*  ; populate in the reverse of normal to keep the
0419B5             0209*  ; inputs from stomping on each other
0419B5 ED 53 D4 19 0210*      ld (@dy-1),de
       04          
0419BA ED 43 D2 19 0211*      ld (@dx-1),bc
       04          
0419BF 3E 0E       0212*      ld a,14       ; restore the final byte of the command
0419C1 32 D2 19 04 0213*      ld (@cmd+2),a ; string that got stomped on by bcu
0419C5 21 D0 19 04 0214*      ld hl,@cmd
0419C9 01 07 00 00 0215*      ld bc,@end-@cmd
0419CD 5B DF       0216*      rst.lil $18
0419CF C9          0217*      ret
0419D0 17 1B 0E    0218*  @cmd:  db 23,27,14
0419D3 00 00       0219*  @dx: dw 0x0000
0419D5 00 00       0220*  @dy: dw 0x0000
0419D7             0221*  @end:  ; no padding required b/c we shifted de right
0419D7             0222*  
0419D7             0223*  ; VDU 23, 27, 15: Update the sprites in the GPU
0419D7             0224*  ; inputs: none
0419D7             0225*  vdu_sprite_update:
0419D7 21 E2 19 04 0226*      ld hl,@cmd
0419DB 01 03 00 00 0227*      ld bc,@end-@cmd
0419DF 5B DF       0228*      rst.lil $18
0419E1 C9          0229*      ret
0419E2 17 1B 0F    0230*  @cmd: db 23,27,15
0419E5             0231*  @end:
0419E5             0232*  
0419E5             0233*  ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
0419E5             0234*  ; inputs: none
0419E5             0235*  vdu_sprite_bmp_reset:
0419E5 21 F0 19 04 0236*      ld hl,@cmd
0419E9 01 03 00 00 0237*      ld bc,@end-@cmd
0419ED 5B DF       0238*      rst.lil $18
0419EF C9          0239*      ret
0419F0 17 1B 10    0240*  @cmd: db 23,27,16
0419F3             0241*  @end:
0419F3             0242*  
0419F3             0243*  ; VDU 23, 27, 17: Reset sprites (only) and clear all data
0419F3             0244*  ; inputs: none
0419F3             0245*  vdu_sprite_reset:
0419F3 21 FE 19 04 0246*      ld hl,@cmd
0419F7 01 03 00 00 0247*      ld bc,@end-@cmd
0419FB 5B DF       0248*      rst.lil $18
0419FD C9          0249*      ret
0419FE 17 1B 11    0250*  @cmd: db 23,27,17
041A01             0251*  @end:
041A01             0252*  
041A01             0253*  ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
041A01             0254*  ; inputs: a is the GCOL paint mode
041A01             0255*  ; prerequisites: vdu_sprite_select
041A01             0256*  vdu_sprite_set_gcol:
041A01 32 13 1A 04 0257*      ld (@mode),a
041A05 21 10 1A 04 0258*      ld hl,@cmd
041A09 01 04 00 00 0259*      ld bc,@end-@cmd
041A0D 5B DF       0260*      rst.lil $18
041A0F C9          0261*      ret
041A10 17 1B 12    0262*  @cmd:  db 23,27,18
041A13 00          0263*  @mode: db 0x00
041A14             0264*  @end:
041A14             0265*  
041A14             0266*  ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
041A14             0267*  ; inputs: hl=bufferId
041A14             0268*  ; prerequisites: vdu_sprite_select
041A14             0269*  vdu_sprite_add_buff:
041A14 22 26 1A 04 0270*      ld (@bufferId),hl
041A18 21 23 1A 04 0271*      ld hl,@cmd
041A1C 01 05 00 00 0272*      ld bc,@end-@cmd
041A20 5B DF       0273*      rst.lil $18
041A22 C9          0274*      ret
041A23 17 1B 26    0275*  @cmd:      db 23,27,0x26
041A26 00 00       0276*  @bufferId: dw 0x0000
041A28 00          0277*  @end:      db 0x00 ; padding
041A29             0040   
041A29             0041   ; APPLICATION INCLUDES
041A29             0042       include "collisions.inc"
041A29             0001*  ; ====== COLLISION DETECTION ======
041A29             0002*  ; --- constants ---
041A29             0003*  ; sprite_collisions flags
041A29             0004*  collides_with_player: equ 0
041A29             0005*  collides_with_laser: equ 1
041A29             0006*  sprite_alive: equ 6 ; set when sprite is alive
041A29             0007*  sprite_just_died: equ 7 ; set when sprite just died
041A29             0008*  
041A29             0009*  ; TODO: make these bit numbers instead of masks
041A29             0010*  collide_top: equ %00001000
041A29             0011*  collide_bottom: equ %00000100
041A29             0012*  collide_left: equ %00000010
041A29             0013*  collide_right: equ %00000001
041A29             0014*  ; END TODO
041A29             0015*  
041A29             0016*  ; this routine detects collisions between two collidable objects,
041A29             0017*  ; which can include sprites, active tiles, or any screen coordinate
041A29             0018*  ; which has been set up with a sprite table structure that includes dim_x
041A29             0019*  ; representing the radius of the collidable object
041A29             0020*  ; inputs: ix and iy point to the colliding objects' sprite table records
041A29             0021*  ; outputs: uh.l = distance - sum of radii
041A29             0022*  ;          zero flag set or sign flag negative if collision detected
041A29             0023*  ;          dx168 and dy168 are also populated with the signed displacements
041A29             0024*  ; destroys: everything except indexes
041A29             0025*  check_collision:
041A29             0026*  ; compute dx = x1-x0
041A29 DD 27 0B    0027*      ld hl,(ix+sprite_x)
041A2C FD 17 0B    0028*      ld de,(iy+sprite_x)
041A2F AF          0029*      xor a ; clear carry
041A30 ED 52       0030*      sbc hl,de
041A32 22 A2 09 04 0031*      ld (dx168),hl ; dx to scratch
041A36             0032*  ; compute dy = y1-y0
041A36 DD 27 0E    0033*      ld hl,(ix+sprite_y)
041A39 FD 17 0E    0034*      ld de,(iy+sprite_y)
041A3C AF          0035*      xor a ; clear carry
041A3D ED 52       0036*      sbc hl,de ; hl = dy
041A3F 22 A8 09 04 0037*      ld (dy168),hl ; dy to scratch
041A43             0038*  ; compute euclidean distance between centers
041A43 CD AE 09 04 0039*      call distance168 ; uh.l = distance
041A47             0040*  ; check for overlap by summing half the radii
041A47 DD 7E 09    0041*      ld a,(ix+sprite_dim_x)
041A4A CB 3F       0042*      srl a ; divide by 2
041A4C FD 5E 09    0043*      ld e,(iy+sprite_dim_x)
041A4F CB 3B       0044*      srl e ; divide by 2
041A51 83          0045*      add a,e
041A52 11 00 00 00 0046*      ld de,0 ; clear deu and e
041A56 57          0047*      ld d,a ; ud.e = sum of radii
041A57 B7          0048*      or a ; clear carry
041A58 ED 52       0049*      sbc hl,de ; uh.l = distance - sum of radii
041A5A C9          0050*      ret
041A5B             0051*  ; end check_collision
041A5B             0043       include "enemies.inc"
041A5B 04          0001*  max_enemy_sprites: db 4
041A5C             0002*  
041A5C             0003*  ; sprite_type
041A5C             0004*  enemy_dead: equ 0
041A5C             0005*  enemy_seeker: equ 1
041A5C             0006*  enemy_medium: equ 2
041A5C             0007*  enemy_large: equ 3
041A5C             0008*  landing_pad: equ 4
041A5C             0009*  laser_turret: equ 5
041A5C             0010*  fireballs: equ 6
041A5C             0011*  explosion: equ 7
041A5C             0012*  
041A5C             0013*  move_enemies:
041A5C             0014*  ; are there any active enemies or explosions?
041A5C 3A C7 38 04 0015*      ld a,(table_active_sprites)
041A60 A7          0016*      and a ; will be zero if no alive enemies or explosions
041A61 C2 6E 1A 04 0017*      jp nz,@they_live
041A65 21 E9 3A 04 0018*      ld hl,enemies_dead
041A69 22 E6 3A 04 0019*      ld (enemies_state),hl
041A6D C9          0020*      ret
041A6E             0021*  @they_live:
041A6E             0022*  ; initialize pointers and loop counter
041A6E FD 21 64 36 0023*      ld iy,table_base ; set iy to first record in table
       04          
041A73 06 10       0024*      ld b,table_max_records ; loop counter
041A75             0025*  @move_loop:
041A75 FD 22 C4 38 0026*      ld (table_pointer),iy ; update table pointer
       04          
041A7A C5          0027*      push bc ; backup loop counter
041A7B             0028*  ; check sprite_type to see if sprite is active
041A7B FD 7E 01    0029*      ld a,(iy+sprite_type)
041A7E A7          0030*      and a ; if zero, sprite is dead
041A7F CA B2 1A 04 0031*      jp z,@next_record ; ... and we skip to next record
041A83             0032*  ; otherwise we prepare to move the sprite
041A83 FD 7E 00    0033*      ld a,(iy+sprite_id) ; get spriteId
041A86 CD BF 18 04 0034*      call vdu_sprite_select ; select sprite
041A8A FD 27 05    0035*      ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
041A8D             0036*      callHL
041A8D 01 93 1A 04 0001*M     ld bc,@F ; Address of first instruction after the jump
041A91 C5          0002*M     push bc ; which constitutes the return address
041A92 E9          0003*M     jp (hl) ; Jump to the address in HL
041A93             0004*M @@:
041A93             0037*  ; move_enemies_loop_return: return from behavior subroutines
041A93 FD 2A C4 38 0038*      ld iy,(table_pointer) ; get back table pointer
       04          
041A98             0039*  ; now we check results of all the moves
041A98 FD CB 08 7E 0040*      bit sprite_just_died,(iy+sprite_collisions)
041A9C CA A8 1A 04 0041*      jp z,@draw_sprite ; if not dead, draw sprite
041AA0 CD 10 39 04 0042*      call table_deactivate_sprite
041AA4 C3 B2 1A 04 0043*      jp @next_record ; and to the next record
041AA8             0044*  @draw_sprite:
041AA8 FD 07 0B    0045*      ld bc,(iy+sprite_x)
041AAB FD 17 0E    0046*      ld de,(iy+sprite_y)
041AAE CD 8B 19 04 0047*      call vdu_sprite_move_abs168
041AB2             0048*  ; fall through to @next_record
041AB2             0049*  @next_record:
041AB2 ED 33 26    0050*      lea iy,iy+table_bytes_per_record
041AB5 AF          0051*      xor a ; clears carry flag
041AB6 32 C8 38 04 0052*      ld (sprite_screen_edge),a ; clear screen edge collision flag
041ABA C1          0053*      pop bc ; get back our loop counter
041ABB 10 B8       0054*      djnz @move_loop ; loop until we've checked all the records
041ABD C9          0055*      ret ; and we're out
041ABE             0056*  
041ABE             0057*  ; ; ######### SPRITE BEHAVIOR ROUTINES #########
041ABE             0058*  ; ; each sprite in the table must have one of these defined
041ABE             0059*  ; ; but they need not be unique to a particular sprite
041ABE             0060*  ; ; these are jumped to from move_enemies_do_program,but could come from other places
041ABE             0061*  ; ; and have the option but not obligation to go back to move_enemies_loop_return
041ABE             0062*  ; ; but they can call anything they want between those two endpoints
041ABE             0063*  ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
041ABE             0064*  
041ABE             0065*  check_enemy_player_collisions:
041ABE             0066*  ; check for collisions with player
041ABE DD 21 E1 34 0067*      ld ix,player_start_variables
       04          
041AC3 DD CB 08 76 0068*      bit sprite_alive,(ix+sprite_collisions)
041AC7 C8          0069*      ret z ; player dead, no collision
041AC8 CD 29 1A 04 0070*      call check_collision
041ACC F0          0071*      ret p ; no collision
041ACD C3 F8 1A 04 0072*      jp enemy_kill
041AD1             0073*  ; end move_enemy_seeker
041AD1             0074*  orientation_to_player:
041AD1 FD 2A C4 38 0075*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
041AD6 FD 07 0B    0076*      ld bc,(iy+sprite_x)
041AD9 FD 17 0E    0077*      ld de,(iy+sprite_y)
041ADC DD 2A EC 34 0078*      ld ix,(player_x)
       04          
041AE1 FD 2A EF 34 0079*      ld iy,(player_y)
       04          
041AE6 CD 87 09 04 0080*      call dxy168
041AEA C5          0081*      push bc
041AEB D5          0082*      push de
041AEC CD E3 09 04 0083*      call atan2_168fast
041AF0 D1          0084*      pop de
041AF1 C1          0085*      pop bc
041AF2 FD 2A C4 38 0086*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
041AF7 C9          0087*      ret
041AF8             0088*  
041AF8             0089*  ; this routine vanquishes the enemy sprite
041AF8             0090*  ; inputs: table_pointer set to sprite record
041AF8             0091*  ; destroys: everything except index registers
041AF8             0092*  ; returns: an incandescent ball of debris and gas
041AF8             0093*  enemy_kill:
041AF8 FD 2A C4 38 0094*      ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
041AFD             0095*  ; tally up points
041AFD 2A DD 34 04 0096*      ld hl,(player_score)
041B01 01 00 00 00 0097*      ld bc,0 ; clear bcu
041B05 FD 4E 24    0098*      ld c,(iy+sprite_points)
041B08 09          0099*      add hl,bc
041B09 22 DD 34 04 0100*      ld (player_score),hl
041B0D FD CB 08 FE 0101*      set sprite_just_died,(iy+sprite_collisions)
041B11 C9          0102*      ret
041B12             0103*  ; end enemy_kill
041B12             0044       include "images_sprites.inc"
041B12             0001*  ; Generated by beegee747/build/scripts/build_99_asm_img_load.py
041B12             0002*  
041B12             0003*  sprites_num_images: equ 113
041B12             0004*  
041B12             0005*  ; buffer_ids:
041B12             0006*  BUF_BLINKY_0: equ 256
041B12             0007*  BUF_BLINKY_1: equ 257
041B12             0008*  BUF_BLINKY_2: equ 258
041B12             0009*  BUF_BLINKY_3: equ 259
041B12             0010*  BUF_BLINKY_4: equ 260
041B12             0011*  BUF_BLINKY_5: equ 261
041B12             0012*  BUF_BLINKY_6: equ 262
041B12             0013*  BUF_BLINKY_7: equ 263
041B12             0014*  BUF_CLYDE_0: equ 264
041B12             0015*  BUF_CLYDE_1: equ 265
041B12             0016*  BUF_CLYDE_2: equ 266
041B12             0017*  BUF_CLYDE_3: equ 267
041B12             0018*  BUF_CLYDE_4: equ 268
041B12             0019*  BUF_CLYDE_5: equ 269
041B12             0020*  BUF_CLYDE_6: equ 270
041B12             0021*  BUF_CLYDE_7: equ 271
041B12             0022*  BUF_FRUIT_0: equ 272
041B12             0023*  BUF_FRUIT_1: equ 273
041B12             0024*  BUF_FRUIT_2: equ 274
041B12             0025*  BUF_FRUIT_3: equ 275
041B12             0026*  BUF_FRUIT_4: equ 276
041B12             0027*  BUF_FRUIT_5: equ 277
041B12             0028*  BUF_FRUIT_6: equ 278
041B12             0029*  BUF_FRUIT_7: equ 279
041B12             0030*  BUF_INKY_0: equ 280
041B12             0031*  BUF_INKY_1: equ 281
041B12             0032*  BUF_INKY_2: equ 282
041B12             0033*  BUF_INKY_3: equ 283
041B12             0034*  BUF_INKY_4: equ 284
041B12             0035*  BUF_INKY_5: equ 285
041B12             0036*  BUF_INKY_6: equ 286
041B12             0037*  BUF_INKY_7: equ 287
041B12             0038*  BUF_MAZE_PELLETS_00: equ 288
041B12             0039*  BUF_MAZE_PELLETS_01: equ 289
041B12             0040*  BUF_MAZE_PELLETS_02: equ 290
041B12             0041*  BUF_PAC_BIG_00_00: equ 291
041B12             0042*  BUF_PAC_BIG_00_01: equ 292
041B12             0043*  BUF_PAC_BIG_00_02: equ 293
041B12             0044*  BUF_PAC_DED_00_00: equ 294
041B12             0045*  BUF_PAC_DED_00_01: equ 295
041B12             0046*  BUF_PAC_DED_00_02: equ 296
041B12             0047*  BUF_PAC_DED_00_03: equ 297
041B12             0048*  BUF_PAC_DED_00_04: equ 298
041B12             0049*  BUF_PAC_DED_00_05: equ 299
041B12             0050*  BUF_PAC_DED_00_06: equ 300
041B12             0051*  BUF_PAC_DED_00_07: equ 301
041B12             0052*  BUF_PAC_DED_00_08: equ 302
041B12             0053*  BUF_PAC_DED_00_09: equ 303
041B12             0054*  BUF_PAC_DED_00_10: equ 304
041B12             0055*  BUF_PAC_LIV_00_00: equ 305
041B12             0056*  BUF_PAC_MAN_00_00: equ 306
041B12             0057*  BUF_PAC_MAN_00_01: equ 307
041B12             0058*  BUF_PAC_MAN_00_02: equ 308
041B12             0059*  BUF_PAC_MAN_01_00: equ 309
041B12             0060*  BUF_PAC_MAN_01_01: equ 310
041B12             0061*  BUF_PAC_MAN_01_02: equ 311
041B12             0062*  BUF_PAC_MAN_02_00: equ 312
041B12             0063*  BUF_PAC_MAN_02_01: equ 313
041B12             0064*  BUF_PAC_MAN_02_02: equ 314
041B12             0065*  BUF_PAC_MAN_03_00: equ 315
041B12             0066*  BUF_PAC_MAN_03_01: equ 316
041B12             0067*  BUF_PAC_MAN_03_02: equ 317
041B12             0068*  BUF_PINKY_0: equ 318
041B12             0069*  BUF_PINKY_1: equ 319
041B12             0070*  BUF_PINKY_2: equ 320
041B12             0071*  BUF_PINKY_3: equ 321
041B12             0072*  BUF_PINKY_4: equ 322
041B12             0073*  BUF_PINKY_5: equ 323
041B12             0074*  BUF_PINKY_6: equ 324
041B12             0075*  BUF_PINKY_7: equ 325
041B12             0076*  BUF_REVERSE_0: equ 326
041B12             0077*  BUF_REVERSE_1: equ 327
041B12             0078*  BUF_REVERSE_2: equ 328
041B12             0079*  BUF_REVERSE_3: equ 329
041B12             0080*  BUF_REVERSE_4: equ 330
041B12             0081*  BUF_REVERSE_5: equ 331
041B12             0082*  BUF_REVERSE_6: equ 332
041B12             0083*  BUF_REVERSE_7: equ 333
041B12             0084*  BUF_TILE_00: equ 334
041B12             0085*  BUF_TILE_01: equ 335
041B12             0086*  BUF_TILE_02: equ 336
041B12             0087*  BUF_TILE_03: equ 337
041B12             0088*  BUF_TILE_04: equ 338
041B12             0089*  BUF_TILE_05: equ 339
041B12             0090*  BUF_TILE_06: equ 340
041B12             0091*  BUF_TILE_07: equ 341
041B12             0092*  BUF_TILE_08: equ 342
041B12             0093*  BUF_TILE_09: equ 343
041B12             0094*  BUF_TILE_10: equ 344
041B12             0095*  BUF_TILE_11: equ 345
041B12             0096*  BUF_TILE_12: equ 346
041B12             0097*  BUF_TILE_13: equ 347
041B12             0098*  BUF_TILE_14: equ 348
041B12             0099*  BUF_TILE_15: equ 349
041B12             0100*  BUF_TILE_16: equ 350
041B12             0101*  BUF_TILE_17: equ 351
041B12             0102*  BUF_TILE_18: equ 352
041B12             0103*  BUF_TILE_19: equ 353
041B12             0104*  BUF_TILE_20: equ 354
041B12             0105*  BUF_TILE_21: equ 355
041B12             0106*  BUF_TILE_22: equ 356
041B12             0107*  BUF_TILE_23: equ 357
041B12             0108*  BUF_TILE_24: equ 358
041B12             0109*  BUF_TILE_25: equ 359
041B12             0110*  BUF_TILE_26: equ 360
041B12             0111*  BUF_TILE_27: equ 361
041B12             0112*  BUF_TILE_28: equ 362
041B12             0113*  BUF_TILE_29: equ 363
041B12             0114*  BUF_TILE_30: equ 364
041B12             0115*  BUF_TILE_31: equ 365
041B12             0116*  BUF_TILE_32: equ 366
041B12             0117*  BUF_TILE_33: equ 367
041B12             0118*  BUF_TILE_34: equ 368
041B12             0119*  
041B12             0120*  sprites_image_list: ; type; width; height; filename; bufferId:
041B12 01 00 00 10 0121*  	dl 1, 16, 16, 256, fn_blinky_0, 256
       00 00 10 00 
       00 00 01 00 
       04 23 04 00 
       01 00       
041B24 01 00 00 10 0122*  	dl 1, 16, 16, 256, fn_blinky_1, 257
       00 00 10 00 
       00 00 01 00 
       1B 23 04 01 
       01 00       
041B36 01 00 00 10 0123*  	dl 1, 16, 16, 256, fn_blinky_2, 258
       00 00 10 00 
       00 00 01 00 
       32 23 04 02 
       01 00       
041B48 01 00 00 10 0124*  	dl 1, 16, 16, 256, fn_blinky_3, 259
       00 00 10 00 
       00 00 01 00 
       49 23 04 03 
       01 00       
041B5A 01 00 00 10 0125*  	dl 1, 16, 16, 256, fn_blinky_4, 260
       00 00 10 00 
       00 00 01 00 
       60 23 04 04 
       01 00       
041B6C 01 00 00 10 0126*  	dl 1, 16, 16, 256, fn_blinky_5, 261
       00 00 10 00 
       00 00 01 00 
       77 23 04 05 
       01 00       
041B7E 01 00 00 10 0127*  	dl 1, 16, 16, 256, fn_blinky_6, 262
       00 00 10 00 
       00 00 01 00 
       8E 23 04 06 
       01 00       
041B90 01 00 00 10 0128*  	dl 1, 16, 16, 256, fn_blinky_7, 263
       00 00 10 00 
       00 00 01 00 
       A5 23 04 07 
       01 00       
041BA2 01 00 00 10 0129*  	dl 1, 16, 16, 256, fn_clyde_0, 264
       00 00 10 00 
       00 00 01 00 
       BC 23 04 08 
       01 00       
041BB4 01 00 00 10 0130*  	dl 1, 16, 16, 256, fn_clyde_1, 265
       00 00 10 00 
       00 00 01 00 
       D2 23 04 09 
       01 00       
041BC6 01 00 00 10 0131*  	dl 1, 16, 16, 256, fn_clyde_2, 266
       00 00 10 00 
       00 00 01 00 
       E8 23 04 0A 
       01 00       
041BD8 01 00 00 10 0132*  	dl 1, 16, 16, 256, fn_clyde_3, 267
       00 00 10 00 
       00 00 01 00 
       FE 23 04 0B 
       01 00       
041BEA 01 00 00 10 0133*  	dl 1, 16, 16, 256, fn_clyde_4, 268
       00 00 10 00 
       00 00 01 00 
       14 24 04 0C 
       01 00       
041BFC 01 00 00 10 0134*  	dl 1, 16, 16, 256, fn_clyde_5, 269
       00 00 10 00 
       00 00 01 00 
       2A 24 04 0D 
       01 00       
041C0E 01 00 00 10 0135*  	dl 1, 16, 16, 256, fn_clyde_6, 270
       00 00 10 00 
       00 00 01 00 
       40 24 04 0E 
       01 00       
041C20 01 00 00 10 0136*  	dl 1, 16, 16, 256, fn_clyde_7, 271
       00 00 10 00 
       00 00 01 00 
       56 24 04 0F 
       01 00       
041C32 01 00 00 10 0137*  	dl 1, 16, 16, 256, fn_fruit_0, 272
       00 00 10 00 
       00 00 01 00 
       6C 24 04 10 
       01 00       
041C44 01 00 00 10 0138*  	dl 1, 16, 16, 256, fn_fruit_1, 273
       00 00 10 00 
       00 00 01 00 
       82 24 04 11 
       01 00       
041C56 01 00 00 10 0139*  	dl 1, 16, 16, 256, fn_fruit_2, 274
       00 00 10 00 
       00 00 01 00 
       98 24 04 12 
       01 00       
041C68 01 00 00 10 0140*  	dl 1, 16, 16, 256, fn_fruit_3, 275
       00 00 10 00 
       00 00 01 00 
       AE 24 04 13 
       01 00       
041C7A 01 00 00 10 0141*  	dl 1, 16, 16, 256, fn_fruit_4, 276
       00 00 10 00 
       00 00 01 00 
       C4 24 04 14 
       01 00       
041C8C 01 00 00 10 0142*  	dl 1, 16, 16, 256, fn_fruit_5, 277
       00 00 10 00 
       00 00 01 00 
       DA 24 04 15 
       01 00       
041C9E 01 00 00 10 0143*  	dl 1, 16, 16, 256, fn_fruit_6, 278
       00 00 10 00 
       00 00 01 00 
       F0 24 04 16 
       01 00       
041CB0 01 00 00 10 0144*  	dl 1, 16, 16, 256, fn_fruit_7, 279
       00 00 10 00 
       00 00 01 00 
       06 25 04 17 
       01 00       
041CC2 01 00 00 10 0145*  	dl 1, 16, 16, 256, fn_inky_0, 280
       00 00 10 00 
       00 00 01 00 
       1C 25 04 18 
       01 00       
041CD4 01 00 00 10 0146*  	dl 1, 16, 16, 256, fn_inky_1, 281
       00 00 10 00 
       00 00 01 00 
       31 25 04 19 
       01 00       
041CE6 01 00 00 10 0147*  	dl 1, 16, 16, 256, fn_inky_2, 282
       00 00 10 00 
       00 00 01 00 
       46 25 04 1A 
       01 00       
041CF8 01 00 00 10 0148*  	dl 1, 16, 16, 256, fn_inky_3, 283
       00 00 10 00 
       00 00 01 00 
       5B 25 04 1B 
       01 00       
041D0A 01 00 00 10 0149*  	dl 1, 16, 16, 256, fn_inky_4, 284
       00 00 10 00 
       00 00 01 00 
       70 25 04 1C 
       01 00       
041D1C 01 00 00 10 0150*  	dl 1, 16, 16, 256, fn_inky_5, 285
       00 00 10 00 
       00 00 01 00 
       85 25 04 1D 
       01 00       
041D2E 01 00 00 10 0151*  	dl 1, 16, 16, 256, fn_inky_6, 286
       00 00 10 00 
       00 00 01 00 
       9A 25 04 1E 
       01 00       
041D40 01 00 00 10 0152*  	dl 1, 16, 16, 256, fn_inky_7, 287
       00 00 10 00 
       00 00 01 00 
       AF 25 04 1F 
       01 00       
041D52 01 00 00 08 0153*  	dl 1, 8, 8, 64, fn_maze_pellets_00, 288
       00 00 08 00 
       00 40 00 00 
       C4 25 04 20 
       01 00       
041D64 01 00 00 08 0154*  	dl 1, 8, 8, 64, fn_maze_pellets_01, 289
       00 00 08 00 
       00 40 00 00 
       E2 25 04 21 
       01 00       
041D76 01 00 00 08 0155*  	dl 1, 8, 8, 64, fn_maze_pellets_02, 290
       00 00 08 00 
       00 40 00 00 
       00 26 04 22 
       01 00       
041D88 01 00 00 20 0156*  	dl 1, 32, 32, 1024, fn_pac_big_00_00, 291
       00 00 20 00 
       00 00 04 00 
       1E 26 04 23 
       01 00       
041D9A 01 00 00 20 0157*  	dl 1, 32, 32, 1024, fn_pac_big_00_01, 292
       00 00 20 00 
       00 00 04 00 
       3A 26 04 24 
       01 00       
041DAC 01 00 00 20 0158*  	dl 1, 32, 32, 1024, fn_pac_big_00_02, 293
       00 00 20 00 
       00 00 04 00 
       56 26 04 25 
       01 00       
041DBE 01 00 00 10 0159*  	dl 1, 16, 16, 256, fn_pac_ded_00_00, 294
       00 00 10 00 
       00 00 01 00 
       72 26 04 26 
       01 00       
041DD0 01 00 00 10 0160*  	dl 1, 16, 16, 256, fn_pac_ded_00_01, 295
       00 00 10 00 
       00 00 01 00 
       8E 26 04 27 
       01 00       
041DE2 01 00 00 10 0161*  	dl 1, 16, 16, 256, fn_pac_ded_00_02, 296
       00 00 10 00 
       00 00 01 00 
       AA 26 04 28 
       01 00       
041DF4 01 00 00 10 0162*  	dl 1, 16, 16, 256, fn_pac_ded_00_03, 297
       00 00 10 00 
       00 00 01 00 
       C6 26 04 29 
       01 00       
041E06 01 00 00 10 0163*  	dl 1, 16, 16, 256, fn_pac_ded_00_04, 298
       00 00 10 00 
       00 00 01 00 
       E2 26 04 2A 
       01 00       
041E18 01 00 00 10 0164*  	dl 1, 16, 16, 256, fn_pac_ded_00_05, 299
       00 00 10 00 
       00 00 01 00 
       FE 26 04 2B 
       01 00       
041E2A 01 00 00 10 0165*  	dl 1, 16, 16, 256, fn_pac_ded_00_06, 300
       00 00 10 00 
       00 00 01 00 
       1A 27 04 2C 
       01 00       
041E3C 01 00 00 10 0166*  	dl 1, 16, 16, 256, fn_pac_ded_00_07, 301
       00 00 10 00 
       00 00 01 00 
       36 27 04 2D 
       01 00       
041E4E 01 00 00 10 0167*  	dl 1, 16, 16, 256, fn_pac_ded_00_08, 302
       00 00 10 00 
       00 00 01 00 
       52 27 04 2E 
       01 00       
041E60 01 00 00 10 0168*  	dl 1, 16, 16, 256, fn_pac_ded_00_09, 303
       00 00 10 00 
       00 00 01 00 
       6E 27 04 2F 
       01 00       
041E72 01 00 00 10 0169*  	dl 1, 16, 16, 256, fn_pac_ded_00_10, 304
       00 00 10 00 
       00 00 01 00 
       8A 27 04 30 
       01 00       
041E84 01 00 00 10 0170*  	dl 1, 16, 16, 256, fn_pac_liv_00_00, 305
       00 00 10 00 
       00 00 01 00 
       A6 27 04 31 
       01 00       
041E96 01 00 00 10 0171*  	dl 1, 16, 16, 256, fn_pac_man_00_00, 306
       00 00 10 00 
       00 00 01 00 
       C2 27 04 32 
       01 00       
041EA8 01 00 00 10 0172*  	dl 1, 16, 16, 256, fn_pac_man_00_01, 307
       00 00 10 00 
       00 00 01 00 
       DE 27 04 33 
       01 00       
041EBA 01 00 00 10 0173*  	dl 1, 16, 16, 256, fn_pac_man_00_02, 308
       00 00 10 00 
       00 00 01 00 
       FA 27 04 34 
       01 00       
041ECC 01 00 00 10 0174*  	dl 1, 16, 16, 256, fn_pac_man_01_00, 309
       00 00 10 00 
       00 00 01 00 
       16 28 04 35 
       01 00       
041EDE 01 00 00 10 0175*  	dl 1, 16, 16, 256, fn_pac_man_01_01, 310
       00 00 10 00 
       00 00 01 00 
       32 28 04 36 
       01 00       
041EF0 01 00 00 10 0176*  	dl 1, 16, 16, 256, fn_pac_man_01_02, 311
       00 00 10 00 
       00 00 01 00 
       4E 28 04 37 
       01 00       
041F02 01 00 00 10 0177*  	dl 1, 16, 16, 256, fn_pac_man_02_00, 312
       00 00 10 00 
       00 00 01 00 
       6A 28 04 38 
       01 00       
041F14 01 00 00 10 0178*  	dl 1, 16, 16, 256, fn_pac_man_02_01, 313
       00 00 10 00 
       00 00 01 00 
       86 28 04 39 
       01 00       
041F26 01 00 00 10 0179*  	dl 1, 16, 16, 256, fn_pac_man_02_02, 314
       00 00 10 00 
       00 00 01 00 
       A2 28 04 3A 
       01 00       
041F38 01 00 00 10 0180*  	dl 1, 16, 16, 256, fn_pac_man_03_00, 315
       00 00 10 00 
       00 00 01 00 
       BE 28 04 3B 
       01 00       
041F4A 01 00 00 10 0181*  	dl 1, 16, 16, 256, fn_pac_man_03_01, 316
       00 00 10 00 
       00 00 01 00 
       DA 28 04 3C 
       01 00       
041F5C 01 00 00 10 0182*  	dl 1, 16, 16, 256, fn_pac_man_03_02, 317
       00 00 10 00 
       00 00 01 00 
       F6 28 04 3D 
       01 00       
041F6E 01 00 00 10 0183*  	dl 1, 16, 16, 256, fn_pinky_0, 318
       00 00 10 00 
       00 00 01 00 
       12 29 04 3E 
       01 00       
041F80 01 00 00 10 0184*  	dl 1, 16, 16, 256, fn_pinky_1, 319
       00 00 10 00 
       00 00 01 00 
       28 29 04 3F 
       01 00       
041F92 01 00 00 10 0185*  	dl 1, 16, 16, 256, fn_pinky_2, 320
       00 00 10 00 
       00 00 01 00 
       3E 29 04 40 
       01 00       
041FA4 01 00 00 10 0186*  	dl 1, 16, 16, 256, fn_pinky_3, 321
       00 00 10 00 
       00 00 01 00 
       54 29 04 41 
       01 00       
041FB6 01 00 00 10 0187*  	dl 1, 16, 16, 256, fn_pinky_4, 322
       00 00 10 00 
       00 00 01 00 
       6A 29 04 42 
       01 00       
041FC8 01 00 00 10 0188*  	dl 1, 16, 16, 256, fn_pinky_5, 323
       00 00 10 00 
       00 00 01 00 
       80 29 04 43 
       01 00       
041FDA 01 00 00 10 0189*  	dl 1, 16, 16, 256, fn_pinky_6, 324
       00 00 10 00 
       00 00 01 00 
       96 29 04 44 
       01 00       
041FEC 01 00 00 10 0190*  	dl 1, 16, 16, 256, fn_pinky_7, 325
       00 00 10 00 
       00 00 01 00 
       AC 29 04 45 
       01 00       
041FFE 01 00 00 10 0191*  	dl 1, 16, 16, 256, fn_reverse_0, 326
       00 00 10 00 
       00 00 01 00 
       C2 29 04 46 
       01 00       
042010 01 00 00 10 0192*  	dl 1, 16, 16, 256, fn_reverse_1, 327
       00 00 10 00 
       00 00 01 00 
       DA 29 04 47 
       01 00       
042022 01 00 00 10 0193*  	dl 1, 16, 16, 256, fn_reverse_2, 328
       00 00 10 00 
       00 00 01 00 
       F2 29 04 48 
       01 00       
042034 01 00 00 10 0194*  	dl 1, 16, 16, 256, fn_reverse_3, 329
       00 00 10 00 
       00 00 01 00 
       0A 2A 04 49 
       01 00       
042046 01 00 00 10 0195*  	dl 1, 16, 16, 256, fn_reverse_4, 330
       00 00 10 00 
       00 00 01 00 
       22 2A 04 4A 
       01 00       
042058 01 00 00 10 0196*  	dl 1, 16, 16, 256, fn_reverse_5, 331
       00 00 10 00 
       00 00 01 00 
       3A 2A 04 4B 
       01 00       
04206A 01 00 00 10 0197*  	dl 1, 16, 16, 256, fn_reverse_6, 332
       00 00 10 00 
       00 00 01 00 
       52 2A 04 4C 
       01 00       
04207C 01 00 00 10 0198*  	dl 1, 16, 16, 256, fn_reverse_7, 333
       00 00 10 00 
       00 00 01 00 
       6A 2A 04 4D 
       01 00       
04208E 01 00 00 08 0199*  	dl 1, 8, 8, 64, fn_tile_00, 334
       00 00 08 00 
       00 40 00 00 
       82 2A 04 4E 
       01 00       
0420A0 01 00 00 08 0200*  	dl 1, 8, 8, 64, fn_tile_01, 335
       00 00 08 00 
       00 40 00 00 
       98 2A 04 4F 
       01 00       
0420B2 01 00 00 08 0201*  	dl 1, 8, 8, 64, fn_tile_02, 336
       00 00 08 00 
       00 40 00 00 
       AE 2A 04 50 
       01 00       
0420C4 01 00 00 08 0202*  	dl 1, 8, 8, 64, fn_tile_03, 337
       00 00 08 00 
       00 40 00 00 
       C4 2A 04 51 
       01 00       
0420D6 01 00 00 08 0203*  	dl 1, 8, 8, 64, fn_tile_04, 338
       00 00 08 00 
       00 40 00 00 
       DA 2A 04 52 
       01 00       
0420E8 01 00 00 08 0204*  	dl 1, 8, 8, 64, fn_tile_05, 339
       00 00 08 00 
       00 40 00 00 
       F0 2A 04 53 
       01 00       
0420FA 01 00 00 08 0205*  	dl 1, 8, 8, 64, fn_tile_06, 340
       00 00 08 00 
       00 40 00 00 
       06 2B 04 54 
       01 00       
04210C 01 00 00 08 0206*  	dl 1, 8, 8, 64, fn_tile_07, 341
       00 00 08 00 
       00 40 00 00 
       1C 2B 04 55 
       01 00       
04211E 01 00 00 08 0207*  	dl 1, 8, 8, 64, fn_tile_08, 342
       00 00 08 00 
       00 40 00 00 
       32 2B 04 56 
       01 00       
042130 01 00 00 08 0208*  	dl 1, 8, 8, 64, fn_tile_09, 343
       00 00 08 00 
       00 40 00 00 
       48 2B 04 57 
       01 00       
042142 01 00 00 08 0209*  	dl 1, 8, 8, 64, fn_tile_10, 344
       00 00 08 00 
       00 40 00 00 
       5E 2B 04 58 
       01 00       
042154 01 00 00 08 0210*  	dl 1, 8, 8, 64, fn_tile_11, 345
       00 00 08 00 
       00 40 00 00 
       74 2B 04 59 
       01 00       
042166 01 00 00 08 0211*  	dl 1, 8, 8, 64, fn_tile_12, 346
       00 00 08 00 
       00 40 00 00 
       8A 2B 04 5A 
       01 00       
042178 01 00 00 08 0212*  	dl 1, 8, 8, 64, fn_tile_13, 347
       00 00 08 00 
       00 40 00 00 
       A0 2B 04 5B 
       01 00       
04218A 01 00 00 08 0213*  	dl 1, 8, 8, 64, fn_tile_14, 348
       00 00 08 00 
       00 40 00 00 
       B6 2B 04 5C 
       01 00       
04219C 01 00 00 08 0214*  	dl 1, 8, 8, 64, fn_tile_15, 349
       00 00 08 00 
       00 40 00 00 
       CC 2B 04 5D 
       01 00       
0421AE 01 00 00 08 0215*  	dl 1, 8, 8, 64, fn_tile_16, 350
       00 00 08 00 
       00 40 00 00 
       E2 2B 04 5E 
       01 00       
0421C0 01 00 00 08 0216*  	dl 1, 8, 8, 64, fn_tile_17, 351
       00 00 08 00 
       00 40 00 00 
       F8 2B 04 5F 
       01 00       
0421D2 01 00 00 08 0217*  	dl 1, 8, 8, 64, fn_tile_18, 352
       00 00 08 00 
       00 40 00 00 
       0E 2C 04 60 
       01 00       
0421E4 01 00 00 08 0218*  	dl 1, 8, 8, 64, fn_tile_19, 353
       00 00 08 00 
       00 40 00 00 
       24 2C 04 61 
       01 00       
0421F6 01 00 00 08 0219*  	dl 1, 8, 8, 64, fn_tile_20, 354
       00 00 08 00 
       00 40 00 00 
       3A 2C 04 62 
       01 00       
042208 01 00 00 08 0220*  	dl 1, 8, 8, 64, fn_tile_21, 355
       00 00 08 00 
       00 40 00 00 
       50 2C 04 63 
       01 00       
04221A 01 00 00 08 0221*  	dl 1, 8, 8, 64, fn_tile_22, 356
       00 00 08 00 
       00 40 00 00 
       66 2C 04 64 
       01 00       
04222C 01 00 00 08 0222*  	dl 1, 8, 8, 64, fn_tile_23, 357
       00 00 08 00 
       00 40 00 00 
       7C 2C 04 65 
       01 00       
04223E 01 00 00 08 0223*  	dl 1, 8, 8, 64, fn_tile_24, 358
       00 00 08 00 
       00 40 00 00 
       92 2C 04 66 
       01 00       
042250 01 00 00 08 0224*  	dl 1, 8, 8, 64, fn_tile_25, 359
       00 00 08 00 
       00 40 00 00 
       A8 2C 04 67 
       01 00       
042262 01 00 00 08 0225*  	dl 1, 8, 8, 64, fn_tile_26, 360
       00 00 08 00 
       00 40 00 00 
       BE 2C 04 68 
       01 00       
042274 01 00 00 08 0226*  	dl 1, 8, 8, 64, fn_tile_27, 361
       00 00 08 00 
       00 40 00 00 
       D4 2C 04 69 
       01 00       
042286 01 00 00 08 0227*  	dl 1, 8, 8, 64, fn_tile_28, 362
       00 00 08 00 
       00 40 00 00 
       EA 2C 04 6A 
       01 00       
042298 01 00 00 08 0228*  	dl 1, 8, 8, 64, fn_tile_29, 363
       00 00 08 00 
       00 40 00 00 
       00 2D 04 6B 
       01 00       
0422AA 01 00 00 08 0229*  	dl 1, 8, 8, 64, fn_tile_30, 364
       00 00 08 00 
       00 40 00 00 
       16 2D 04 6C 
       01 00       
0422BC 01 00 00 08 0230*  	dl 1, 8, 8, 64, fn_tile_31, 365
       00 00 08 00 
       00 40 00 00 
       2C 2D 04 6D 
       01 00       
0422CE 01 00 00 08 0231*  	dl 1, 8, 8, 64, fn_tile_32, 366
       00 00 08 00 
       00 40 00 00 
       42 2D 04 6E 
       01 00       
0422E0 01 00 00 08 0232*  	dl 1, 8, 8, 64, fn_tile_33, 367
       00 00 08 00 
       00 40 00 00 
       58 2D 04 6F 
       01 00       
0422F2 01 00 00 08 0233*  	dl 1, 8, 8, 64, fn_tile_34, 368
       00 00 08 00 
       00 40 00 00 
       6E 2D 04 70 
       01 00       
042304             0234*  
042304             0235*  ; files_list: ; filename:
042304 73 70 72 69 0236*  fn_blinky_0: db "sprites/blinky_0.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 30 
       2E 72 67 62 
       61 32 00    
04231B 73 70 72 69 0237*  fn_blinky_1: db "sprites/blinky_1.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 31 
       2E 72 67 62 
       61 32 00    
042332 73 70 72 69 0238*  fn_blinky_2: db "sprites/blinky_2.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 32 
       2E 72 67 62 
       61 32 00    
042349 73 70 72 69 0239*  fn_blinky_3: db "sprites/blinky_3.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 33 
       2E 72 67 62 
       61 32 00    
042360 73 70 72 69 0240*  fn_blinky_4: db "sprites/blinky_4.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 34 
       2E 72 67 62 
       61 32 00    
042377 73 70 72 69 0241*  fn_blinky_5: db "sprites/blinky_5.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 35 
       2E 72 67 62 
       61 32 00    
04238E 73 70 72 69 0242*  fn_blinky_6: db "sprites/blinky_6.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 36 
       2E 72 67 62 
       61 32 00    
0423A5 73 70 72 69 0243*  fn_blinky_7: db "sprites/blinky_7.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 37 
       2E 72 67 62 
       61 32 00    
0423BC 73 70 72 69 0244*  fn_clyde_0: db "sprites/clyde_0.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 30 2E 
       72 67 62 61 
       32 00       
0423D2 73 70 72 69 0245*  fn_clyde_1: db "sprites/clyde_1.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 31 2E 
       72 67 62 61 
       32 00       
0423E8 73 70 72 69 0246*  fn_clyde_2: db "sprites/clyde_2.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 32 2E 
       72 67 62 61 
       32 00       
0423FE 73 70 72 69 0247*  fn_clyde_3: db "sprites/clyde_3.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 33 2E 
       72 67 62 61 
       32 00       
042414 73 70 72 69 0248*  fn_clyde_4: db "sprites/clyde_4.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 34 2E 
       72 67 62 61 
       32 00       
04242A 73 70 72 69 0249*  fn_clyde_5: db "sprites/clyde_5.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 35 2E 
       72 67 62 61 
       32 00       
042440 73 70 72 69 0250*  fn_clyde_6: db "sprites/clyde_6.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 36 2E 
       72 67 62 61 
       32 00       
042456 73 70 72 69 0251*  fn_clyde_7: db "sprites/clyde_7.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 37 2E 
       72 67 62 61 
       32 00       
04246C 73 70 72 69 0252*  fn_fruit_0: db "sprites/fruit_0.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 30 2E 
       72 67 62 61 
       32 00       
042482 73 70 72 69 0253*  fn_fruit_1: db "sprites/fruit_1.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 31 2E 
       72 67 62 61 
       32 00       
042498 73 70 72 69 0254*  fn_fruit_2: db "sprites/fruit_2.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 32 2E 
       72 67 62 61 
       32 00       
0424AE 73 70 72 69 0255*  fn_fruit_3: db "sprites/fruit_3.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 33 2E 
       72 67 62 61 
       32 00       
0424C4 73 70 72 69 0256*  fn_fruit_4: db "sprites/fruit_4.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 34 2E 
       72 67 62 61 
       32 00       
0424DA 73 70 72 69 0257*  fn_fruit_5: db "sprites/fruit_5.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 35 2E 
       72 67 62 61 
       32 00       
0424F0 73 70 72 69 0258*  fn_fruit_6: db "sprites/fruit_6.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 36 2E 
       72 67 62 61 
       32 00       
042506 73 70 72 69 0259*  fn_fruit_7: db "sprites/fruit_7.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 37 2E 
       72 67 62 61 
       32 00       
04251C 73 70 72 69 0260*  fn_inky_0: db "sprites/inky_0.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 30 2E 72 
       67 62 61 32 
       00          
042531 73 70 72 69 0261*  fn_inky_1: db "sprites/inky_1.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 31 2E 72 
       67 62 61 32 
       00          
042546 73 70 72 69 0262*  fn_inky_2: db "sprites/inky_2.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 32 2E 72 
       67 62 61 32 
       00          
04255B 73 70 72 69 0263*  fn_inky_3: db "sprites/inky_3.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 33 2E 72 
       67 62 61 32 
       00          
042570 73 70 72 69 0264*  fn_inky_4: db "sprites/inky_4.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 34 2E 72 
       67 62 61 32 
       00          
042585 73 70 72 69 0265*  fn_inky_5: db "sprites/inky_5.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 35 2E 72 
       67 62 61 32 
       00          
04259A 73 70 72 69 0266*  fn_inky_6: db "sprites/inky_6.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 36 2E 72 
       67 62 61 32 
       00          
0425AF 73 70 72 69 0267*  fn_inky_7: db "sprites/inky_7.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 37 2E 72 
       67 62 61 32 
       00          
0425C4 73 70 72 69 0268*  fn_maze_pellets_00: db "sprites/maze_pellets_00.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 30 2E 
       72 67 62 61 
       32 00       
0425E2 73 70 72 69 0269*  fn_maze_pellets_01: db "sprites/maze_pellets_01.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 31 2E 
       72 67 62 61 
       32 00       
042600 73 70 72 69 0270*  fn_maze_pellets_02: db "sprites/maze_pellets_02.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 32 2E 
       72 67 62 61 
       32 00       
04261E 73 70 72 69 0271*  fn_pac_big_00_00: db "sprites/pac_big_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
04263A 73 70 72 69 0272*  fn_pac_big_00_01: db "sprites/pac_big_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
042656 73 70 72 69 0273*  fn_pac_big_00_02: db "sprites/pac_big_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
042672 73 70 72 69 0274*  fn_pac_ded_00_00: db "sprites/pac_ded_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
04268E 73 70 72 69 0275*  fn_pac_ded_00_01: db "sprites/pac_ded_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
0426AA 73 70 72 69 0276*  fn_pac_ded_00_02: db "sprites/pac_ded_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
0426C6 73 70 72 69 0277*  fn_pac_ded_00_03: db "sprites/pac_ded_00_03.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       33 2E 72 67 
       62 61 32 00 
0426E2 73 70 72 69 0278*  fn_pac_ded_00_04: db "sprites/pac_ded_00_04.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       34 2E 72 67 
       62 61 32 00 
0426FE 73 70 72 69 0279*  fn_pac_ded_00_05: db "sprites/pac_ded_00_05.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       35 2E 72 67 
       62 61 32 00 
04271A 73 70 72 69 0280*  fn_pac_ded_00_06: db "sprites/pac_ded_00_06.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       36 2E 72 67 
       62 61 32 00 
042736 73 70 72 69 0281*  fn_pac_ded_00_07: db "sprites/pac_ded_00_07.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       37 2E 72 67 
       62 61 32 00 
042752 73 70 72 69 0282*  fn_pac_ded_00_08: db "sprites/pac_ded_00_08.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       38 2E 72 67 
       62 61 32 00 
04276E 73 70 72 69 0283*  fn_pac_ded_00_09: db "sprites/pac_ded_00_09.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       39 2E 72 67 
       62 61 32 00 
04278A 73 70 72 69 0284*  fn_pac_ded_00_10: db "sprites/pac_ded_00_10.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 31 
       30 2E 72 67 
       62 61 32 00 
0427A6 73 70 72 69 0285*  fn_pac_liv_00_00: db "sprites/pac_liv_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6C 69 76 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
0427C2 73 70 72 69 0286*  fn_pac_man_00_00: db "sprites/pac_man_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
0427DE 73 70 72 69 0287*  fn_pac_man_00_01: db "sprites/pac_man_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
0427FA 73 70 72 69 0288*  fn_pac_man_00_02: db "sprites/pac_man_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
042816 73 70 72 69 0289*  fn_pac_man_01_00: db "sprites/pac_man_01_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       30 2E 72 67 
       62 61 32 00 
042832 73 70 72 69 0290*  fn_pac_man_01_01: db "sprites/pac_man_01_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       31 2E 72 67 
       62 61 32 00 
04284E 73 70 72 69 0291*  fn_pac_man_01_02: db "sprites/pac_man_01_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       32 2E 72 67 
       62 61 32 00 
04286A 73 70 72 69 0292*  fn_pac_man_02_00: db "sprites/pac_man_02_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       30 2E 72 67 
       62 61 32 00 
042886 73 70 72 69 0293*  fn_pac_man_02_01: db "sprites/pac_man_02_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       31 2E 72 67 
       62 61 32 00 
0428A2 73 70 72 69 0294*  fn_pac_man_02_02: db "sprites/pac_man_02_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       32 2E 72 67 
       62 61 32 00 
0428BE 73 70 72 69 0295*  fn_pac_man_03_00: db "sprites/pac_man_03_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       30 2E 72 67 
       62 61 32 00 
0428DA 73 70 72 69 0296*  fn_pac_man_03_01: db "sprites/pac_man_03_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       31 2E 72 67 
       62 61 32 00 
0428F6 73 70 72 69 0297*  fn_pac_man_03_02: db "sprites/pac_man_03_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       32 2E 72 67 
       62 61 32 00 
042912 73 70 72 69 0298*  fn_pinky_0: db "sprites/pinky_0.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 30 2E 
       72 67 62 61 
       32 00       
042928 73 70 72 69 0299*  fn_pinky_1: db "sprites/pinky_1.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 31 2E 
       72 67 62 61 
       32 00       
04293E 73 70 72 69 0300*  fn_pinky_2: db "sprites/pinky_2.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 32 2E 
       72 67 62 61 
       32 00       
042954 73 70 72 69 0301*  fn_pinky_3: db "sprites/pinky_3.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 33 2E 
       72 67 62 61 
       32 00       
04296A 73 70 72 69 0302*  fn_pinky_4: db "sprites/pinky_4.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 34 2E 
       72 67 62 61 
       32 00       
042980 73 70 72 69 0303*  fn_pinky_5: db "sprites/pinky_5.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 35 2E 
       72 67 62 61 
       32 00       
042996 73 70 72 69 0304*  fn_pinky_6: db "sprites/pinky_6.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 36 2E 
       72 67 62 61 
       32 00       
0429AC 73 70 72 69 0305*  fn_pinky_7: db "sprites/pinky_7.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 37 2E 
       72 67 62 61 
       32 00       
0429C2 73 70 72 69 0306*  fn_reverse_0: db "sprites/reverse_0.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       30 2E 72 67 
       62 61 32 00 
0429DA 73 70 72 69 0307*  fn_reverse_1: db "sprites/reverse_1.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       31 2E 72 67 
       62 61 32 00 
0429F2 73 70 72 69 0308*  fn_reverse_2: db "sprites/reverse_2.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       32 2E 72 67 
       62 61 32 00 
042A0A 73 70 72 69 0309*  fn_reverse_3: db "sprites/reverse_3.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       33 2E 72 67 
       62 61 32 00 
042A22 73 70 72 69 0310*  fn_reverse_4: db "sprites/reverse_4.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       34 2E 72 67 
       62 61 32 00 
042A3A 73 70 72 69 0311*  fn_reverse_5: db "sprites/reverse_5.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       35 2E 72 67 
       62 61 32 00 
042A52 73 70 72 69 0312*  fn_reverse_6: db "sprites/reverse_6.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       36 2E 72 67 
       62 61 32 00 
042A6A 73 70 72 69 0313*  fn_reverse_7: db "sprites/reverse_7.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       37 2E 72 67 
       62 61 32 00 
042A82 73 70 72 69 0314*  fn_tile_00: db "sprites/tile_00.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 30 2E 
       72 67 62 61 
       32 00       
042A98 73 70 72 69 0315*  fn_tile_01: db "sprites/tile_01.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 31 2E 
       72 67 62 61 
       32 00       
042AAE 73 70 72 69 0316*  fn_tile_02: db "sprites/tile_02.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 32 2E 
       72 67 62 61 
       32 00       
042AC4 73 70 72 69 0317*  fn_tile_03: db "sprites/tile_03.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 33 2E 
       72 67 62 61 
       32 00       
042ADA 73 70 72 69 0318*  fn_tile_04: db "sprites/tile_04.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 34 2E 
       72 67 62 61 
       32 00       
042AF0 73 70 72 69 0319*  fn_tile_05: db "sprites/tile_05.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 35 2E 
       72 67 62 61 
       32 00       
042B06 73 70 72 69 0320*  fn_tile_06: db "sprites/tile_06.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 36 2E 
       72 67 62 61 
       32 00       
042B1C 73 70 72 69 0321*  fn_tile_07: db "sprites/tile_07.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 37 2E 
       72 67 62 61 
       32 00       
042B32 73 70 72 69 0322*  fn_tile_08: db "sprites/tile_08.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 38 2E 
       72 67 62 61 
       32 00       
042B48 73 70 72 69 0323*  fn_tile_09: db "sprites/tile_09.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 39 2E 
       72 67 62 61 
       32 00       
042B5E 73 70 72 69 0324*  fn_tile_10: db "sprites/tile_10.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 30 2E 
       72 67 62 61 
       32 00       
042B74 73 70 72 69 0325*  fn_tile_11: db "sprites/tile_11.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 31 2E 
       72 67 62 61 
       32 00       
042B8A 73 70 72 69 0326*  fn_tile_12: db "sprites/tile_12.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 32 2E 
       72 67 62 61 
       32 00       
042BA0 73 70 72 69 0327*  fn_tile_13: db "sprites/tile_13.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 33 2E 
       72 67 62 61 
       32 00       
042BB6 73 70 72 69 0328*  fn_tile_14: db "sprites/tile_14.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 34 2E 
       72 67 62 61 
       32 00       
042BCC 73 70 72 69 0329*  fn_tile_15: db "sprites/tile_15.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 35 2E 
       72 67 62 61 
       32 00       
042BE2 73 70 72 69 0330*  fn_tile_16: db "sprites/tile_16.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 36 2E 
       72 67 62 61 
       32 00       
042BF8 73 70 72 69 0331*  fn_tile_17: db "sprites/tile_17.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 37 2E 
       72 67 62 61 
       32 00       
042C0E 73 70 72 69 0332*  fn_tile_18: db "sprites/tile_18.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 38 2E 
       72 67 62 61 
       32 00       
042C24 73 70 72 69 0333*  fn_tile_19: db "sprites/tile_19.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 39 2E 
       72 67 62 61 
       32 00       
042C3A 73 70 72 69 0334*  fn_tile_20: db "sprites/tile_20.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 30 2E 
       72 67 62 61 
       32 00       
042C50 73 70 72 69 0335*  fn_tile_21: db "sprites/tile_21.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 31 2E 
       72 67 62 61 
       32 00       
042C66 73 70 72 69 0336*  fn_tile_22: db "sprites/tile_22.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 32 2E 
       72 67 62 61 
       32 00       
042C7C 73 70 72 69 0337*  fn_tile_23: db "sprites/tile_23.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 33 2E 
       72 67 62 61 
       32 00       
042C92 73 70 72 69 0338*  fn_tile_24: db "sprites/tile_24.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 34 2E 
       72 67 62 61 
       32 00       
042CA8 73 70 72 69 0339*  fn_tile_25: db "sprites/tile_25.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 35 2E 
       72 67 62 61 
       32 00       
042CBE 73 70 72 69 0340*  fn_tile_26: db "sprites/tile_26.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 36 2E 
       72 67 62 61 
       32 00       
042CD4 73 70 72 69 0341*  fn_tile_27: db "sprites/tile_27.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 37 2E 
       72 67 62 61 
       32 00       
042CEA 73 70 72 69 0342*  fn_tile_28: db "sprites/tile_28.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 38 2E 
       72 67 62 61 
       32 00       
042D00 73 70 72 69 0343*  fn_tile_29: db "sprites/tile_29.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 39 2E 
       72 67 62 61 
       32 00       
042D16 73 70 72 69 0344*  fn_tile_30: db "sprites/tile_30.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 30 2E 
       72 67 62 61 
       32 00       
042D2C 73 70 72 69 0345*  fn_tile_31: db "sprites/tile_31.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 31 2E 
       72 67 62 61 
       32 00       
042D42 73 70 72 69 0346*  fn_tile_32: db "sprites/tile_32.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 32 2E 
       72 67 62 61 
       32 00       
042D58 73 70 72 69 0347*  fn_tile_33: db "sprites/tile_33.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 33 2E 
       72 67 62 61 
       32 00       
042D6E 73 70 72 69 0348*  fn_tile_34: db "sprites/tile_34.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 34 2E 
       72 67 62 61 
       32 00       
042D84             0045       include "maze.inc"
042D84             0001*  maze_cols: equ 0
042D84             0002*  maze_rows: equ 3
042D84             0003*  maze_tile_size: equ 6
042D84             0004*  maze_null_tile: equ 9
042D84             0005*  maze_x: equ 12
042D84             0006*  maze_y: equ 15
042D84             0007*  maze_base_bufferId: equ 18
042D84             0008*  
042D84             0009*  ; draw a maze based on a maze definition table
042D84             0010*  ; inputs: ix = pointer to maze definition table
042D84             0011*  ; outputs: pretty pixels
042D84             0012*  ; destroys: all the things
042D84             0013*  ; TODO: this could be significantly simplified if the null tile number
042D84             0014*  ;       and low byte of the base bufferId are 0
042D84             0015*  draw_maze:
042D84             0016*  ; initialize variables
042D84 DD E5       0017*      push ix
042D86 FD E1       0018*      pop iy
042D88 ED 32 15    0019*      lea ix,ix+maze_base_bufferId+3 ; point to the first cell of the maze data
042D8B 21 00 00 00 0020*      ld hl,0
042D8F FD 2F 0C    0021*      ld (iy+maze_x),hl
042D92 FD 2F 0F    0022*      ld (iy+maze_y),hl
042D95 FD 6E 00    0023*      ld l,(iy+maze_cols) ; l = num cols
042D98 FD 66 03    0024*      ld h,(iy+maze_rows) ; h = num rows
042D9B             0025*  @loop:
042D9B E5          0026*      push hl ; row/col loop counter
042D9C DD 7E 00    0027*      ld a,(ix) ; tile number
042D9F FD BE 09    0028*      cp (iy+maze_null_tile) ; is it the null tile?
042DA2 28 19       0029*      jr z,@next_tile
042DA4 FD 27 12    0030*      ld hl,(iy+maze_base_bufferId) ; base bufferId
042DA7 11 00 00 00 0031*      ld de,0 ; clear deu and d
042DAB DD 5E 00    0032*      ld e,(ix) ; tile number
042DAE 19          0033*      add hl,de ; hl = tile bufferId
042DAF             0034*      ; push hl ; DEBUG
042DAF CD C2 14 04 0035*      call vdu_buff_select
042DB3 FD 07 0C    0036*      ld bc,(iy+maze_x) ; x-coordinate
042DB6 FD 17 0F    0037*      ld de,(iy+maze_y) ; y-coordinate
042DB9             0038*      ; pop hl ; DEBUG
042DB9             0039*      ; call dumpRegistersHex ; DEBUG
042DB9             0040*      ; call waitKeypress ; DEBUG
042DB9 CD 1E 18 04 0041*      call vdu_plot_bmp
042DBD             0042*  @next_tile:
042DBD FD 27 0C    0043*      ld hl,(iy+maze_x) ; x-coordinate
042DC0 FD 17 06    0044*      ld de,(iy+maze_tile_size) ; tile size
042DC3 19          0045*      add hl,de ; x-coordinate + tile size
042DC4 FD 2F 0C    0046*      ld (iy+maze_x),hl ; x-coordinate = x-coordinate + tile size
042DC7 DD 23       0047*      inc ix ; bump pointer to next tile
042DC9 E1          0048*      pop hl ; row/col loop counter
042DCA 2D          0049*      dec l
042DCB C2 9B 2D 04 0050*      jp nz,@loop
042DCF             0051*  ; ; DEBUG
042DCF             0052*  ;     push hl
042DCF             0053*  ;     call dumpRegistersHex
042DCF             0054*  ;     call waitKeypress
042DCF             0055*  ;     pop hl
042DCF             0056*  ; ; END DEBUG
042DCF 25          0057*      dec h
042DD0 C8          0058*      ret z ; done
042DD1 FD 6E 00    0059*      ld l,(iy+maze_cols) ; number of columns
042DD4 E5          0060*      push hl
042DD5 FD 27 0F    0061*      ld hl,(iy+maze_y) ; y-coordinate
042DD8 FD 17 06    0062*      ld de,(iy+maze_tile_size) ; tile size
042DDB 19          0063*      add hl,de ; y-coordinate + tile size
042DDC FD 2F 0F    0064*      ld (iy+maze_y),hl ; y-coordinate = y-coordinate + tile size
042DDF 21 00 00 00 0065*      ld hl,0 ; x-coordinate
042DE3 FD 2F 0C    0066*      ld (iy+maze_x),hl ; x-coordinate = 0
042DE6 E1          0067*      pop hl
042DE7 C3 9B 2D 04 0068*      jp @loop
042DEB             0046       include "maze_walls.inc"
042DEB             0001*  ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
042DEB             0002*  
042DEB             0003*  maze_walls:
042DEB 1C 00 00    0004*  maze_walls_num_cols: dl 28
042DEE 1F 00 00    0005*  maze_walls_num_rows: dl 31
042DF1 08 00 00    0006*  maze_walls_tile_size: dl 8
042DF4 06 00 00    0007*  maze_walls_null_tile: dl 6
042DF7 00 00 00    0008*  maze_walls_x: dl 0
042DFA 00 00 00    0009*  maze_walls_y: dl 0
042DFD 4E 01 00    0010*  maze_walls_base_bufferId: dl BUF_TILE_00
042E00             0011*  
042E00             0012*  maze_walls_map:
042E00 00 01 01 01 0013*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,02,03,01,01,01,01,01,01,01,01,01,01,01,01,04
       01 01 01 01 
       01 01 01 01 
       01 02 03 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 04 
042E1C 05 06 06 06 0014*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 07 08 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
042E38 05 06 0A 0B 0015*      db 05,06,10,11,11,12,06,10,11,11,11,12,06,07,08,06,10,11,11,11,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0B 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 0B 
       0C 06 0A 0B 
       0B 0C 06 09 
042E54 05 06 07 06 0016*      db 05,06,07,06,06,08,06,07,06,06,06,08,06,07,08,06,07,06,06,06,08,06,07,06,06,08,06,09
       06 08 06 07 
       06 06 06 08 
       06 07 08 06 
       07 06 06 06 
       08 06 07 06 
       06 08 06 09 
042E70 05 06 0D 0E 0017*      db 05,06,13,14,14,15,06,13,14,14,14,15,06,13,15,06,13,14,14,14,15,06,13,14,14,15,06,09
       0E 0F 06 0D 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0F 06 0D 0E 
       0E 0F 06 09 
042E8C 05 06 06 06 0018*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
042EA8 05 06 0A 0B 0019*      db 05,06,10,11,11,12,06,10,12,06,10,11,11,11,11,11,11,12,06,10,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0C 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 0A 
       0C 06 0A 0B 
       0B 0C 06 09 
042EC4 05 06 0D 0E 0020*      db 05,06,13,14,14,15,06,07,08,06,13,14,14,16,17,14,14,15,06,07,08,06,13,14,14,15,06,09
       0E 0F 06 07 
       08 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 07 
       08 06 0D 0E 
       0E 0F 06 09 
042EE0 05 06 06 06 0021*      db 05,06,06,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,06,06,09
       06 06 06 07 
       08 06 06 06 
       06 07 08 06 
       06 06 06 07 
       08 06 06 06 
       06 06 06 09 
042EFC 12 13 13 13 0022*      db 18,19,19,19,19,12,06,07,20,11,11,12,06,07,08,06,10,11,11,21,08,06,10,19,19,19,19,22
       13 0C 06 07 
       14 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 15 
       08 06 0A 13 
       13 13 13 16 
042F18 06 06 06 06 0023*      db 06,06,06,06,06,05,06,07,17,14,14,15,06,13,15,06,13,14,14,16,08,06,09,06,06,06,06,06
       06 05 06 07 
       11 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 10 
       08 06 09 06 
       06 06 06 06 
042F34 06 06 06 06 0024*      db 06,06,06,06,06,05,06,07,08,06,06,06,06,06,06,06,06,06,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 06 06 
       06 06 06 06 
       06 06 06 07 
       08 06 09 06 
       06 06 06 06 
042F50 06 06 06 06 0025*      db 06,06,06,06,06,05,06,07,08,06,23,19,24,06,06,25,19,26,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 17 13 
       18 06 06 19 
       13 1A 06 07 
       08 06 09 06 
       06 06 06 06 
042F6C 01 01 01 01 0026*      db 01,01,01,01,01,15,06,13,15,06,09,06,06,06,06,06,06,05,06,13,15,06,13,01,01,01,01,01
       01 0F 06 0D 
       0F 06 09 06 
       06 06 06 06 
       06 05 06 0D 
       0F 06 0D 01 
       01 01 01 01 
042F88 06 06 06 06 0027*      db 06,06,06,06,06,06,06,06,06,06,09,06,06,06,06,06,06,05,06,06,06,06,06,06,06,06,06,06
       06 06 06 06 
       06 06 09 06 
       06 06 06 06 
       06 05 06 06 
       06 06 06 06 
       06 06 06 06 
042FA4 13 13 13 13 0028*      db 19,19,19,19,19,12,06,10,12,06,09,06,06,06,06,06,06,05,06,10,12,06,10,19,19,19,19,19
       13 0C 06 0A 
       0C 06 09 06 
       06 06 06 06 
       06 05 06 0A 
       0C 06 0A 13 
       13 13 13 13 
042FC0 06 06 06 06 0029*      db 06,06,06,06,06,05,06,07,08,06,27,01,01,01,01,01,01,28,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 1B 01 
       01 01 01 01 
       01 1C 06 07 
       08 06 09 06 
       06 06 06 06 
042FDC 06 06 06 06 0030*      db 06,06,06,06,06,05,06,07,08,06,06,06,06,06,06,06,06,06,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 06 06 
       06 06 06 06 
       06 06 06 07 
       08 06 09 06 
       06 06 06 06 
042FF8 06 06 06 06 0031*      db 06,06,06,06,06,05,06,07,08,06,10,11,11,11,11,11,11,12,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 07 
       08 06 09 06 
       06 06 06 06 
043014 00 01 01 01 0032*      db 00,01,01,01,01,15,06,13,15,06,13,14,14,16,17,14,14,15,06,13,15,06,13,01,01,01,01,29
       01 0F 06 0D 
       0F 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 0D 
       0F 06 0D 01 
       01 01 01 1D 
043030 05 06 06 06 0033*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 07 08 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
04304C 05 06 0A 0B 0034*      db 05,06,10,11,11,12,06,10,11,11,11,12,06,07,08,06,10,11,11,11,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0B 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 0B 
       0C 06 0A 0B 
       0B 0C 06 09 
043068 05 06 0D 0E 0035*      db 05,06,13,14,16,08,06,13,14,14,14,15,06,13,15,06,13,14,14,14,15,06,07,17,14,15,06,09
       10 08 06 0D 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0F 06 07 11 
       0E 0F 06 09 
043084 05 06 06 06 0036*      db 05,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,09
       07 08 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 07 08 
       06 06 06 09 
0430A0 1E 0B 0C 06 0037*      db 30,11,12,06,07,08,06,10,12,06,10,11,11,11,11,11,11,12,06,10,12,06,07,08,06,10,11,31
       07 08 06 0A 
       0C 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 0A 
       0C 06 07 08 
       06 0A 0B 1F 
0430BC 20 0E 0F 06 0038*      db 32,14,15,06,13,15,06,07,08,06,13,14,14,16,17,14,14,15,06,07,08,06,13,15,06,13,14,33
       0D 0F 06 07 
       08 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 07 
       08 06 0D 0F 
       06 0D 0E 21 
0430D8 05 06 06 06 0039*      db 05,06,06,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,06,06,09
       06 06 06 07 
       08 06 06 06 
       06 07 08 06 
       06 06 06 07 
       08 06 06 06 
       06 06 06 09 
0430F4 05 06 0A 0B 0040*      db 05,06,10,11,11,11,11,21,20,11,11,12,06,07,08,06,10,11,11,21,20,11,11,11,11,12,06,09
       0B 0B 0B 15 
       14 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 15 
       14 0B 0B 0B 
       0B 0C 06 09 
043110 05 06 0D 0E 0041*      db 05,06,13,14,14,14,14,14,14,14,14,15,06,13,15,06,13,14,14,14,14,14,14,14,14,15,06,09
       0E 0E 0E 0E 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0E 0E 0E 0E 
       0E 0F 06 09 
04312C 05 06 06 06 0042*      db 05,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
043148 12 13 13 13 0043*      db 18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,34
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 22 
043164             0047       include "maze_pellets.inc"
043164             0001*  ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
043164             0002*  
043164             0003*  maze_pellets:
043164 1C 00 00    0004*  maze_pellets_num_cols: dl 28
043167 1F 00 00    0005*  maze_pellets_num_rows: dl 31
04316A 08 00 00    0006*  maze_pellets_tile_size: dl 8
04316D 00 00 00    0007*  maze_pellets_null_tile: dl 0
043170 00 00 00    0008*  maze_pellets_x: dl 0
043173 00 00 00    0009*  maze_pellets_y: dl 0
043176 20 01 00    0010*  maze_pellets_base_bufferId: dl BUF_MAZE_PELLETS_00
043179             0011*  
043179             0012*  maze_pellets_map:
043179 00 00 00 00 0013*      db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043195 00 01 01 01 0014*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 00 00 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
0431B1 00 01 00 00 0015*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
0431CD 00 02 00 00 0016*      db 00,02,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,02,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 02 00 
0431E9 00 01 00 00 0017*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
043205 00 01 01 01 0018*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043221 00 01 00 00 0019*      db 00,01,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 01 00 
04323D 00 01 00 00 0020*      db 00,01,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 01 00 
043259 00 01 01 01 0021*      db 00,01,01,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,01,01,00
       01 01 01 00 
       00 01 01 01 
       01 00 00 01 
       01 01 01 00 
       00 01 01 01 
       01 01 01 00 
043275 00 00 00 00 0022*      db 00,00,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 00 00 
043291 00 00 00 00 0023*      db 00,00,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 00 00 
0432AD 00 00 00 00 0024*      db 00,00,00,00,00,00,01,00,00,01,01,01,01,01,01,01,01,01,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 01 01 
       01 01 01 01 
       01 01 01 00 
       00 01 00 00 
       00 00 00 00 
0432C9 00 00 00 00 0025*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
0432E5 00 00 00 00 0026*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043301 01 01 01 01 0027*      db 01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,00,00,00,01,01,01,01,01,01,01,01,01,01
       01 01 01 01 
       01 01 00 00 
       00 00 00 00 
       00 00 01 01 
       01 01 01 01 
       01 01 01 01 
04331D 00 00 00 00 0028*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043339 00 00 00 00 0029*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043355 00 00 00 00 0030*      db 00,00,00,00,00,00,01,00,00,01,01,01,01,01,01,01,01,01,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 01 01 
       01 01 01 01 
       01 01 01 00 
       00 01 00 00 
       00 00 00 00 
043371 00 00 00 00 0031*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
04338D 00 00 00 00 0032*      db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
0433A9 00 01 01 01 0033*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 00 00 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
0433C5 00 01 00 00 0034*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
0433E1 00 01 00 00 0035*      db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
0433FD 00 02 01 01 0036*      db 00,02,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,02,00
       00 00 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 00 00 
       01 01 02 00 
043419 00 00 00 01 0037*      db 00,00,00,01,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,01,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       01 00 00 00 
043435 00 00 00 01 0038*      db 00,00,00,01,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,01,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       01 00 00 00 
043451 00 01 01 01 0039*      db 00,01,01,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,01,01,00
       01 01 01 00 
       00 01 01 01 
       01 00 00 01 
       01 01 01 00 
       00 01 01 01 
       01 01 01 00 
04346D 00 01 00 00 0040*      db 00,01,00,00,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,00,00,01,00
       00 00 00 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 00 00 00 
       00 00 01 00 
043489 00 01 00 00 0041*      db 00,01,00,00,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,00,00,01,00
       00 00 00 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 00 00 00 
       00 00 01 00 
0434A5 00 01 01 01 0042*      db 00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
0434C1 00 00 00 00 0043*      db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0434DD             0048       include "player.inc"
0434DD             0001*  ; ######## GAME STATE VARIABLES #######
0434DD 00 00 00    0002*  player_score: dl 0 ; integer
0434E0 03          0003*  player_lives: db 3 ; integer
0434E1             0004*  speed_player: equ 1*256 ; 1 pixels per frame 16.8 fixed
0434E1             0005*  
0434E1             0006*  ; ######### PLAYER SPRITE PARAMETERS ##########
0434E1             0007*  ; uses the same offsets from its table base as the main sprite table:
0434E1             0008*  player_start_variables: ; label marking beginning of table
0434E1 0F          0009*  player_id:               db table_max_records-1
0434E2 00          0010*  player_type:             db     0x00 ; 1 bytes currently not used
0434E3 32 01 00    0011*  player_base_bufferId:    dl BUF_PAC_MAN_00_00 ; 3 bytes bitmap bufferId
0434E6 00 00 00    0012*  player_move_program:     dl 0x000000 ; 3 bytes not currently used
0434E9 00          0013*  player_collisions:       db     0x00 ; 1 bytes uses sprite_alive and sprite_just_died flags
0434EA 00          0014*  player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
0434EB 00          0015*  player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
0434EC 00 00 00    0016*  player_x:                dl 0x000000 ; 3 bytes 16.8 fractional x position in pixels
0434EF 00 00 00    0017*  player_y:                dl 0x000000 ; 3 bytes 16.8 fractional y position in pixels
0434F2 00 00 00    0018*  player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
0434F5 00 00 00    0019*  player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
0434F8 00 00 00    0020*  player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
0434FB 00 00 00    0021*  player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
0434FE 01 00 00    0022*  player_orientation:      dl 1 ; 3 bytes, low four bits are direction mask, bit 0 = right
043501 00          0023*  player_animation:        db     0x00 ; 1 bytes current animation index, zero-based
043502 08          0024*  player_animation_timer:  db     8 ; 1 bytes
043503 00          0025*  player_move_timer:       db     0x00 ; 1 bytes not currently used
043504 00          0026*  player_move_step:        db     0x00 ; 1 bytes not currently used
043505 00          0027*  player_points:           db     0x00 ; 1 bytes not currently used
043506 00          0028*  player_shield_damage:    db     0x00 ; 1 bytes not currently used
043507             0029*  player_end_variables: ; for when we want to traverse this table in reverse
043507             0030*  
043507             0031*  orient_up: equ 2
043507             0032*  orient_left: equ 1
043507             0033*  orient_down: equ 3
043507             0034*  orient_right: equ 0
043507             0035*  
043507             0036*  ; set initial player position
043507             0037*  ; inputs: none,everything is hardcoded
043507             0038*  ; outputs: player_x/y set to bottom-left corner of screen
043507             0039*  ; destroys: a
043507             0040*  player_init:
043507 3A E1 34 04 0041*  	ld a,(player_id)
04350B CD BF 18 04 0042*  	call vdu_sprite_select
04350F CD D2 18 04 0043*      call vdu_sprite_clear_frames
043513 21 32 01 00 0044*      ld hl,BUF_PAC_MAN_00_00
043517 06 0C       0045*      ld b,12 ; number of frames in the sprite
043519             0046*  @loop:
043519 C5          0047*      push bc ; backup loop counter
04351A E5          0048*      push hl
04351B CD 14 1A 04 0049*      call vdu_sprite_add_buff
04351F E1          0050*      pop hl
043520 23          0051*      inc hl
043521 C1          0052*      pop bc
043522 10 F5       0053*      djnz @loop
043524             0054*  ; initialize player position
043524 01 00 00 00 0055*      ld bc,0
043528 ED 43 EC 34 0056*      ld (player_x),bc
       04          
04352D 11 00 6F 01 0057*      ld de,sprite_bottom*256 ; max sprite y-coordinate
043531 ED 53 EF 34 0058*      ld (player_y),de
       04          
043536 CD 8B 19 04 0059*      call vdu_sprite_move_abs168
04353A CD 35 19 04 0060*      call vdu_sprite_show
04353E 21 D5 3A 04 0061*      ld hl,player_alive
043542 22 C7 3A 04 0062*      ld (player_state),hl
043546 21 E9 34 04 0063*      ld hl,player_collisions
04354A CB F6       0064*      set sprite_alive,(hl)
04354C             0065*  
04354C             0066*  ; ; DEBUG
04354C             0067*  ;     ld hl,speed_player
04354C             0068*  ;     ld (player_xvel),hl
04354C             0069*  ; ; END DEBUG
04354C C9          0070*      ret
04354D             0071*  
04354D             0072*  ; process player keyboard input, set player bitmap
04354D             0073*  ; velocities and draw player bitmap at updated coordinates
04354D             0074*  ; Inputs: player_x/y set at desired position
04354D             0075*  ; Returns: player bitmap drawn at updated position
04354D             0076*  ; Destroys: probably everything except maybe iy
04354D             0077*  ; NOTE: in mode 9 we draw the player as a sprite, not a bitmap
04354D             0078*  ; TODO: requires sprite implementation
04354D             0079*  player_input:
04354D             0080*  ; set player as the active sprite
04354D FD 21 E1 34 0081*      ld iy,player_start_variables
       04          
043552 FD 22 C4 38 0082*      ld (table_pointer),iy
       04          
043557 FD 7E 00    0083*      ld a,(iy+sprite_id)
04355A CD BF 18 04 0084*      call vdu_sprite_select
04355E             0085*  ; DEBUG
04355E CD 8A 13 04 0086*      call vdu_home_cursor
043562             0087*  ; END DEBUG
043562             0088*  ; did we die last frame?
043562 FD 7E 08    0089*      ld a,(iy+sprite_collisions)
043565 E6 02       0090*      and %00000010 ; zero flag will be set if not dead
043567 28 05       0091*      jr z,player_not_dead
043569             0092*  ; yes we died
043569 CD 3F 36 04 0093*      call kill_player
04356D C9          0094*      ret ; done
04356E             0095*  player_not_dead: ; yay we didn't die
04356E             0096*  ; check for keypresses and branch accordingly
04356E             0097*  ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
04356E             0098*      MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
04356E 3E 1E       0001*M 			LD	A, function
043570 5B CF       0002*M 			RST.LIL	08h
043572             0099*  ; we test all four arrow keys and add/subract velocities accordingly
043572             0100*  ; this handles the case where two opposing movement keys
043572             0101*  ; are down simultaneously (velocities will net to zero)
043572 AF          0102*      xor a ; reset orientation bits
043573             0103*  ; 26 Left: move player left
043573 DD CB 03 4E 0104*      bit 1,(ix+3)
043577 CA 7D 35 04 0105*      jp z,@F
04357B CB CF       0106*      set orient_left,a
04357D             0107*  @@:
04357D             0108*  ; 122 Right: move player right
04357D DD CB 0F 4E 0109*      bit 1,(ix+15)
043581 CA 87 35 04 0110*  	jp z,@F
043585 CB C7       0111*      set orient_right,a
043587             0112*  @@:
043587             0113*  ; 58 Up: move player up
043587 DD CB 07 4E 0114*      bit 1,(ix+7)
04358B CA 91 35 04 0115*  	jp z,@F
04358F CB D7       0116*      set orient_up,a
043591             0117*  @@:
043591             0118*  ; 42 Down: move player down
043591 DD CB 05 4E 0119*      bit 1,(ix+5)
043595 CA 9B 35 04 0120*  	jp z,@F
043599 CB DF       0121*      set orient_down,a
04359B             0122*  @@:
04359B             0123*  ; test for no keyboard input
04359B A7          0124*      and a
04359C C2 A7 35 04 0125*      jp nz,@F ; we have input
0435A0 FD 7E 1D    0126*      ld a,(iy+sprite_orientation) ; use last orientation
0435A3 C3 B2 35 04 0127*      jp @animation_timer
0435A7             0128*  @@:
0435A7             0129*  ; test for more than one input key pressed
0435A7 47          0130*      ld b,a
0435A8 3D          0131*      dec a
0435A9 A0          0132*      and a,b
0435AA 78          0133*      ld a,b
0435AB             0134*  ; zero means only one key pressed
0435AB             0135*  ; (or none, if we had not done the zero check above)
0435AB CA B2 35 04 0136*      jp z,@animation_timer
0435AF FD 7E 1D    0137*      ld a,(iy+sprite_orientation) ; use last orientation
0435B2             0138*      ; fall through to @animation_timer
0435B2             0139*  @animation_timer:
0435B2 FD 77 1D    0140*      ld (iy+sprite_orientation),a
0435B5             0141*  ; time to bump the animation frame?
0435B5 FD 35 21    0142*      dec (iy+sprite_animation_timer)
0435B8 C2 D1 35 04 0143*      jp nz,@select_frame ; not time yet
0435BC             0144*  ; reset animation timer
0435BC 3E 08       0145*      ld a,8
0435BE FD 77 21    0146*      ld (iy+sprite_animation_timer),a
0435C1             0147*  ; bump the animation frame
0435C1 FD 34 20    0148*      inc (iy+sprite_animation)
0435C4             0149*  ; time to wrap around to first frame?
0435C4 3E 03       0150*      ld a,3
0435C6 FD BE 20    0151*      cp a,(iy+sprite_animation)
0435C9 C2 D1 35 04 0152*      jp nz,@select_frame ; not time yet
0435CD             0153*  ; reset animation frame
0435CD AF          0154*      xor a
0435CE FD 77 20    0155*      ld (iy+sprite_animation),a
0435D1             0156*      ; fall through to @select_frame
0435D1             0157*  @select_frame:
0435D1 FD 7E 1D    0158*      ld a,(iy+sprite_orientation)
0435D4             0159*  ; find which bit is set in orientation
0435D4 2E 00       0160*      ld l,0 ; bit counter
0435D6             0161*  @find_bit:
0435D6 0F          0162*      rrca ; bit 0 to carry
0435D7 DA E0 35 04 0163*      jp c,@found_bit
0435DB 2C          0164*      inc l ; next bit
0435DC C3 D6 35 04 0165*      jp @find_bit
0435E0             0166*  @found_bit:
0435E0 26 03       0167*      ld h,3 ; three frames per orientation
0435E2 ED 6C       0168*      mlt hl
0435E4 FD 7E 20    0169*      ld a,(iy+sprite_animation)
0435E7 85          0170*      add a,l
0435E8 CD 22 19 04 0171*      call vdu_sprite_select_frame
0435EC             0172*  ; set player velocities based on orientation
0435EC FD 7E 1D    0173*      ld a,(iy+sprite_orientation)
0435EF 21 00 01 00 0174*      ld hl,speed_player
0435F3 CD 0C 36 04 0175*      call velocity_from_orientation
0435F7 FD 0F 11    0176*      ld (iy+sprite_xvel),bc
0435FA FD 1F 14    0177*      ld (iy+sprite_yvel),de
0435FD             0178*  ; draw player at updated position
0435FD CD 3B 39 04 0179*      call move_sprite
043601 FD 07 0B    0180*      ld bc,(iy+sprite_x)
043604 FD 17 0E    0181*      ld de,(iy+sprite_y)
043607 CD 8B 19 04 0182*  	call vdu_sprite_move_abs168
04360B             0183*  ; done
04360B C9          0184*      ret
04360C             0185*  ; end player_input
04360C             0186*  
04360C             0187*  ; inputs: a = orientation, uh.l = speed in 16.8 fixed format
04360C             0188*  ; outputs: ub.c and ud.e are vel_x and vel_y in 16.8 fixed format
04360C             0189*  velocity_from_orientation:
04360C             0190*  ; initialize velocities to zero
04360C 01 00 00 00 0191*      ld bc,0
043610 11 00 00 00 0192*      ld de,0
043614             0193*  ; test for orientation
043614 CB 4F       0194*      bit orient_left,a
043616 C2 2D 36 04 0195*      jp nz,@left
04361A CB 47       0196*      bit orient_right,a
04361C C2 34 36 04 0197*      jp nz,@right
043620 CB 57       0198*      bit orient_up,a
043622 C2 37 36 04 0199*      jp nz,@up
043626 CB 5F       0200*      bit orient_down,a
043628 C2 3D 36 04 0201*      jp nz,@down
04362C C9          0202*      ret ; no orientation set so velocities are zero
04362D             0203*  @left:
04362D CD A4 06 04 0204*      call neg_hlu
043631 E5          0205*      push hl
043632 C1          0206*      pop bc
043633 C9          0207*      ret
043634             0208*  @right:
043634 E5          0209*      push hl
043635 C1          0210*      pop bc
043636 C9          0211*      ret
043637             0212*  @up:
043637 CD A4 06 04 0213*      call neg_hlu
04363B EB          0214*      ex de,hl
04363C C9          0215*      ret
04363D             0216*  @down:
04363D EB          0217*      ex de,hl
04363E C9          0218*      ret
04363F             0219*  ; end velocity_from_orientation
04363F             0220*  
04363F             0221*  ; ###################################################################
04363F             0222*  ; TODO: the below is all stuff from the original code we need to port
04363F             0223*  ; ###################################################################
04363F             0224*  
04363F             0225*  kill_player:
04363F             0226*  ; ; set player status to dead
04363F             0227*  ;     xor a; sets all player flags to zero
04363F             0228*  ;     ld (player_collisions),a
04363F             0229*  ; ; deduct a player from the inventory
04363F             0230*  ;     ld a,(player_lives)
04363F             0231*  ;     dec a
04363F             0232*  ;     ld (player_lives),a
04363F             0233*  ; ; are we out of players?
04363F             0234*  ;     jp z,game_over
04363F             0235*  ; ; wait a few ticks
04363F             0236*  ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
04363F             0237*  ;     ld (player_move_timer),a
04363F             0238*  ; kill_player_loop:
04363F             0239*  ;     call vdu_vblank
04363F             0240*  ;     ld a,(player_move_timer)
04363F             0241*  ;     dec a
04363F             0242*  ;     ld (player_move_timer),a
04363F             0243*  ;     jr nz,kill_player_loop
04363F             0244*  ;     call player_init ; player respawn if timer zero
04363F C9          0245*      ret ; and out
043640             0246*  
043640             0247*  ; draws the player's shields level
043640             0248*  ; draw_shields:
043640             0249*  ; TODO: Agonize this routine
043640             0250*  ; ; prep the loop to draw the bars
043640             0251*  ;     ld a,(player_shields) ; snag shields
043640             0252*  ;     and a
043640             0253*  ;     ret z ; don't draw if zero shields
043640             0254*  ; ; set loop counter and drawing position
043640             0255*  ;     ld b,a ; loop counter
043640             0256*  ;     ld hl,#5300+48+12
043640             0257*  ; ; set color based on bars remaining
043640             0258*  ;     ld c,103 ; bright green 28fe0a
043640             0259*  ;     cp 9
043640             0260*  ;     jp p,draw_shields_loop
043640             0261*  ;     ld c,74 ; bright yellow eafe5b
043640             0262*  ;     cp 3
043640             0263*  ;     jp p,draw_shields_loop
043640             0264*  ;     ld c,28 ; bright red fe0a0a
043640             0265*  ; draw_shields_loop:
043640             0266*  ;     push bc ; yup,outta
043640             0267*  ;     push hl ; registers again
043640             0268*  ;     ; ld a,#A8 ; â–€,168
043640             0269*  ;     ld a,10 ; â–€,168 ; we renumber because we don't use the full charset
043640             0270*  ;     ; call draw_char
043640             0271*  ;     call draw_num ; we nuked draw_char for the time being
043640             0272*  ;     pop hl
043640             0273*  ;     ld a,8
043640             0274*  ;     add a,l
043640             0275*  ;     ld l,a
043640             0276*  ;     pop bc
043640             0277*  ;     djnz draw_shields_loop
043640             0278*      ; ret
043640             0279*  
043640             0280*  score_x: equ 0
043640             0281*  score_y: equ 1
043640             0282*  ; prints the player's score
043640             0283*  print_score:
043640             0284*  ; DEBUG
043640 0E 00       0285*      ld c,score_x
043642 06 00       0286*      ld b,score_y-1
043644 CD C1 13 04 0287*      call vdu_move_cursor
043648 CD 70 00 04 0288*      call printInline
04364C 53 63 6F 72 0289*      asciz "Score:"
       65 3A 00    
043653             0290*  ; END DEBUG
043653 0E 00       0291*      ld c,score_x
043655 06 01       0292*      ld b,score_y
043657 CD C1 13 04 0293*      call vdu_move_cursor
04365B 2A DD 34 04 0294*      ld hl,(player_score)
04365F CD 76 01 04 0295*      call printDec
043663 C9          0296*      ret
043664             0297*  
043664             0298*  ; draw_lives:
043664             0299*  ;     ld hl,player_small ; make small yellow player the active sprite
043664             0300*  ;     ld (sprite_base_bufferId),hl
043664             0301*  ;     ; ld a,#80 ; northern orientation
043664             0302*  ;     ; ld (sprite_orientation),a
043664             0303*  ;     ld hl,0 ; north
043664             0304*  ;     ld (sprite_heading),hl
043664             0305*  ;     xor a
043664             0306*  ;     ld (sprite_animation),a
043664             0307*  ;     ld a,#56 ; top of visible screen
043664             0308*  ;     ld (sprite_y+1),a
043664             0309*  ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043664             0310*  ;     ld a,(player_lives)
043664             0311*  ;     dec a ; we draw one fewer players than lives
043664             0312*  ;     ret z ; nothing to draw here, move along
043664             0313*  ;     ld b,a ; loop counter
043664             0314*  ;     ld a,256-16 ; initial x position
043664             0315*  ; draw_lives_loop:
043664             0316*  ;     ld (sprite_x+1),a
043664             0317*  ;     push af
043664             0318*  ;     push bc
043664             0319*  ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043664             0320*  ;     pop bc
043664             0321*  ;     pop af
043664             0322*  ;     sub 10
043664             0323*  ;     djnz draw_lives_loop
043664             0324*  ;     ret
043664             0049       include "sprites.inc"
043664             0001*  ; ###### SPRITE TABLE FIELD INDICES ######
043664             0002*  table_bytes_per_record: equ 38 ; 38 bytes per sprite record
043664             0003*  sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
043664             0004*  sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
043664             0005*  sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
043664             0006*  sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
043664             0007*  sprite_collisions:      equ 08 ; 1 bytes see collisions.inc constants for bit definitions
043664             0008*  sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
043664             0009*  sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
043664             0010*  sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
043664             0011*  sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
043664             0012*  sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043664             0013*  sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043664             0014*  sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
043664             0015*  sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
043664             0016*  sprite_orientation:     equ 29 ; 3 bytes orientation bits
043664             0017*  sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
043664             0018*  sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
043664             0019*  sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
043664             0020*  sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
043664             0021*  sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type
043664             0022*  sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision
043664             0023*  
043664             0024*  ; ###### SPRITE TABLE VARIABLES ######
043664             0025*  ; maximum number of sprites
043664             0026*  table_max_records: equ 16 ; it can handle more but this is pushing it
043664             0027*  table_total_bytes: equ table_max_records*table_bytes_per_record
043664             0028*  
043664             0029*  ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
043664             0030*  table_base:
043664 00 00 00 00 0031*  sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0438C4             0032*  sprite_end_variables: ; in case we want to traverse the table in reverse
0438C4             0033*  
0438C4             0034*  ; pointer to top address of current record, initialized to table_base
0438C4 64 36 04    0035*  table_pointer: dl table_base
0438C7             0036*  ; how many active sprites
0438C7 00          0037*  table_active_sprites: db 0x00
0438C8             0038*  ; flag indicating collision with screen edge
0438C8             0039*  ; uses orientation codes to specify which edge(s)
0438C8 00          0040*  sprite_screen_edge: db #00
0438C9             0041*  ; next sprite id to use
0438C9 00          0042*  sprite_next_id: db 0
0438CA             0043*  
0438CA             0044*  ; origin_top: equ 48
0438CA             0045*  origin_top: equ 0 ; DEBUG
0438CA             0046*  origin_left: equ 128
0438CA             0047*  field_top: equ 0
0438CA             0048*  field_bottom: equ 383-origin_top
0438CA             0049*  field_left: equ 0
0438CA             0050*  field_right: equ 255
0438CA             0051*  sprite_top: equ 0
0438CA             0052*  sprite_bottom: equ field_bottom-16
0438CA             0053*  sprite_left: equ field_left
0438CA             0054*  sprite_right: equ field_right-16
0438CA             0055*  
0438CA             0056*  ; ######### COLLISION SPRITE PARAMETERS ##########
0438CA             0057*  ; integer coordinates are all that are needed for collision calculations
0438CA 00          0058*  collision_x: db 0x00
0438CB 00          0059*  collision_y: db 0x00
0438CC 00          0060*  collision_dim_x: db 0x00
0438CD 00          0061*  collision_dim_y: db 0x00
0438CE             0062*  
0438CE             0063*  ; scratch variables
0438CE 00          0064*  x: db 0x00 ; 8-bit signed integer
0438CF 00          0065*  y: db 0x00 ; 8-bit signed integer
0438D0 00 00 00    0066*  x0: dl 0x000000 ; 16.8 signed fixed place
0438D3 00 00 00    0067*  y0: dl 0x000000 ; 16.8 signed fixed place
0438D6 00 00 00    0068*  incx1: dl 0x000000 ; 16.8 signed fixed place
0438D9 00 00 00    0069*  incy1: dl 0x000000 ; 16.8 signed fixed place
0438DC 00 00 00    0070*  incx2: dl 0x000000 ; 16.8 signed fixed place
0438DF 00 00 00    0071*  incy2: dl 0x000000 ; 16.8 signed fixed place
0438E2             0072*  
0438E2             0073*  ; sprite_heading: dl 0x000000 ; signed fixed 16.8
0438E2 00 00 00    0074*  radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
0438E5 00 00 00    0075*  sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
0438E8 00 00 00    0076*  cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
0438EB             0077*  
0438EB             0078*  ; gets the next available sprite id
0438EB             0079*  ; inputs; none
0438EB             0080*  ; returns: if new sprite available, a = sprite id,
0438EB             0081*  ;           ix pointing to new sprite vars, carry set
0438EB             0082*  ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
0438EB             0083*  ; destroys: a,b,hl,ix
0438EB             0084*  ; affects: bumps table_active_sprites by one
0438EB             0085*  table_get_next_id:
0438EB DD 21 64 36 0086*      ld ix,table_base
       04          
0438F0 11 26 00 00 0087*      ld de,table_bytes_per_record
0438F4 06 10       0088*      ld b,table_max_records
0438F6             0089*  @loop:
0438F6 DD 7E 01    0090*      ld a,(ix+sprite_type)
0438F9 A7          0091*      and a
0438FA 28 06       0092*      jr z,@found
0438FC DD 19       0093*      add ix,de
0438FE 10 F6       0094*      djnz @loop
043900             0095*  @notfound:
043900 AF          0096*      xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
043901 C9          0097*      ret
043902             0098*  @found:
043902             0099*  ; bump number of active sprites
043902 21 C7 38 04 0100*      ld hl,table_active_sprites
043906 34          0101*      inc (hl)
043907             0102*  ; return sprite id
043907 3E 10       0103*      ld a,table_max_records
043909 90          0104*      sub b
04390A 32 C9 38 04 0105*      ld (sprite_next_id),a
04390E 37          0106*      scf ; sets carry flag indicating we found a free sprite
04390F C9          0107*      ret ; done
043910             0108*  ; end table_get_next_id
043910             0109*  
043910             0110*  ; deactivate the sprite with the given id
043910             0111*  ; inputs: iy set to sprite record, vdu_sprite_select called
043910             0112*  ; outputs: nothing
043910             0113*  ; destroys: a,hl
043910             0114*  ; affects: decrements table_active_sprites by one
043910             0115*  table_deactivate_sprite:
043910 CD 43 19 04 0116*      call vdu_sprite_hide
043914 AF          0117*      xor a
043915 FD 77 01    0118*      ld (iy+sprite_type),a
043918 21 C7 38 04 0119*      ld hl,table_active_sprites
04391C 35          0120*      dec (hl)
04391D C9          0121*      ret
04391E             0122*  ; end table_deactivate_sprite
04391E             0123*  
04391E             0124*  sprites_init:
04391E             0125*  ; initialize sprites
04391E CD F3 19 04 0126*  	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
043922 AF          0127*  	xor a
043923             0128*  @sprite_loop:
043923 F5          0129*  	push af
043924 CD BF 18 04 0130*  	call vdu_sprite_select
043928 21 00 01 00 0131*  	ld hl,256 ; can be anything, so we just use the first one on the list
04392C CD 14 1A 04 0132*  	call vdu_sprite_add_buff
043930 F1          0133*  	pop af
043931 3C          0134*  	inc a
043932 FE 10       0135*  	cp table_max_records
043934 20 ED       0136*  	jr nz,@sprite_loop
043936 CD F3 18 04 0137*  	call vdu_sprite_activate
04393A             0138*  ; all done
04393A C9          0139*      ret
04393B             0140*  ; end sprites_init
04393B             0141*  
04393B             0142*  ; compute a sprite's new position based on its component x,y velocities
04393B             0143*  ; with screen boundary checking and update its sprite table record accordingly
04393B             0144*  ; inputs: table_pointer set to sprite record
04393B             0145*  ; returns: updated x, y positions and edge collision flags in sprite table record
04393B             0146*  ; destroys: everything
04393B             0147*  ; note: actual rendering of sprite must be handled by caller
04393B             0148*  move_sprite:
04393B FD 2A C4 38 0149*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
043940             0150*  ; x-axis movement
043940 FD 27 0B    0151*      ld hl,(iy+sprite_x)
043943 FD 17 11    0152*      ld de,(iy+sprite_xvel)
043946 19          0153*      add hl,de
043947 FD 2F 0B    0154*      ld (iy+sprite_x),hl
04394A             0155*  ; y-axis movement
04394A FD 27 0E    0156*      ld hl,(iy+sprite_y)
04394D FD 17 14    0157*      ld de,(iy+sprite_yvel)
043950 19          0158*      add hl,de
043951 FD 2F 0E    0159*      ld (iy+sprite_y),hl
043954             0160*  ; detect screen edge collisions
043954 AF          0161*      xor a ; reset screen edge collision flag and clear carry
043955 32 C8 38 04 0162*      ld (sprite_screen_edge),a
043959             0163*  ; y-axis first since we already have it in hl
043959 11 00 00 00 0164*      ld de,-sprite_top*256
04395D ED 5A       0165*      adc hl,de
04395F FA 89 39 04 0166*      jp m,@top
043963 ED 52       0167*      sbc hl,de ; hl back to original value
043965 11 00 91 FE 0168*      ld de,-sprite_bottom*256
043969 ED 5A       0169*      adc hl,de
04396B F2 93 39 04 0170*      jp p,@bottom
04396F             0171*  @xaxis:
04396F FD 27 0B    0172*      ld hl,(iy+sprite_x)
043972 11 00 00 00 0173*      ld de,-sprite_left*256
043976 ED 5A       0174*      adc hl,de
043978 FA AE 39 04 0175*      jp m,@left
04397C ED 52       0176*      sbc hl,de ; hl back to original value
04397E 11 00 11 FF 0177*      ld de,-sprite_right*256
043982 ED 5A       0178*      adc hl,de
043984 F2 BC 39 04 0179*      jp p,@right
043988             0180*  ; no edge collisions so go home
043988 C9          0181*      ret
043989             0182*  @top:
043989 3E 08       0183*      ld a,collide_top
04398B 21 00 00 00 0184*      ld hl,sprite_top*256
04398F C3 99 39 04 0185*      jp @collide_y
043993             0186*  @bottom:
043993 3E 04       0187*      ld a,collide_bottom
043995 21 00 6F 01 0188*      ld hl,sprite_bottom*256
043999             0189*  @collide_y:
043999 32 C8 38 04 0190*      ld (sprite_screen_edge),a
04399D FD 2F 0E    0191*      ld (iy+sprite_y),hl
0439A0             0192*  ; reverse y-axis velocity
0439A0 FD 27 14    0193*      ld hl,(iy+sprite_yvel)
0439A3 CD A4 06 04 0194*      call neg_hlu
0439A7 FD 2F 14    0195*      ld (iy+sprite_yvel),hl
0439AA             0196*  ; go check for x-axis collisions
0439AA C3 6F 39 04 0197*      jp @xaxis
0439AE             0198*  @left:
0439AE 3A C8 38 04 0199*      ld a,(sprite_screen_edge)
0439B2 F6 02       0200*      or a,collide_left
0439B4 21 00 00 00 0201*      ld hl,sprite_left*256
0439B8 C3 C6 39 04 0202*      jp @collide_x
0439BC             0203*  @right:
0439BC 3A C8 38 04 0204*      ld a,(sprite_screen_edge)
0439C0 F6 01       0205*      or a,collide_right
0439C2 21 00 EF 00 0206*      ld hl,sprite_right*256
0439C6             0207*  @collide_x:
0439C6 32 C8 38 04 0208*      ld (sprite_screen_edge),a
0439CA FD 2F 0B    0209*      ld (iy+sprite_x),hl
0439CD             0210*  ; reverse x-axis velocity
0439CD FD 27 11    0211*      ld hl,(iy+sprite_xvel)
0439D0 CD A4 06 04 0212*      call neg_hlu
0439D4 FD 2F 11    0213*      ld (iy+sprite_xvel),hl
0439D7             0214*  ; final collision flag to a and return
0439D7 3A C8 38 04 0215*      ld a,(sprite_screen_edge)
0439DB C9          0216*      ret
0439DC             0217*  ; end move_sprite
0439DC             0218*  
0439DC             0219*  sprite_compute_velocities:
0439DC FD 2A C4 38 0220*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0439E1 FD 17 17    0221*      ld de,(iy+sprite_vel)
0439E4 CD 52 09 04 0222*      call polar_to_cartesian
0439E8 FD 2A C4 38 0223*      ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0439ED FD 0F 11    0224*      ld (iy+sprite_xvel),bc ; save x-velocity component
0439F0 FD 1F 14    0225*      ld (iy+sprite_yvel),de ; save y-velocity component
0439F3 C9          0226*      ret
0439F4             0227*  ; end sprite_compute_velocities
0439F4             0050       include "state.inc"
0439F4 00          0001*  cur_level: db 0
0439F5             0002*  
0439F5             0003*  init_level: ; TODO: Implement level initialization
0439F5             0004*  ; BEGIN DEBUG
0439F5 DD 21 EB 2D 0005*      ld ix,maze_walls
       04          
0439FA 21 4E 01 00 0006*      ld hl,BUF_TILE_00
0439FE CD 84 2D 04 0007*      call draw_maze
043A02 DD 21 64 31 0008*      ld ix,maze_pellets
       04          
043A07 21 20 01 00 0009*      ld hl,BUF_MAZE_PELLETS_00
043A0B CD 84 2D 04 0010*      call draw_maze
043A0F             0011*      ; call waitKeypress
043A0F             0012*  ; END DEBUG
043A0F C9          0013*      ret
043A10             0014*  
043A10             0015*  ; Game state variables
043A10 1E 3A 04    0016*  game_state:  dl game_main_menu
043A13             0017*  
043A13             0018*  do_game:
043A13 2A 10 3A 04 0019*      ld hl,(game_state)   ; Load the current game state
043A17             0020*      callHL                ; Call the corresponding state handler
043A17 01 1D 3A 04 0001*M     ld bc,@F ; Address of first instruction after the jump
043A1B C5          0002*M     push bc ; which constitutes the return address
043A1C E9          0003*M     jp (hl) ; Jump to the address in HL
043A1D             0004*M @@:
043A1D C9          0021*      ret
043A1E             0022*  
043A1E             0023*  ; ========================
043A1E             0024*  ; Main Game States
043A1E             0025*  ; ========================
043A1E             0026*  
043A1E             0027*  game_main_menu:
043A1E             0028*      ; Handle main menu options
043A1E             0029*      ; Example: Check input for "Start Game"
043A1E CD EF 3A 04 0030*      call check_input_menu
043A22 C2 27 3A 04 0031*      jp nz, game_initialize ; Start game on selection
043A26 C9          0032*      ret
043A27             0033*  
043A27             0034*  game_initialize:
043A27             0035*  ; reset the sprite table
043A27 AF          0036*      xor a
043A28 32 C7 38 04 0037*      ld (table_active_sprites),a
043A2C 21 64 36 04 0038*      ld hl,table_base
043A30 22 C4 38 04 0039*      ld (table_pointer),hl
043A34             0040*  ; initialize sprites
043A34 CD 1E 39 04 0041*      call sprites_init
043A38             0042*  ; initialize the first level
043A38 AF          0043*      xor a
043A39 32 F4 39 04 0044*      ld (cur_level),a
043A3D CD F5 39 04 0045*      call init_level
043A41             0046*  ; initialize player
043A41 21 00 00 00 0047*      ld hl,0
043A45 22 DD 34 04 0048*      ld (player_score),hl
043A49 3E 03       0049*      ld a,3
043A4B 32 E0 34 04 0050*      ld (player_lives),a
043A4F CD 07 35 04 0051*      call player_init
043A53             0052*  ; set the game state to playing
043A53 21 5D 3A 04 0053*      ld hl,game_playing
043A57 22 10 3A 04 0054*      ld (game_state), hl
043A5B C9          0055*      ret
043A5C             0056*  ; done initializing
043A5C C9          0057*      ret
043A5D             0058*  
043A5D             0059*  game_playing:
043A5D             0060*  ; Main gameplay loop
043A5D CD CA 3A 04 0061*      call do_player
043A61 CD DB 3A 04 0062*      call do_enemies
043A65             0063*  ; update UI: TODO make this a standalone function
043A65 CD 40 36 04 0064*      call print_score
043A69 C9          0065*      ret
043A6A             0066*  
043A6A             0067*  game_paused:
043A6A             0068*      ; Pause menu logic
043A6A CD F2 3A 04 0069*      call check_input_pause
043A6E C2 5D 3A 04 0070*      jp nz, game_playing ; Resume game
043A72 CA 1E 3A 04 0071*      jp z, game_main_menu ; Exit to main menu
043A76 C9          0072*      ret
043A77             0073*  
043A77             0074*  game_level_transition:
043A77             0075*      ; Handle level transitions
043A77 CD F3 3A 04 0076*      call load_next_level
043A7B 21 5D 3A 04 0077*      ld hl, game_playing
043A7F 22 10 3A 04 0078*      ld (game_state), hl
043A83 C9          0079*      ret
043A84             0080*  
043A84             0081*  game_over:
043A84             0082*      ; Display game over screen
043A84 CD F4 3A 04 0083*      call display_game_over
043A88 C2 1E 3A 04 0084*      jp nz, game_main_menu ; Return to main menu on input
043A8C C9          0085*      ret
043A8D             0086*  
043A8D             0087*  game_victory:
043A8D             0088*      ; Display victory screen
043A8D CD F5 3A 04 0089*      call display_victory
043A91 C2 1E 3A 04 0090*      jp nz, game_main_menu ; Return to main menu on input
043A95 C9          0091*      ret
043A96             0092*  
043A96             0093*  ; ========================
043A96             0094*  ; Supporting States
043A96             0095*  ; ========================
043A96             0096*  
043A96             0097*  game_loading:
043A96             0098*      ; Show loading screen while preparing assets
043A96 CD F6 3A 04 0099*      call load_resources
043A9A 21 27 3A 04 0100*      ld hl, game_initialize
043A9E 22 10 3A 04 0101*      ld (game_state), hl
043AA2 C9          0102*      ret
043AA3             0103*  
043AA3             0104*  game_cutscene:
043AA3             0105*      ; Play a non-interactive cutscene
043AA3 CD F7 3A 04 0106*      call play_cutscene
043AA7 C2 5D 3A 04 0107*      jp nz, game_playing ; Return to gameplay after cutscene
043AAB C9          0108*      ret
043AAC             0109*  
043AAC             0110*  game_inventory:
043AAC             0111*      ; Open inventory or shop
043AAC CD F8 3A 04 0112*      call display_inventory
043AB0 C2 5D 3A 04 0113*      jp nz, game_playing ; Return to gameplay after inventory close
043AB4 C9          0114*      ret
043AB5             0115*  
043AB5             0116*  game_map:
043AB5             0117*      ; Display map or quest
043AB5 CD F9 3A 04 0118*      call display_map
043AB9 C2 5D 3A 04 0119*      jp nz, game_playing ; Return to gameplay after map close
043ABD C9          0120*      ret
043ABE             0121*  
043ABE             0122*  game_exit:
043ABE             0123*      ; Handle exit logic
043ABE CD FA 3A 04 0124*      call save_game
043AC2 C3 FB 3A 04 0125*      jp exit_game         ; Safely shut down
043AC6 C9          0126*      ret
043AC7             0127*  
043AC7             0128*  ; ========================
043AC7             0129*  ; Sub-state branching (Example for player state)
043AC7             0130*  ; ========================
043AC7             0131*  
043AC7 D5 3A 04    0132*  player_state:  dl player_alive ; Player state variable
043ACA             0133*  
043ACA             0134*  do_player:
043ACA 2A C7 3A 04 0135*      ld hl,(player_state)
043ACE             0136*      callHL                ; Call the corresponding player state
043ACE 01 D4 3A 04 0001*M     ld bc,@F ; Address of first instruction after the jump
043AD2 C5          0002*M     push bc ; which constitutes the return address
043AD3 E9          0003*M     jp (hl) ; Jump to the address in HL
043AD4             0004*M @@:
043AD4 C9          0137*      ret
043AD5             0138*  
043AD5             0139*  player_alive:
043AD5 CD 4D 35 04 0140*      call player_input     ; Handle player input
043AD9 C9          0141*      ret
043ADA             0142*  
043ADA             0143*  player_dead:
043ADA C9          0144*      ret
043ADB             0145*  
043ADB             0146*  do_enemies:
043ADB 2A E6 3A 04 0147*      ld hl, (enemies_state)
043ADF             0148*      callHL
043ADF 01 E5 3A 04 0001*M     ld bc,@F ; Address of first instruction after the jump
043AE3 C5          0002*M     push bc ; which constitutes the return address
043AE4 E9          0003*M     jp (hl) ; Jump to the address in HL
043AE5             0004*M @@:
043AE5 C9          0149*      ret
043AE6 E9 3A 04    0150*  enemies_state: dl enemies_dead
043AE9             0151*  enemies_dead:
043AE9 C9          0152*      ret
043AEA             0153*  
043AEA             0154*  enemies_alive:
043AEA CD 5C 1A 04 0155*      call move_enemies
043AEE C9          0156*      ret
043AEF             0157*  
043AEF             0158*  check_input_menu:
043AEF C9          0159*      ret
043AF0             0160*  
043AF0             0161*  update_game_world:
043AF0 C9          0162*      ret
043AF1             0163*  
043AF1             0164*  check_game_events:
043AF1 C9          0165*      ret
043AF2             0166*  
043AF2             0167*  check_input_pause:
043AF2 C9          0168*      ret
043AF3             0169*  
043AF3             0170*  load_next_level:
043AF3 C9          0171*      ret
043AF4             0172*  
043AF4             0173*  display_game_over:
043AF4 C9          0174*      ret
043AF5             0175*  
043AF5             0176*  display_victory:
043AF5 C9          0177*      ret
043AF6             0178*  
043AF6             0179*  load_resources:
043AF6 C9          0180*      ret
043AF7             0181*  
043AF7             0182*  play_cutscene:
043AF7 C9          0183*      ret
043AF8             0184*  
043AF8             0185*  display_inventory:
043AF8 C9          0186*      ret
043AF9             0187*  
043AF9             0188*  display_map:
043AF9 C9          0189*      ret
043AFA             0190*  
043AFA             0191*  save_game:
043AFA C9          0192*      ret
043AFB             0193*  
043AFB             0194*  exit_game:
043AFB C9          0195*      ret
043AFC             0196*  
043AFC             0051   
043AFC 57 65 6C 63 0052   hello_world: asciz "Welcome to Pac-Man!"
       6F 6D 65 20 
       74 6F 20 50 
       61 63 2D 4D 
       61 6E 21 00 
043B10 4C 6F 61 64 0053   loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
043B1B 50 72 65 73 0054   loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
043B36             0055   
043B36             0056   init:
043B36             0057   ; clear all buffers
043B36 CD B4 15 04 0058       call vdu_clear_all_buffers
043B3A             0059   
043B3A             0060   ; set up the display
043B3A 3E 08       0061       ld a,8;+128 ; 136   320   240   64    60hz double-buffered
043B3C CD 9E 14 04 0062       call vdu_set_screen_mode
043B40 AF          0063       xor a
043B41 CD AF 14 04 0064       call vdu_set_scaling
043B45             0065   
043B45             0066   ; ; enable additional audio channels
043B45             0067   ; 	call vdu_enable_channels
043B45             0068   
043B45             0069   ; set text background color
043B45 3E 9A       0070       ld a,26+128 ; violet
043B47 CD 06 14 04 0071       call vdu_colour_text
043B4B             0072   
043B4B             0073   ; set text foreground color
043B4B 3E 2F       0074       ld a,47 ; aaaaff lavenderish
043B4D CD 06 14 04 0075       call vdu_colour_text
043B51             0076   
043B51             0077   ; set gfx bg color
043B51 AF          0078       xor a ; plotting mode 0
043B52 3E 9A       0079       ld a,26+128 ; violet
043B54 CD 17 14 04 0080       call vdu_gcol
043B58 CD D5 13 04 0081       call vdu_cls
043B5C             0082   
043B5C             0083   ; set the cursor off
043B5C CD 9D 13 04 0084       call vdu_cursor_off
043B60             0085   
043B60             0086   ; ; VDU 28, left, bottom, right, top: Set text viewport **
043B60             0087   ; ; MIND THE LITTLE-ENDIANESS
043B60             0088   ; ; inputs: c=left,b=bottom,e=right,d=top
043B60             0089   ;     ld c,0 ; left
043B60             0090   ;     ld d,29 ; top
043B60             0091   ;     ld e,39 ; right
043B60             0092   ;     ld b,29; bottom
043B60             0093   ;     call vdu_set_txt_viewport
043B60             0094   
043B60             0095   ; ; print loading ui message
043B60             0096   ;     ld hl,loading_ui
043B60             0097   ;     call printString
043B60             0098   ;     call vdu_flip
043B60             0099   
043B60             0100   ; ; load UI images
043B60             0101   ;     call load_ui_images
043B60             0102   
043B60             0103   ; load sprites
043B60             0104       ; call img_load_init ; sets up the animated load screen
043B60 CD A6 11 04 0105       call load_sprite_images
043B64             0106   
043B64             0107   ; ; load sound effects ; TODO
043B64             0108   ; 	ld bc,SFX_num_buffers
043B64             0109   ; 	ld hl,SFX_buffer_id_lut
043B64             0110   ; 	ld (cur_buffer_id_lut),hl
043B64             0111   ; 	ld hl,SFX_load_routines_table
043B64             0112   ; 	ld (cur_load_jump_table),hl
043B64             0113   ; 	call sfx_load_main
043B64             0114   
043B64             0115   ; print loading complete message and wait for user keypress
043B64 CD D5 13 04 0116       call vdu_cls
043B68 21 1B 3B 04 0117       ld hl,loading_complete
043B6C CD 77 00 04 0118       call printString
043B70 CD DA 13 04 0119       call vdu_flip
043B74 CD 15 06 04 0120       call waitKeypress
043B78             0121   
043B78             0122   ; set up display for gameplay
043B78             0123       ; ld a,8
043B78 3E 14       0124       ld a,20
043B7A CD 9E 14 04 0125       call vdu_set_screen_mode
043B7E AF          0126       xor a
043B7F CD AF 14 04 0127       call vdu_set_scaling
043B83 CD 9D 13 04 0128       call vdu_cursor_off
043B87             0129   ; ; load fonts
043B87             0130   ; 	call fonts_load
043B87             0131   ; ; select font
043B87             0132   ;     ld hl,computer_pixel_7_8x16
043B87             0133   ;     ld a,1 ; flags
043B87             0134   ;     call vdu_font_select
043B87             0135   ; ; plot bezel art
043B87             0136   ;     ld hl,BUF_BEZEL_L
043B87             0137   ;     call vdu_buff_select
043B87             0138   ;     ld bc,0
043B87             0139   ;     ld de,0
043B87             0140   ;     call vdu_plot_bmp
043B87             0141   ;     ld hl,BUF_BEZEL_R
043B87             0142   ;     call vdu_buff_select
043B87             0143   ;     ld bc,384
043B87             0144   ;     ld de,0
043B87             0145   ;     call vdu_plot_bmp
043B87             0146   ; set gfx origin and viewport to playing field window
043B87 01 80 00 00 0147       ld bc,origin_left
043B8B 11 00 00 00 0148       ld de,origin_top
043B8F CD 5A 14 04 0149       call vdu_set_gfx_origin
043B93 01 00 00 00 0150       ld bc,field_left
043B97 11 00 00 00 0151       ld de,field_top
043B9B DD 21 FF 00 0152       ld ix,field_right
       00          
043BA0 FD 21 7F 01 0153       ld iy,field_bottom
       00          
043BA5 CD 75 14 04 0154       call vdu_set_gfx_viewport
043BA9             0155   ; set background color
043BA9 3E 9A       0156       ld a,26+128 ; violet
043BAB CD 17 14 04 0157       call vdu_gcol
043BAF CD E8 13 04 0158       call vdu_clg
043BB3             0159   ; ; VDU 28, left, bottom, right, top: Set text viewport **
043BB3             0160   ;     ld c,0 ; left
043BB3             0161   ;     ld d,0 ; top
043BB3             0162   ;     ld e,62 ; right
043BB3             0163   ;     ld b,7; bottom
043BB3             0164   ;     call vdu_set_txt_viewport
043BB3             0165   
043BB3             0166   ; initialize the global timestamp
043BB3 CD 11 13 04 0167       call timestamp_tick
043BB7             0168   
043BB7             0169   ; done with init
043BB7 C9          0170       ret
043BB8             0171   
043BB8             0172   main:
043BB8             0173   ; start a new game
043BB8 CD 27 3A 04 0174       call game_initialize
043BBC             0175   
043BBC             0176   main_loop:
043BBC             0177   ; update the global timestamp
043BBC CD 11 13 04 0178       call timestamp_tick
043BC0             0179   
043BC0             0180   ; do gamestate logic
043BC0 CD 13 3A 04 0181       call do_game
043BC4             0182   
043BC4             0183   ; wait for the next vblank mitigate flicker and for loop timing
043BC4 CD 49 14 04 0184       call vdu_vblank
043BC8             0185       ; call vdu_vblank ; DEBUG
043BC8             0186       ; call vdu_vblank ; DEBUG
043BC8             0187       ; call vdu_vblank ; DEBUG
043BC8             0188   
043BC8             0189   ; poll keyboard for escape keypress
043BC8 3E 08       0190       ld a, $08 ; code to send to MOS
043BCA 5B CF       0191       rst.lil $08 ; get IX pointer to System Variables
043BCC             0192   
043BCC DD 7E 05    0193       ld a, (ix + $05) ; get ASCII code of key pressed
043BCF FE 1B       0194       cp 27 ; check if 27 (ascii code for ESC)
043BD1 CA D9 3B 04 0195       jp z, main_end ; if pressed, jump to exit
043BD5             0196   
043BD5 C3 BC 3B 04 0197       jp main_loop
043BD9             0198   
043BD9             0199   main_end:
043BD9 CD 8F 13 04 0200       call vdu_cursor_on
043BDD C9          0201       ret
