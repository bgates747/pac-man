PC     Output      Line
040000             0001        assume adl=1
040000             0002        org 0x040000
040000 C3 45 00 04 0003        jp start
040004 FF FF FF FF 0004        align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0005        db "MOS"
040043 00          0006        db 00h
040044 01          0007        db 01h
040045             0008    
040045             0009    start:
040045 F5          0010        push af
040046 C5          0011        push bc
040047 D5          0012        push de
040048 DD E5       0013        push ix
04004A FD E5       0014        push iy
04004C CD 23 48 04 0015        call init
040050 CD B1 48 04 0016        call main
040054             0017    
040054             0018    exit:
040054 FD E1       0019        pop iy
040056 DD E1       0020        pop ix
040058 D1          0021        pop de
040059 C1          0022        pop bc
04005A F1          0023        pop af
04005B 21 00 00 00 0024        ld hl,0
04005F             0025    
04005F C9          0026        ret
040060             0027    
040060             0028    ; API INCLUDES
040060             0029        include "mos_api.inc"
040060             0001*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/mos_api.inc
040060             0002*   ; Title:	AGON MOS - API for user projects
040060             0003*   ; Author:	Dean Belfield
040060             0004*   ;			Adapted for agon-ez80asm by Jeroen Venema
040060             0005*   ;			Added MOS error codes for return in HL
040060             0006*   ; Created:	03/08/2022
040060             0007*   ; Last Updated:	10/08/2023
040060             0008*   ;
040060             0009*   ; Modinfo:
040060             0010*   ; 05/08/2022:	Added mos_feof
040060             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040060             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040060             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040060             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040060             0015*   ; 13/10/2022:	Added mos_oscli
040060             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040060             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040060             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040060             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040060             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040060             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040060             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040060             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040060             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040060             0025*   ; 19/05/2023:	Added sysvar_scrMode
040060             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040060             0027*   ; 03/08/2023:	Added mos_setkbvector
040060             0028*   ; 10/08/2023:	Added mos_getkbmap
040060             0029*   
040060             0030*   ; VDP control (VDU 23, 0, n)
040060             0031*   ;
040060             0032*   vdp_gp:				EQU 80h
040060             0033*   vdp_keycode:		EQU 81h
040060             0034*   vdp_cursor:			EQU	82h
040060             0035*   vdp_scrchar:		EQU	83h
040060             0036*   vdp_scrpixel:		EQU	84h
040060             0037*   vdp_audio:			EQU	85h
040060             0038*   vdp_mode:			EQU	86h
040060             0039*   vdp_rtc:			EQU	87h
040060             0040*   vdp_keystate:		EQU	88h
040060             0041*   vdp_logicalcoords:	EQU	C0h
040060             0042*   vdp_terminalmode:	EQU	FFh
040060             0043*   
040060             0044*   ; MOS high level functions
040060             0045*   ;
040060             0046*   mos_getkey:			EQU	00h
040060             0047*   mos_load:			EQU	01h
040060             0048*   mos_save:			EQU	02h
040060             0049*   mos_cd:				EQU	03h
040060             0050*   mos_dir:			EQU	04h
040060             0051*   mos_del:			EQU	05h
040060             0052*   mos_ren:			EQU	06h
040060             0053*   mos_mkdir:			EQU	07h
040060             0054*   mos_sysvars:		EQU	08h
040060             0055*   mos_editline:		EQU	09h
040060             0056*   mos_fopen:			EQU	0Ah
040060             0057*   mos_fclose:			EQU	0Bh
040060             0058*   mos_fgetc:			EQU	0Ch
040060             0059*   mos_fputc:			EQU	0Dh
040060             0060*   mos_feof:			EQU	0Eh
040060             0061*   mos_getError:		EQU	0Fh
040060             0062*   mos_oscli:			EQU	10h
040060             0063*   mos_copy:			EQU	11h
040060             0064*   mos_getrtc:			EQU	12h
040060             0065*   mos_setrtc:			EQU	13h
040060             0066*   mos_setintvector:	EQU	14h
040060             0067*   mos_uopen:			EQU	15h
040060             0068*   mos_uclose:			EQU	16h
040060             0069*   mos_ugetc:			EQU	17h
040060             0070*   mos_uputc:			EQU	18h
040060             0071*   mos_getfil:			EQU	19h
040060             0072*   mos_fread:			EQU	1Ah
040060             0073*   mos_fwrite:			EQU	1Bh
040060             0074*   mos_flseek:			EQU	1Ch
040060             0075*   mos_setkbvector:	EQU	1Dh
040060             0076*   mos_getkbmap:		EQU	1Eh
040060             0077*   
040060             0078*   ; MOS program exit codes
040060             0079*   ;
040060             0080*   EXIT_OK:				EQU  0;	"OK",
040060             0081*   EXIT_ERROR_SD_ACCESS:	EQU	 1;	"Error accessing SD card",
040060             0082*   EXIT_ERROR_ASSERTION:	EQU  2;	"Assertion failed",
040060             0083*   EXIT_SD_CARDFAILURE:	EQU  3;	"SD card failure",
040060             0084*   EXIT_FILENOTFOUND:		EQU  4;	"Could not find file",
040060             0085*   EXIT_PATHNOTFOUND:		EQU  5;	"Could not find path",
040060             0086*   EXIT_INVALIDPATHNAME:	EQU  6;	"Invalid path name",
040060             0087*   EXIT_ACCESSDENIED_FULL:	EQU  7;	"Access denied or directory full",
040060             0088*   EXIT_ACCESSDENIED:		EQU  8;	"Access denied",
040060             0089*   EXIT_INVALIDOBJECT:		EQU  9;	"Invalid file/directory object",
040060             0090*   EXIT_SD_WRITEPROTECTED:	EQU 10;	"SD card is write protected",
040060             0091*   EXIT_INVALIDDRIVENUMBER:EQU 11;	"Logical drive number is invalid",
040060             0092*   EXIT_NOVOLUMEWORKAREA:	EQU 12;	"Volume has no work area",
040060             0093*   EXIT_NOVALIDFATVOLUME:	EQU 13;	"No valid FAT volume",
040060             0094*   EXIT_ERRORMKFS:			EQU 14;	"Error occurred during mkfs",
040060             0095*   EXIT_VOLUMETIMEOUT:		EQU 15;	"Volume timeout",
040060             0096*   EXIT_VOLUMELOCKED:		EQU 16;	"Volume locked",
040060             0097*   EXIT_LFNALLOCATION:		EQU 17;	"LFN working buffer could not be allocated",
040060             0098*   EXIT_MAXOPENFILES:		EQU 18;	"Too many open files",
040060             0099*   EXIT_INVALIDPARAMETER:	EQU 19;	"Invalid parameter",
040060             0100*   EXIT_INVALIDCOMMAND:	EQU 20;	"Invalid command",
040060             0101*   EXIT_INVALIDEXECUTABLE:	EQU 21;	"Invalid executable",
040060             0102*   ; FatFS file access functions
040060             0103*   ;
040060             0104*   ffs_fopen:			EQU	80h
040060             0105*   ffs_fclose:			EQU	81h
040060             0106*   ffs_fread:			EQU	82h
040060             0107*   ffs_fwrite:			EQU	83h
040060             0108*   ffs_flseek:			EQU	84h
040060             0109*   ffs_ftruncate:		EQU	85h
040060             0110*   ffs_fsync:			EQU	86h
040060             0111*   ffs_fforward:		EQU	87h
040060             0112*   ffs_fexpand:		EQU	88h
040060             0113*   ffs_fgets:			EQU	89h
040060             0114*   ffs_fputc:			EQU	8Ah
040060             0115*   ffs_fputs:			EQU	8Bh
040060             0116*   ffs_fprintf:		EQU	8Ch
040060             0117*   ffs_ftell:			EQU	8Dh
040060             0118*   ffs_feof:			EQU	8Eh
040060             0119*   ffs_fsize:			EQU	8Fh
040060             0120*   ffs_ferror:			EQU	90h
040060             0121*   
040060             0122*   ; FatFS directory access functions
040060             0123*   ;
040060             0124*   ffs_dopen:			EQU	91h
040060             0125*   ffs_dclose:			EQU	92h
040060             0126*   ffs_dread:			EQU	93h
040060             0127*   ffs_dfindfirst:		EQU	94h
040060             0128*   ffs_dfindnext:		EQU	95h
040060             0129*   
040060             0130*   ; FatFS file and directory management functions
040060             0131*   ;
040060             0132*   ffs_stat:			EQU	96h
040060             0133*   ffs_unlink:			EQU	97h
040060             0134*   ffs_rename:			EQU	98h
040060             0135*   ffs_chmod:			EQU	99h
040060             0136*   ffs_utime:			EQU	9Ah
040060             0137*   ffs_mkdir:			EQU	9Bh
040060             0138*   ffs_chdir:			EQU	9Ch
040060             0139*   ffs_chdrive:		EQU	9Dh
040060             0140*   ffs_getcwd:			EQU	9Eh
040060             0141*   
040060             0142*   ; FatFS volume management and system configuration functions
040060             0143*   ;
040060             0144*   ffs_mount:			EQU	9Fh
040060             0145*   ffs_mkfs:			EQU	A0h
040060             0146*   ffs_fdisk:			EQU	A1h
040060             0147*   ffs_getfree:		EQU	A2h
040060             0148*   ffs_getlabel:		EQU	A3h
040060             0149*   ffs_setlabel:		EQU	A4h
040060             0150*   ffs_setcp:			EQU	A5h
040060             0151*   
040060             0152*   ; File access modes
040060             0153*   ;
040060             0154*   fa_read:			EQU	01h
040060             0155*   fa_write:			EQU	02h
040060             0156*   fa_open_existing:	EQU	00h
040060             0157*   fa_create_new:		EQU	04h
040060             0158*   fa_create_always:	EQU	08h
040060             0159*   fa_open_always:		EQU	10h
040060             0160*   fa_open_append:		EQU	30h
040060             0161*   
040060             0162*   ; System variable indexes for api_sysvars
040060             0163*   ; Index into _sysvars in globals.inc
040060             0164*   ;
040060             0165*   sysvar_time:			EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040060             0166*   sysvar_vpd_pflags:		EQU	04h	; 1: Flags to indicate completion of VDP commands
040060             0167*   sysvar_keyascii:		EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040060             0168*   sysvar_keymods:			EQU	06h	; 1: Keycode modifiers
040060             0169*   sysvar_cursorX:			EQU	07h	; 1: Cursor X position
040060             0170*   sysvar_cursorY:			EQU	08h	; 1: Cursor Y position
040060             0171*   sysvar_scrchar:			EQU	09h	; 1: Character read from screen
040060             0172*   sysvar_scrpixel:		EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040060             0173*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040060             0174*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040060             0175*   sysvar_scrWidth:		EQU	0Fh	; 2: Screen width in pixels
040060             0176*   sysvar_scrHeight:		EQU	11h	; 2: Screen height in pixels
040060             0177*   sysvar_scrCols:			EQU	13h	; 1: Screen columns in characters
040060             0178*   sysvar_scrRows:			EQU	14h	; 1: Screen rows in characters
040060             0179*   sysvar_scrColours:		EQU	15h	; 1: Number of colours displayed
040060             0180*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040060             0181*   sysvar_vkeycode:		EQU	17h	; 1: Virtual key code from FabGL
040060             0182*   sysvar_vkeydown:		EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040060             0183*   sysvar_vkeycount:		EQU	19h	; 1: Incremented every time a key packet is received
040060             0184*   sysvar_rtc:				EQU	1Ah	; 6: Real time clock data
040060             0185*   sysvar_spare:			EQU	20h	; 2: Spare, previously used by rtc
040060             0186*   sysvar_keydelay:		EQU	22h	; 2: Keyboard repeat delay
040060             0187*   sysvar_keyrate:			EQU	24h	; 2: Keyboard repeat reat
040060             0188*   sysvar_keyled:			EQU	26h	; 1: Keyboard LED status
040060             0189*   sysvar_scrMode:			EQU	27h	; 1: Screen mode
040060             0190*   sysvar_rtcEnable:		EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040060             0191*   
040060             0192*   ; Flags for the VPD protocol
040060             0193*   ;
040060             0194*   vdp_pflag_cursor:		EQU	00000001b
040060             0195*   vdp_pflag_scrchar:		EQU	00000010b
040060             0196*   vdp_pflag_point:		EQU	00000100b
040060             0197*   vdp_pflag_audio:		EQU	00001000b
040060             0198*   vdp_pflag_mode:			EQU	00010000b
040060             0199*   vdp_pflag_rtc:			EQU	00100000b
040060             0200*   
040060             0201*   ;
040060             0202*   ; FatFS structures
040060             0203*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040060             0204*   ;
040060             0205*   ; Object ID and allocation information (FFOBJID)
040060             0206*   ;
040060             0207*   ; Indexes into FFOBJID structure
040060             0208*   ffobjid_fs:			EQU	0	; 3: Pointer to the hosting volume of this object
040060             0209*   ffobjid_id:			EQU	3	; 2: Hosting volume mount ID
040060             0210*   ffobjid_attr:		EQU	5	; 1: Object attribute
040060             0211*   ffobjid_stat:		EQU	6	; 1: Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040060             0212*   ffobjid_sclust:		EQU	7	; 4: Object data start cluster (0:no cluster or root directory)
040060             0213*   ffobjid_objsize:	EQU	11	; 4: Object size (valid when sclust != 0)
040060             0214*   ;
040060             0215*   ; File object structure (FIL)
040060             0216*   ;
040060             0217*   ; Indexes into FIL structure
040060             0218*   fil_obj:		EQU 0	; 15: Object identifier
040060             0219*   fil_flag:		EQU	15 	;  1: File status flags
040060             0220*   fil_err:		EQU	16	;  1: Abort flag (error code)
040060             0221*   fil_fptr:		EQU	17	;  4: File read/write pointer (Zeroed on file open)
040060             0222*   fil_clust:		EQU	21	;  4: Current cluster of fpter (invalid when fptr is 0)
040060             0223*   fil_sect:		EQU	25	;  4: Sector number appearing in buf[] (0:invalid)
040060             0224*   fil_dir_sect:	EQU	29	;  4: Sector number containing the directory entry
040060             0225*   fil_dir_ptr:	EQU	33	;  3: Pointer to the directory entry in the win[]
040060             0226*   ;
040060             0227*   ; Directory object structure (DIR)
040060             0228*   ; Indexes into DIR structure
040060             0229*   dir_obj:		EQU  0	; 15: Object identifier
040060             0230*   dir_dptr:		EQU	15	;  4: Current read/write offset
040060             0231*   dir_clust:		EQU	19	;  4: Current cluster
040060             0232*   dir_sect:		EQU	23	;  4: Current sector (0:Read operation has terminated)
040060             0233*   dir_dir:		EQU	27	;  3: Pointer to the directory item in the win[]
040060             0234*   dir_fn:			EQU	30	; 12: SFN (in/out) {body[8],ext[3],status[1]}
040060             0235*   dir_blk_ofs:	EQU	42	;  4: Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040060             0236*   ;
040060             0237*   ; File information structure (FILINFO)
040060             0238*   ;
040060             0239*   ; Indexes into FILINFO structure
040060             0240*   filinfo_fsize:		EQU 0	;   4: File size
040060             0241*   filinfo_fdate:		EQU	4	;   2: Modified date
040060             0242*   filinfo_ftime:		EQU	6	;   2: Modified time
040060             0243*   filinfo_fattrib:	EQU	8	;   1: File attribute
040060             0244*   filinfo_altname:	EQU	9	;  13: Alternative file name
040060             0245*   filinfo_fname:		EQU	22	; 256: Primary file name
040060             0246*   ;
040060             0247*   ; Macro for calling the API
040060             0248*   ; Parameters:
040060             0249*   ; - function: One of the function numbers listed above
040060             0250*   ;
040060             0251*   	MACRO	MOSCALL	function
040060             0252*   			LD	A, function
040060             0253*   			RST.LIL	08h
040060             0254*   	ENDMACRO
040060             0030        include "macros.inc"
040060             0001*   
040060             0002*   ; test the sign of HL
040060             0003*   ; inputs: HL obviously
040060             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040060             0005*   ; destroys: flags
040060             0006*       MACRO SIGN_HLU
040060             0007*       add hl,de ; 1 cycle
040060             0008*       or a ; clear flags ; 1 cycle
040060             0009*       sbc hl,de ; 2 cycles
040060             0010*       ; 4 cycles total
040060             0011*       ENDMACRO
040060             0012*   
040060             0013*   ; put the value in A into HLU
040060             0014*   ; affects: HLU
040060             0015*   ; destroys: nothing
040060             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040060             0017*       MACRO A_TO_HLU
040060             0018*       xor a ; 1 cycle
040060             0019*       ld ($+8+1),hl ; 7 cycles
040060             0020*       ld ($+4+3),a ; 5 cycles
040060             0021*       ld hl,0x000000 ; 4 cycles
040060             0022*       ; 17 cycles total
040060             0023*       ENDMACRO
040060             0024*   
040060             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040060             0026*   ; one cycle less but burns flags
040060             0027*       MACRO A_TO_HLU_ALT
040060             0028*       push hl ; 4 cycles
040060             0029*       ld hl,2 ; 4 cycles
040060             0030*       add hl,sp ; 1 cycle
040060             0031*       ld (hl),a ; 2 cycles
040060             0032*       pop hl ; 4 cycles
040060             0033*       ; 15 cycles total
040060             0034*       ENDMACRO
040060             0035*   
040060             0036*       MACRO hlu_mul256
040060             0037*       add hl,hl ; * 2
040060             0038*       add hl,hl ; * 4
040060             0039*       add hl,hl ; * 8
040060             0040*       add hl,hl ; * 16
040060             0041*       add hl,hl ; * 32
040060             0042*       add hl,hl ; * 64
040060             0043*       add hl,hl ; * 128
040060             0044*       add hl,hl ; * 256
040060             0045*       ENDMACRO
040060             0046*   
040060             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040060             0048*       MACRO SRL_UHL
040060             0049*       dec sp ; 1 cycle
040060             0050*       push hl ; 4 cycles
040060             0051*       inc sp ; 1 cycle
040060             0052*       pop hl ; 4 cycles
040060             0053*       inc hl ; 1 cycle
040060             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040060             0055*       ; 13 cycles total
040060             0056*       ENDMACRO
040060             0057*   
040060             0058*       MACRO printChar char
040060             0059*       LD A, char
040060             0060*       RST.LIL 10h
040060             0061*       ENDMACRO
040060             0062*   
040060             0063*   ; Simulated call to subroutine at HL
040060             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040060             0065*   ; outputs: whatever the subroutine does, including HL and BC
040060             0066*   ; destroys: only what the subroutine does, but always BC
040060             0067*       MACRO CALL_HL
040060             0068*       ld bc,$+6 ; Address of first instruction after the jump
040060             0069*       push bc ; which constitutes the return address
040060             0070*       jp (hl) ; Jump to the address in HL
040060             0071*       ENDMACRO
040060             0072*   
040060             0073*   ; Simulated call to subroutine at IX
040060             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040060             0075*   ; outputs: whatever the subroutine does, including IX and BC
040060             0076*   ; destroys: only what the subroutine does, but always BC
040060             0077*       MACRO CALL_IX
040060             0078*       ld bc,$+6 ; Address of first instruction after the jump
040060             0079*       push bc ; which constitutes the return address
040060             0080*       jp (ix) ; Jump to the address in IX
040060             0081*       ENDMACRO
040060             0082*   
040060             0083*   ; Simulated call to soubroutinte at IY
040060             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040060             0085*   ; outputs: whatever the subroutine does, including IY and BC
040060             0086*   ; destroys: only what the subroutine does, but always BC
040060             0087*       MACRO CALL_IY
040060             0088*       ld bc,$+6 ; Address of first instruction after the jump
040060             0089*       push bc ; which constitutes the return address
040060             0090*       jp (iy) ; Jump to the address in IY
040060             0091*       ENDMACRO
040060             0092*   
040060             0093*   ; put the value in HLU into A
040060             0094*   ; destroys: af
040060             0095*       MACRO HLU_TO_A
040060             0096*       dec sp ; 1 cycle
040060             0097*       push hl ; 4 cycles
040060             0098*       inc sp ; 1 cycle
040060             0099*       pop af ; 4 cycles
040060             0100*       ; 10 cycles total
040060             0101*       ENDMACRO
040060             0102*   
040060             0103*       MACRO PUSH_ALL
040060             0104*       ex af,af'
040060             0105*       exx
040060             0106*       push af
040060             0107*       push hl
040060             0108*       push bc
040060             0109*       push de
040060             0110*   
040060             0111*       ex af,af'
040060             0112*       exx
040060             0113*       push af
040060             0114*       push hl
040060             0115*       push bc
040060             0116*       push de
040060             0117*       push ix
040060             0118*       push iy
040060             0119*       ENDMACRO
040060             0120*   
040060             0121*       MACRO POP_ALL
040060             0122*       pop iy
040060             0123*       pop ix
040060             0124*       pop de
040060             0125*       pop bc
040060             0126*       pop hl
040060             0127*       pop af
040060             0128*       ex af,af'
040060             0129*       exx
040060             0130*   
040060             0131*       pop de
040060             0132*       pop bc
040060             0133*       pop hl
040060             0134*       pop af
040060             0135*       ex af,af'
040060             0136*       exx
040060             0137*       ENDMACRO
040060             0031        include "functions.inc"
040060 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040100             0002*   
040100             0003*   ; Print a zero-terminated string inline with code, e.g.:
040100             0004*   ;
040100             0005*   ;    call printInline
040100             0006*   ;    ASCIZ "Hello, world!\r\n"
040100             0007*   ;
040100             0008*   ; Destroys: HL,AF
040100             0009*   printInline:
040100 E1          0010*       pop hl ; get the return address = pointer to start of string
040101 CD 07 01 04 0011*       call printString ; HL advances to end of string
040105 E5          0012*       push hl ; restore the return address = pointer to end of string
040106 C9          0013*       ret
040107             0014*   
040107             0015*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040107             0016*   ; Print a zero-terminated string
040107             0017*   ; HL: Pointer to string
040107             0018*   printString:
040107 C5          0019*       PUSH BC
040108 01 00 00 00 0020*       LD BC,0
04010C 3E 00       0021*       LD A,0
04010E 5B DF       0022*       RST.LIL 18h
040110 C1          0023*       POP BC
040111 C9          0024*       RET
040112             0025*   ; print a VDU sequence
040112             0026*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
040112             0027*   sendVDUsequence:
040112 C5          0028*       PUSH BC
040113 01 00 00 00 0029*       LD BC, 0
040117 4E          0030*       LD C, (HL)
040118 5B DF       0031*       RST.LIL 18h
04011A C1          0032*       POP BC
04011B C9          0033*       RET
04011C             0034*   ; Print Newline sequence to VDP
04011C             0035*   ; destroys bc
04011C             0036*   printNewLine:
04011C F5          0037*       push af ; for some reason rst.lil 10h sets carry flag
04011D 3E 0D       0038*       LD A, '\r'
04011F 5B D7       0039*       RST.LIL 10h
040121 3E 0A       0040*       LD A, '\n'
040123 5B D7       0041*       RST.LIL 10h
040125 F1          0042*       pop af
040126 C9          0043*       RET
040127             0044*   
040127             0045*   ; Print a 24-bit HEX number
040127             0046*   ; HLU: Number to print
040127             0047*   printHex24:
040127             0048*       HLU_TO_A
040127 3B          0001*M1     dec sp ; 1 cycle
040128 E5          0002*M1     push hl ; 4 cycles
040129 33          0003*M1     inc sp ; 1 cycle
04012A F1          0004*M1     pop af ; 4 cycles
04012B             0005*M1     ; 10 cycles total
04012B CD 35 01 04 0049*       CALL printHex8
04012F             0050*   ; Print a 16-bit HEX number
04012F             0051*   ; HL: Number to print
04012F             0052*   printHex16:
04012F 7C          0053*       LD A,H
040130 CD 35 01 04 0054*       CALL printHex8
040134 7D          0055*       LD A,L
040135             0056*   ; Print an 8-bit HEX number
040135             0057*   ; A: Number to print
040135             0058*   printHex8:
040135 4F          0059*       LD C,A
040136 1F          0060*       RRA
040137 1F          0061*       RRA
040138 1F          0062*       RRA
040139 1F          0063*       RRA
04013A CD 3F 01 04 0064*       CALL @F
04013E 79          0065*       LD A,C
04013F             0066*   @@:
04013F E6 0F       0067*       AND 0Fh
040141 C6 90       0068*       ADD A,90h
040143 27          0069*       DAA
040144 CE 40       0070*       ADC A,40h
040146 27          0071*       DAA
040147 5B D7       0072*       RST.LIL 10h
040149 C9          0073*       RET
04014A             0074*   
04014A             0075*   ; Print a 0x HEX prefix
04014A             0076*   DisplayHexPrefix:
04014A 3E 30       0077*       LD A, '0'
04014C 5B D7       0078*       RST.LIL 10h
04014E 3E 78       0079*       LD A, 'x'
040150 5B D7       0080*       RST.LIL 10h
040152 C9          0081*       RET
040153             0082*   
040153             0083*       MACRO printDecBC
040153             0084*       push hl
040153             0085*       push bc
040153             0086*       pop hl
040153             0087*       call printDec
040153             0088*       pop hl
040153             0089*       ENDMACRO
040153             0090*   
040153             0091*       MACRO printDecDE
040153             0092*       push hl
040153             0093*       push de
040153             0094*       pop hl
040153             0095*       call printDec
040153             0096*       pop hl
040153             0097*       ENDMACRO
040153             0098*   
040153             0099*       MACRO printDecHL
040153             0100*       call printDec
040153             0101*       ENDMACRO
040153             0102*   
040153             0103*       MACRO printDecIX
040153             0104*       push hl
040153             0105*       push ix
040153             0106*       pop hl
040153             0107*       call printDec
040153             0108*       pop hl
040153             0109*       ENDMACRO
040153             0110*   
040153             0111*       MACRO printDecIY
040153             0112*       push hl
040153             0113*       push iy
040153             0114*       pop hl
040153             0115*       call printDec
040153             0116*       pop hl
040153             0117*       ENDMACRO
040153             0118*   
040153             0119*   
040153             0120*   ; Prints the right justified decimal value in HL without leading zeroes
040153             0121*   ; HL : Value to print
040153             0122*   ; preserves all registers and flags
040153             0123*   printDec:
040153             0124*   ; BEGIN MY CODE
040153             0125*   ; back up all the things
040153 F5          0126*       push af
040154 C5          0127*       push bc
040155 D5          0128*       push de
040156 E5          0129*       push hl
040157             0130*   ; END MY CODE
040157 11 7F 01 04 0131*       LD DE, _printDecBuffer
04015B CD 8F 01 04 0132*       CALL u24_to_ascii
04015F             0133*   ; BEGIN MY CODE
04015F             0134*   ; replace leading zeroes with spaces
04015F 21 7F 01 04 0135*       LD HL, _printDecBuffer
040163 06 07       0136*       ld B, 7 ; if HL was 0, we want to keep the final zero
040165             0137*   @loop:
040165 7E          0138*       LD A, (HL)
040166 FE 30       0139*       CP '0'
040168 C2 72 01 04 0140*       JP NZ, @done
04016C 3E 20       0141*       LD A, ' '
04016E 77          0142*       LD (HL), A
04016F 23          0143*       INC HL
040170             0144*       ; CALL vdu_cursor_forward
040170 10 F3       0145*       DJNZ @loop
040172             0146*   @done:
040172             0147*   ; END MY CODE
040172 21 7F 01 04 0148*       LD HL, _printDecBuffer
040176 CD 07 01 04 0149*       CALL printString
04017A             0150*   ; BEGIN MY CODE
04017A             0151*   ; restore all the things
04017A E1          0152*       pop hl
04017B D1          0153*       pop de
04017C C1          0154*       pop bc
04017D F1          0155*       pop af
04017E             0156*   ; END MY CODE
04017E C9          0157*       RET
04017F 00 00 00 00 0158*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04018F             0159*   
04018F             0160*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
04018F             0161*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
04018F             0162*   ; so it will allways be 8 characters length
04018F             0163*   ; HL : Value to convert to string
04018F             0164*   ; DE : pointer to buffer, at least 8 byte + 0
04018F             0165*   u24_to_ascii:
04018F 01 80 69 67 0166*       LD BC,-10000000
040193 CD C6 01 04 0167*       CALL @one_digit
040197 01 C0 BD F0 0168*       LD BC,-1000000
04019B CD C6 01 04 0169*       CALL @one_digit
04019F 01 60 79 FE 0170*       LD BC,-100000
0401A3 CD C6 01 04 0171*       CALL @one_digit
0401A7 01 F0 D8 FF 0172*       LD BC,-10000
0401AB CD C6 01 04 0173*       CALL @one_digit
0401AF 01 18 FC FF 0174*       LD BC,-1000
0401B3 CD C6 01 04 0175*       CALL @one_digit
0401B7 01 9C FF FF 0176*       LD BC,-100
0401BB CD C6 01 04 0177*       CALL @one_digit
0401BF 0E F6       0178*       LD C,-10
0401C1 CD C6 01 04 0179*       CALL @one_digit
0401C5 48          0180*       LD C,B
0401C6             0181*   @one_digit:
0401C6 3E 2F       0182*       LD A,'0'-1
0401C8             0183*   @divide_me:
0401C8 3C          0184*       INC A
0401C9 09          0185*       ADD HL,BC
0401CA 38 FC       0186*       JR C,@divide_me
0401CC ED 42       0187*       SBC HL,BC
0401CE 12          0188*       LD (DE),A
0401CF 13          0189*       INC DE
0401D0 C9          0190*       RET
0401D1             0191*   
0401D1             0192*   print_u24:
0401D1 D5          0193*       push de
0401D2 E5          0194*       push hl
0401D3 11 7F 01 04 0195*       ld de,_printDecBuffer
0401D7 CD 8F 01 04 0196*       call u24_to_ascii
0401DB 21 7F 01 04 0197*       ld hl,_printDecBuffer
0401DF CD 07 01 04 0198*       call printString
0401E3 3E 20       0199*       ld a,' '
0401E5 5B D7       0200*       rst.lil 10h
0401E7 E1          0201*       pop hl
0401E8 D1          0202*       pop de
0401E9 C9          0203*       ret
0401EA             0204*   
0401EA             0205*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0401EA             0206*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0401EA             0207*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0401EA             0208*   u168_to_ascii:
0401EA             0209*   ; add a leading space to make room for sign flag if needed
0401EA 3E 20       0210*       ld a,' '
0401EC 12          0211*       ld (de),a
0401ED 13          0212*       inc de
0401EE             0213*   ; Convert integer part
0401EE E5          0214*       push hl ; Save HL (we’ll need the fractional part later)
0401EF             0215*       ; call hlu_udiv256 ; Shift to get integer portion in HL
0401EF             0216*       SRL_UHL ; Shift to get integer portion in HL
0401EF 3B          0001*M1     dec sp ; 1 cycle
0401F0 E5          0002*M1     push hl ; 4 cycles
0401F1 33          0003*M1     inc sp ; 1 cycle
0401F2 E1          0004*M1     pop hl ; 4 cycles
0401F3 23          0005*M1     inc hl ; 1 cycle
0401F4 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0401F6             0007*M1     ; 13 cycles total
0401F6 01 F0 D8 FF 0217*       ld bc, -10000
0401FA CD 1D 02 04 0218*       call @one_int
0401FE 01 18 FC FF 0219*       ld bc, -1000
040202 CD 1D 02 04 0220*       call @one_int
040206 01 9C FF FF 0221*       ld bc, -100
04020A CD 1D 02 04 0222*       call @one_int
04020E 0E F6       0223*       ld c, -10
040210 CD 1D 02 04 0224*       call @one_int
040214 48          0225*       ld c, b
040215 CD 1D 02 04 0226*       call @one_int
040219 C3 28 02 04 0227*       jp @frac ; Jump to fractional part conversion
04021D             0228*   @one_int:
04021D 3E 2F       0229*       ld a, '0' - 1 ; Start ASCII character at '0'
04021F             0230*   @divide_me:
04021F 3C          0231*       inc a
040220 09          0232*       add hl, bc ; Accumulate until overflow
040221 38 FC       0233*       jr c, @divide_me
040223 ED 42       0234*       sbc hl, bc ; Remove excess after overflow
040225 12          0235*       ld (de), a ; Store ASCII digit
040226 13          0236*       inc de
040227 C9          0237*       ret
040228             0238*   ; Convert fractional part
040228             0239*   @frac:
040228 3E 2E       0240*       ld a, '.' ; Decimal point
04022A 12          0241*       ld (de), a
04022B 13          0242*       inc de
04022C E1          0243*       pop hl ; Restore HL with original fraction
04022D 06 03       0244*       ld b, 3 ; Loop counter for 3 fractional digits
04022F             0245*   @frac_loop:
04022F 26 0A       0246*       ld h, 10 ; Load multiplier for fractional part
040231 ED 6C       0247*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
040233 3E 30       0248*       ld a, '0'
040235 84          0249*       add a, h ; Convert integer part to ASCII
040236 12          0250*       ld (de), a
040237 13          0251*       inc de
040238 10 F5       0252*       djnz @frac_loop ; Repeat for each fractional digit
04023A             0253*   ; Add null terminator
04023A AF          0254*       xor a ; Null terminator
04023B 12          0255*       ld (de), a
04023C C9          0256*       ret
04023D             0257*   
04023D             0258*   print_u168:
04023D D5          0259*       push de
04023E E5          0260*       push hl
04023F 11 7F 01 04 0261*       ld de,_printDecBuffer
040243 CD EA 01 04 0262*       call u168_to_ascii
040247 21 7F 01 04 0263*       ld hl,_printDecBuffer
04024B CD 07 01 04 0264*       call printString
04024F E1          0265*       pop hl
040250 D1          0266*       pop de
040251 C9          0267*       ret
040252             0268*   
040252             0269*   ; signed version of u168_to_ascii
040252             0270*   s168_to_ascii:
040252 D5          0271*       push de ; save starting address of buffer
040253 CD 06 05 04 0272*       call hlu_abs
040257 F5          0273*       push af ; save sign flag
040258 CD EA 01 04 0274*       call u168_to_ascii
04025C F1          0275*       pop af ; restore sign flag
04025D D1          0276*       pop de ; restore starting address of buffer
04025E F0          0277*       ret p ; hlu was positive so nothing to do
04025F 3E 2D       0278*       ld a,'-'
040261 12          0279*       ld (de),a
040262 C9          0280*       ret
040263             0281*   
040263             0282*   print_s168:
040263 D5          0283*       push de
040264 E5          0284*       push hl
040265 11 7F 01 04 0285*       ld de,_printDecBuffer
040269 CD 52 02 04 0286*       call s168_to_ascii
04026D 21 7F 01 04 0287*       ld hl,_printDecBuffer
040271 CD 07 01 04 0288*       call printString
040275 E1          0289*       pop hl
040276 D1          0290*       pop de
040277 C9          0291*       ret
040278             0292*   
040278             0293*   print_s168_hl:
040278 F5          0294*       push af
040279 E5          0295*       push hl
04027A CD 63 02 04 0296*       call print_s168
04027E 3E 20       0297*       ld a,' '
040280 5B D7       0298*       rst.lil 10h
040282 E1          0299*       pop hl
040283 F1          0300*       pop af
040284 C9          0301*       ret
040285             0302*   
040285             0303*   print_s168_bc:
040285 F5          0304*       push af
040286 C5          0305*       push bc
040287 E5          0306*       push hl
040288 C5          0307*       push bc
040289 E1          0308*       pop hl
04028A CD 63 02 04 0309*       call print_s168
04028E 3E 20       0310*       ld a,' '
040290 5B D7       0311*       rst.lil 10h
040292 E1          0312*       pop hl
040293 C1          0313*       pop bc
040294 F1          0314*       pop af
040295 C9          0315*       ret
040296             0316*   
040296             0317*   print_s168_de:
040296 F5          0318*       push af
040297 D5          0319*       push de
040298 E5          0320*       push hl
040299 EB          0321*       ex de,hl
04029A CD 63 02 04 0322*       call print_s168
04029E 3E 20       0323*       ld a,' '
0402A0 5B D7       0324*       rst.lil 10h
0402A2 E1          0325*       pop hl
0402A3 D1          0326*       pop de
0402A4 F1          0327*       pop af
0402A5 C9          0328*       ret
0402A6             0329*   
0402A6             0330*   print_s168_hl_bc_de:
0402A6 F5          0331*       push af
0402A7 C5          0332*       push bc
0402A8 D5          0333*       push de
0402A9 E5          0334*       push hl
0402AA CD 63 02 04 0335*       call print_s168
0402AE 3E 20       0336*       ld a,' '
0402B0 5B D7       0337*       rst.lil 10h
0402B2 C5          0338*       push bc
0402B3 E1          0339*       pop hl
0402B4 CD 63 02 04 0340*       call print_s168
0402B8 3E 20       0341*       ld a,' '
0402BA 5B D7       0342*       rst.lil 10h
0402BC EB          0343*       ex de,hl
0402BD CD 63 02 04 0344*       call print_s168
0402C1 3E 20       0345*       ld a,' '
0402C3 5B D7       0346*       rst.lil 10h
0402C5 E1          0347*       pop hl
0402C6 D1          0348*       pop de
0402C7 C1          0349*       pop bc
0402C8 F1          0350*       pop af
0402C9 C9          0351*       ret
0402CA             0352*   
0402CA             0353*   print_s168_bc_de:
0402CA F5          0354*       push af
0402CB C5          0355*       push bc
0402CC D5          0356*       push de
0402CD C5          0357*       push bc
0402CE E1          0358*       pop hl
0402CF CD 63 02 04 0359*       call print_s168
0402D3 3E 20       0360*       ld a,' '
0402D5 5B D7       0361*       rst.lil 10h
0402D7 EB          0362*       ex de,hl
0402D8 CD 63 02 04 0363*       call print_s168
0402DC 3E 20       0364*       ld a,' '
0402DE 5B D7       0365*       rst.lil 10h
0402E0 E1          0366*       pop hl
0402E1 D1          0367*       pop de
0402E2 C1          0368*       pop bc
0402E3 F1          0369*       pop af
0402E4 C9          0370*       ret
0402E5             0371*   
0402E5             0372*   print_s168_a:
0402E5 F5          0373*       push af
0402E6 C5          0374*       push bc
0402E7 E5          0375*       push hl
0402E8 21 00 00 00 0376*       ld hl,0
0402EC 6F          0377*       ld l,a
0402ED CD 78 02 04 0378*       call print_s168_hl
0402F1 E1          0379*       pop hl
0402F2 C1          0380*       pop bc
0402F3 F1          0381*       pop af
0402F4 C9          0382*       ret
0402F5             0383*   
0402F5             0384*   ; #### new functions added by Brandon R. Gates ####
0402F5             0385*   
0402F5             0386*   ; print the binary representation of the 8-bit value in a
0402F5             0387*   ; destroys a, hl, bc
0402F5             0388*   printBin8:
0402F5 06 08       0389*       ld b,8 ; loop counter for 8 bits
0402F7 21 12 03 04 0390*       ld hl,@cmd ; set hl to the low byte of the output string
0402FB             0391*       ; (which will be the high bit of the value in a)
0402FB             0392*   @loop:
0402FB 07          0393*       rlca ; put the next highest bit into carry
0402FC 38 04       0394*       jr c,@one
0402FE 36 30       0395*       ld (hl),'0'
040300 18 02       0396*       jr @next_bit
040302             0397*   @one:
040302 36 31       0398*       ld (hl),'1'
040304             0399*   @next_bit:
040304 23          0400*       inc hl
040305 10 F4       0401*       djnz @loop
040307             0402*   ; print it
040307 21 12 03 04 0403*       ld hl,@cmd
04030B 01 08 00 00 0404*       ld bc,@end-@cmd
04030F 5B DF       0405*       rst.lil $18
040311 C9          0406*       ret
040312             0407*   @cmd: ds 8 ; eight bytes for eight bits
04031A             0408*   @end:
04031A             0409*   
04031A             0410*   ; print the binary representation of the 8-bit value in a
04031A             0411*   ; in reverse order (lsb first)
04031A             0412*   ; destroys a, hl, bc
04031A             0413*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
04031A 06 08       0414*       ld b,8 ; loop counter for 8 bits
04031C 21 37 03 04 0415*       ld hl,@cmd ; set hl to the low byte of the output string
040320             0416*       ; (which will be the high bit of the value in a)
040320             0417*   @loop:
040320 0F          0418*       rrca ; put the next lowest bit into carry
040321 38 04       0419*       jr c,@one
040323 36 30       0420*       ld (hl),'0'
040325 18 02       0421*       jr @next_bit
040327             0422*   @one:
040327 36 31       0423*       ld (hl),'1'
040329             0424*   @next_bit:
040329 23          0425*       inc hl
04032A 10 F4       0426*       djnz @loop
04032C             0427*   ; print it
04032C 21 37 03 04 0428*       ld hl,@cmd
040330 01 08 00 00 0429*       ld bc,@end-@cmd
040334 5B DF       0430*       rst.lil $18
040336 C9          0431*       ret
040337             0432*   @cmd: ds 8 ; eight bytes for eight bits
04033F             0433*   @end:
04033F             0434*   
       FF FF FF FF 
       FF FF FF FF 
04033F 20 61 66 3D 0435*   str_afu: db " af=",0
       00          
040344 20 68 6C 3D 0436*   str_hlu: db " hl=",0
       00          
040349 20 62 63 3D 0437*   str_bcu: db " bc=",0
       00          
04034E 20 64 65 3D 0438*   str_deu: db " de=",0
       00          
040353 20 69 78 3D 0439*   str_ixu: db " ix=",0
       00          
040358 20 69 79 3D 0440*   str_iyu: db " iy=",0
       00          
04035D             0441*   
04035D             0442*   ; print udeuhl to screen in hexidecimal format
04035D             0443*   ; inputs: none
04035D             0444*   ; outputs: concatenated hexidecimal udeuhl
04035D             0445*   ; destroys: nothing
04035D             0446*   dumpUDEUHLHex:
04035D             0447*   ; store everything in scratch
04035D 22 BC 03 04 0448*       ld (uhl),hl
040361 ED 43 BF 03 0449*       ld (ubc),bc
       04          
040366 ED 53 C2 03 0450*       ld (ude),de
       04          
04036B DD 22 C5 03 0451*       ld (uix),ix
       04          
040370 FD 22 C8 03 0452*       ld (uiy),iy
       04          
040375 F5          0453*       push af
040376             0454*   
040376             0455*   ; print each register
040376             0456*   
040376 21 B0 03 04 0457*       ld hl,str_udeuhl
04037A CD 07 01 04 0458*       call printString
04037E 2A C2 03 04 0459*       ld hl,(ude)
040382 CD 27 01 04 0460*       call printHex24
040386 3E 2E       0461*       ld a,'.' ; print a dot to separate the values
040388 5B D7       0462*       rst.lil 10h
04038A 2A BC 03 04 0463*       ld hl,(uhl)
04038E CD 27 01 04 0464*       call printHex24
040392 CD 1C 01 04 0465*       call printNewLine
040396             0466*   
040396             0467*   ; restore everything
040396 2A BC 03 04 0468*       ld hl, (uhl)
04039A ED 4B BF 03 0469*       ld bc, (ubc)
       04          
04039F ED 5B C2 03 0470*       ld de, (ude)
       04          
0403A4 DD 2A C5 03 0471*       ld ix, (uix)
       04          
0403A9 FD 2A C8 03 0472*       ld iy, (uiy)
       04          
0403AE F1          0473*       pop af
0403AF             0474*   ; all done
0403AF C9          0475*       ret
0403B0             0476*   
0403B0 75 64 65 2E 0477*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0403B9             0478*   
0403B9             0479*   ; global scratch memory for registers
0403B9 00 00 00    0480*   uaf: dl 0
0403BC 00 00 00    0481*   uhl: dl 0
0403BF 00 00 00    0482*   ubc: dl 0
0403C2 00 00 00    0483*   ude: dl 0
0403C5 00 00 00    0484*   uix: dl 0
0403C8 00 00 00    0485*   uiy: dl 0
0403CB 00 00 00    0486*   usp: dl 0
0403CE 00 00 00    0487*   upc: dl 0
0403D1             0488*   
0403D1             0489*   
0403D1             0490*   ; set all the bits in the flag register
0403D1             0491*   ; more of an academic exercise than anything useful
0403D1             0492*   ; inputs; none
0403D1             0493*   ; outputs; a=0,f=255
0403D1             0494*   ; destroys: flags, hl
0403D1             0495*   ; preserves: a, because why not
0403D1             0496*   setAllFlags:
0403D1 21 FF 00 00 0497*       ld hl,255
0403D5 67          0498*       ld h,a ; four cycles to preserve a is cheap
0403D6 E5          0499*       push hl
0403D7 F1          0500*       pop af
0403D8 C9          0501*       ret
0403D9             0502*   
0403D9             0503*   ; reset all the bits in the flag register
0403D9             0504*   ; unlike its inverse counterpart, this may actually be useful
0403D9             0505*   ; inputs; none
0403D9             0506*   ; outputs; a=0,f=0
0403D9             0507*   ; destroys: flags, hl
0403D9             0508*   ; preserves: a, because why not
0403D9             0509*   resetAllFlags:
0403D9 21 00 00 00 0510*       ld hl,0
0403DD 67          0511*       ld h,a ; four cycles to preserve a is cheap
0403DE E5          0512*       push hl
0403DF F1          0513*       pop af
0403E0 C9          0514*       ret
0403E1             0515*   
0403E1             0516*   ; wait until user presses a key
0403E1             0517*   ; inputs: none
0403E1             0518*   ; outputs: ascii code of key pressed in a
0403E1             0519*   ; destroys: af,ix
0403E1             0520*   waitKeypress:
0403E1             0521*       MOSCALL mos_getkey
0403E1 3E 00       0001*M1 			LD	A, function
0403E3 5B CF       0002*M1 			RST.LIL	08h
0403E5 C9          0522*       ret
0403E6             0523*   
0403E6             0524*   ; clear a block of memory by writing a prescribed value to each byte in the range
0403E6             0525*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
0403E6             0526*   ; outputs: memory block is cleared
0403E6             0527*   ; destroys: hl, de
0403E6             0528*   clear_mem:
0403E6 0B          0529*       dec bc ; we do this because we will increment de before writing the first byte
0403E7 77          0530*       ld (hl),a
0403E8 E5          0531*       push hl
0403E9 D1          0532*       pop de
0403EA 13          0533*       inc de ; target address
0403EB ED B0       0534*       ldir
0403ED C9          0535*       ret
0403EE             0032        include "arith24.inc"
0403EE             0001*   ;------------------------------------------------------------------------
0403EE             0002*   ;  arith24.asm
0403EE             0003*   ;  24-bit ez80 arithmetic routines
0403EE             0004*   ;  Copyright (c) Shawn Sijnstra 2024
0403EE             0005*   ;  MIT license
0403EE             0006*   ;
0403EE             0007*   ;  This library was created as a tool to help make ez80
0403EE             0008*   ;  24-bit native assembly routines for simple mathematical problems
0403EE             0009*   ;  more widely available.
0403EE             0010*   ;
0403EE             0011*   ;------------------------------------------------------------------------
0403EE             0012*   
0403EE             0013*   ;------------------------------------------------------------------------
0403EE             0014*   ; umul24:	HL = HL*DE (unsigned)
0403EE             0015*   ; Preserves AF, BC, DE
0403EE             0016*   ; Uses a fast multiply routine.
0403EE             0017*   ;------------------------------------------------------------------------
0403EE             0018*   umul24:
0403EE D5          0019*   	push	DE
0403EF C5          0020*   	push	BC
0403F0 F5          0021*   	push	AF
0403F1 E5          0022*   	push	HL
0403F2 C1          0023*   	pop		BC
0403F3 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
0403F5 21 00 00 00 0025*       ld	 	hl, 0 ; Result
0403F9             0026*   umul24_lp:
0403F9 29          0027*   	add	hl,hl
0403FA EB          0028*   	ex	de,hl
0403FB 29          0029*   	add	hl,hl
0403FC EB          0030*   	ex	de,hl
0403FD 30 01       0031*   	jr	nc,umul24_nc
0403FF 09          0032*   	add	hl,bc
040400             0033*   umul24_nc:
040400 3D          0034*   	dec	a
040401 20 F6       0035*   	jr	nz,umul24_lp
040403 F1          0036*   	pop	af
040404 C1          0037*   	pop	bc
040405 D1          0038*   	pop	de
040406 C9          0039*   	ret
040407             0040*   
040407             0041*   
040407             0042*   ;------------------------------------------------------------------------
040407             0043*   ; udiv24
040407             0044*   ; Unsigned 24-bit division
040407             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040407             0046*   ;
040407             0047*   ; Uses AF BC DE HL
040407             0048*   ; Uses Restoring Division algorithm
040407             0049*   ;------------------------------------------------------------------------
040407             0050*   
040407             0051*   udiv24:
040407 E5          0052*   	push	hl
040408 C1          0053*   	pop		bc	;move dividend to BCU
040409 21 00 00 00 0054*   	ld		hl,0	;result
04040D A7          0055*   	and		a
04040E ED 52       0056*   	sbc		hl,de	;test for div by 0
040410 C8          0057*   	ret		z		;it's zero, carry flag is clear
040411 19          0058*   	add		hl,de	;HL is 0 again
040412 3E 18       0059*   	ld		a,24	;number of loops through.
040414             0060*   udiv1:
040414 C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
040415 E3          0062*   	ex		(sp),hl
040416 37          0063*   	scf
040417 ED 6A       0064*   	adc	hl,hl
040419 E3          0065*   	ex	(sp),hl
04041A C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
04041B             0067*   
04041B ED 6A       0068*   	adc	hl,hl
04041D A7          0069*   	and	a		;is this the bug
04041E ED 52       0070*   	sbc	hl,de
040420 30 02       0071*   	jr	nc,udiv2
040422 19          0072*   	add	hl,de
040423             0073*   ;	dec	c
040423 0B          0074*   	dec	bc
040424             0075*   udiv2:
040424 3D          0076*   	dec	a
040425 20 ED       0077*   	jr	nz,udiv1
040427 37          0078*   	scf		;flag used for div0 error
040428 C5          0079*   	push	bc
040429 D1          0080*   	pop		de	;remainder
04042A C9          0081*   	ret
04042B             0082*   
04042B             0083*   
04042B             0084*   
04042B             0085*   ;------------------------------------------------------------------------
04042B             0086*   ; neg24
04042B             0087*   ; Returns: HLU = 0-HLU
04042B             0088*   ; preserves all other registers
04042B             0089*   ;------------------------------------------------------------------------
04042B             0090*   neg24:
04042B D5          0091*   	push	de
04042C EB          0092*   	ex		de,hl
04042D 21 00 00 00 0093*   	ld		hl,0
040431 B7          0094*   	or		a
040432 ED 52       0095*   	sbc		hl,de
040434 D1          0096*   	pop		de
040435 C9          0097*   	ret
040436             0098*   
040436             0099*   ;------------------------------------------------------------------------
040436             0100*   ; or_hlu_deu: 24 bit bitwise OR
040436             0101*   ; Returns: hlu = hlu OR deu
040436             0102*   ; preserves all other registers
040436             0103*   ;------------------------------------------------------------------------
040436             0104*   or_hlu_deu:
040436 22 BF 04 04 0105*   	ld	(bitbuf1),hl
04043A ED 53 C2 04 0106*   	ld	(bitbuf2),de
       04          
04043F D5          0107*   	push	de	;preserve DEU
040440 C5          0108*   	push	bc	;preserve BCU
040441 06 03       0109*   	ld		b,3
040443 21 BF 04 04 0110*   	ld	hl,bitbuf1
040447 11 BF 04 04 0111*   	ld	de,bitbuf1
04044B             0112*   orloop_24:
04044B 1A          0113*   	ld	a,(de)
04044C B6          0114*   	or	(hl)
04044D 12          0115*   	ld	(de),a
04044E 13          0116*   	inc	de
04044F 23          0117*   	inc	hl
040450 10 F9       0118*   	djnz	orloop_24
040452 2A C2 04 04 0119*   	ld	hl,(bitbuf2)
040456 C1          0120*   	pop		bc	;restore BC
040457 D1          0121*   	pop		de	;restore DE
040458             0122*   
040458             0123*   ;------------------------------------------------------------------------
040458             0124*   ; and_hlu_deu: 24 bit bitwise AND
040458             0125*   ; Returns: hlu = hlu AND deu
040458             0126*   ; preserves all other registers
040458             0127*   ;------------------------------------------------------------------------
040458             0128*   and_hlu_deu:
040458 22 BF 04 04 0129*   	ld	(bitbuf1),hl
04045C ED 53 C2 04 0130*   	ld	(bitbuf2),de
       04          
040461 D5          0131*   	push	de	;preserve DEU
040462 C5          0132*   	push	bc	;preserve BCU
040463 06 03       0133*   	ld		b,3
040465 21 BF 04 04 0134*   	ld	hl,bitbuf1
040469 11 BF 04 04 0135*   	ld	de,bitbuf1
04046D             0136*   andloop_24:
04046D 1A          0137*   	ld	a,(de)
04046E A6          0138*   	and	(hl)
04046F 12          0139*   	ld	(de),a
040470 13          0140*   	inc	de
040471 23          0141*   	inc	hl
040472 10 F9       0142*   	djnz	andloop_24
040474 2A C2 04 04 0143*   	ld	hl,(bitbuf2)
040478 C1          0144*   	pop		bc	;restore BC
040479 D1          0145*   	pop		de	;restore DE
04047A             0146*   
04047A             0147*   ;------------------------------------------------------------------------
04047A             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
04047A             0149*   ; Returns: hlu = hlu XOR deu
04047A             0150*   ; preserves all other registers
04047A             0151*   ;------------------------------------------------------------------------
04047A             0152*   xor_hlu_deu:
04047A 22 BF 04 04 0153*   	ld	(bitbuf1),hl
04047E ED 53 C2 04 0154*   	ld	(bitbuf2),de
       04          
040483 D5          0155*   	push	de	;preserve DEU
040484 C5          0156*   	push	bc	;preserve BCU
040485 06 03       0157*   	ld		b,3
040487 21 BF 04 04 0158*   	ld	hl,bitbuf1
04048B 11 BF 04 04 0159*   	ld	de,bitbuf1
04048F             0160*   xorloop_24:
04048F 1A          0161*   	ld	a,(de)
040490 AE          0162*   	xor	(hl)
040491 12          0163*   	ld	(de),a
040492 13          0164*   	inc	de
040493 23          0165*   	inc	hl
040494 10 F9       0166*   	djnz	xorloop_24
040496 2A C2 04 04 0167*   	ld	hl,(bitbuf2)
04049A C1          0168*   	pop		bc	;restore BC
04049B D1          0169*   	pop		de	;restore DE
04049C             0170*   
04049C             0171*   ;------------------------------------------------------------------------
04049C             0172*   ; shl_hlu: 24 bit shift left hlu by a positions
04049C             0173*   ; Returns: hlu = hlu << a
04049C             0174*   ;		   a = 0
04049C             0175*   ; NOTE: only considers a up to 16 bits.
04049C             0176*   ; preserves all other registers
04049C             0177*   ; modified by Brandon R. Gates to use a instead of de
04049C             0178*   ;------------------------------------------------------------------------
04049C             0179*   shl_hlu:
04049C B7          0180*   	or a
04049D C8          0181*   	ret		z		;we're done
04049E 29          0182*   	add		hl,hl	;shift HLU left
04049F 3D          0183*   	dec a
0404A0 18 FA       0184*   	jr		shl_hlu
0404A2             0185*   
0404A2             0186*   ;------------------------------------------------------------------------
0404A2             0187*   ; shr_hlu: 24 bit shift right hlu by a positions
0404A2             0188*   ; Returns: hlu = hlu >> a
0404A2             0189*   ;		   a = 0
0404A2             0190*   ; NOTE: only considers a up to 16 bits.
0404A2             0191*   ; preserves all other registers
0404A2             0192*   ; modified by Brandon R. Gates to use a instead of de
0404A2             0193*   ;------------------------------------------------------------------------
0404A2             0194*   shr_hlu:
0404A2 22 BF 04 04 0195*   	ld		(bitbuf1),hl
0404A6 21 C1 04 04 0196*   	ld		hl,bitbuf1+2
0404AA             0197*   @shr_loop:
0404AA B7          0198*   	or a
0404AB 28 0D       0199*   	jr		z,@shr_done		;we're done
0404AD             0200*   ;carry is clear from or instruction
0404AD CB 1E       0201*   	rr		(hl)
0404AF 2B          0202*   	dec		hl
0404B0 CB 1E       0203*   	rr		(hl)
0404B2 2B          0204*   	dec		hl
0404B3 CB 1E       0205*   	rr		(hl)
0404B5 23          0206*   	inc		hl
0404B6 23          0207*   	inc		hl
0404B7 3D          0208*   	dec a
0404B8 18 F0       0209*   	jr		@shr_loop
0404BA             0210*   @shr_done:
0404BA 2A BF 04 04 0211*   	ld		hl,(bitbuf1)	;collect result
0404BE C9          0212*   	ret
0404BF             0213*   
0404BF             0214*   ;------------------------------------------------------------------------
0404BF             0215*   ; Scratch area for calculations
0404BF             0216*   ;------------------------------------------------------------------------
0404BF 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
0404C2 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
0404C5             0219*   
0404C5             0220*   ; -----------------------------------------------------------------------
0404C5             0221*   ; Functions added by Brandon R. Gates
0404C5             0222*   ; -----------------------------------------------------------------------
0404C5             0223*   
0404C5             0224*   ;------------------------------------------------------------------------
0404C5             0225*   ; shr_hlu_div: Quick division by powers of two based on log2 of A
0404C5             0226*   ;              Determines the LSB of A and shifts HLU accordingly.
0404C5             0227*   ;              HLU = HLU >> LSB(A)
0404C5             0228*   ; Returns: HLU = HLU >> LSB(A)
0404C5             0229*   ; Destroys: af
0404C5             0230*   ;------------------------------------------------------------------------
0404C5             0231*   shr_hlu_log2a:
0404C5 B7          0232*   	or a    ; check for zero
0404C6 C8          0233*   	ret z   ; nothing to shift so we're done
0404C7 C5          0234*   	push 	bc ; preserve
0404C8 06 00       0235*   	ld		b,0 ; clear b
0404CA             0236*   @find_bit:
0404CA 0F          0237*   	rrca ; bit 0 to carry
0404CB DA D4 04 04 0238*   	jp c,@found_bit
0404CF 04          0239*   	inc b ; next bit
0404D0 C3 CA 04 04 0240*   	jp @find_bit
0404D4             0241*   @found_bit:
0404D4 78          0242*   	ld a,b
0404D5 CD A2 04 04 0243*   	call shr_hlu
0404D9 C1          0244*   	pop 	bc ; restore
0404DA C9          0245*   	ret
0404DB             0246*   ; end shr_hlu_log2a
0404DB             0247*   
0404DB             0248*   ;------------------------------------------------------------------------
0404DB             0249*   ; shl_hlu_log2a: Quick multiplication by powers of two based on log2 of A
0404DB             0250*   ;                Determines the LSB of A and shifts HLU accordingly.
0404DB             0251*   ;                HLU = HLU << LSB(A)
0404DB             0252*   ; Returns: HLU = HLU << LSB(A)
0404DB             0253*   ; Destroys: af
0404DB             0254*   ;------------------------------------------------------------------------
0404DB             0255*   shl_hlu_log2a:
0404DB B7          0256*   	or a    ; check for zero
0404DC C8          0257*   	ret z   ; nothing to shift so we're done
0404DD C5          0258*   	push 	bc ; preserve
0404DE 06 00       0259*   	ld		b,0 ; clear b
0404E0             0260*   @find_bit:
0404E0 0F          0261*   	rrca ; bit 0 to carry
0404E1 DA EA 04 04 0262*   	jp c,@found_bit
0404E5 04          0263*   	inc b ; next bit
0404E6 C3 E0 04 04 0264*   	jp @find_bit
0404EA             0265*   @found_bit:
0404EA 78          0266*   	ld a,b
0404EB CD 9C 04 04 0267*   	call shl_hlu
0404EF C1          0268*   	pop 	bc ; restore
0404F0 C9          0269*   	ret
0404F1             0270*   ; end shl_hlu_log2a
0404F1             0033        include "maths.inc"
0404F1 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040500             0002*   
040500             0003*   ;------------------------------------------------------------------------
040500             0004*   ; Scratch area for calculations
040500             0005*   ;------------------------------------------------------------------------
040500 00 00 00    0006*   scratch1: dw24 0 ;bit manipulation buffer 1
040503 00 00 00    0007*   scratch2: dw24 0 ;bit manipulation buffer 2
040506             0008*   
040506             0009*   ; absolute value of hlu
040506             0010*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040506             0011*   ;         s1,z0,pv0,n1,c0 if hlu was negative
040506             0012*   ;         s0,z1,pv0,n1,c0 if hlu was zero
040506             0013*   ;         s0,z0,pv0,n1,c0 if hlu was positive
040506             0014*   ; destroys: a
040506             0015*   hlu_abs:
040506 19          0016*       add hl,de
040507 B7          0017*       or a
040508 ED 52       0018*       sbc hl,de
04050A FA 0F 05 04 0019*       jp m,@is_neg
04050E C9          0020*       ret ; hlu is positive or zero so we're done
04050F             0021*   @is_neg:
04050F F5          0022*       push af ; otherwise, save current flags for return
040510 CD 16 05 04 0023*       call neg_hlu ; negate hlu
040514 F1          0024*       pop af ; get back flags
040515 C9          0025*       ret
040516             0026*   
040516             0027*   ; flip the sign of hlu
040516             0028*   ; inputs: hlu
040516             0029*   ; returns: 0-hlu, flags set appropriately for the result:
040516             0030*   ;         s1,z0,pv0,n1,c1 if result is negative
040516             0031*   ;         s0,z1,pv0,n1,c0 if result is zero
040516             0032*   ;         s0,z0,pv0,n1,c1 if result is positive
040516             0033*   ; destroys a
040516             0034*   neg_hlu:
040516 D5          0035*       push de ; save de
040517 EB          0036*       ex de,hl ; put hl into de
040518 21 00 00 00 0037*       ld hl,0 ; clear hl
04051C AF          0038*       xor a ; clear carry
04051D ED 52       0039*       sbc hl,de ; 0-hlu = -hlu
04051F D1          0040*       pop de ; get de back
040520 C9          0041*       ret ; easy peasy
040521             0042*   
040521             0043*   ;------------------------------------------------------------------------
040521             0044*   ; divide hlu by 2, inspired by above
040521             0045*   ;------------------------------------------------------------------------
040521             0046*   hlu_div2:
040521 22 00 05 04 0047*       ld (scratch1),hl
040525 21 02 05 04 0048*       ld hl,scratch1+2
040529 CB 1E       0049*       rr (hl)
04052B 2B          0050*       dec hl
04052C CB 1E       0051*       rr (hl)
04052E 2B          0052*       dec hl
04052F CB 1E       0053*       rr (hl)
040531 23          0054*       inc hl
040532 23          0055*       inc hl
040533 2A 00 05 04 0056*       ld hl,(scratch1)
040537 C9          0057*       ret
040538             0058*   
040538             0059*   ; this is my little hack to divide by 16
040538             0060*   hlu_div16:
040538 AF          0061*       xor a
040539 29          0062*       add hl,hl
04053A 17          0063*       rla
04053B 29          0064*       add hl,hl
04053C 17          0065*       rla
04053D 29          0066*       add hl,hl
04053E 17          0067*       rla
04053F 29          0068*       add hl,hl
040540 17          0069*       rla
040541 22 4E 05 04 0070*       ld (@scratch),hl
040545 32 51 05 04 0071*       ld (@scratch+3),a
040549 2A 4F 05 04 0072*       ld hl,(@scratch+1)
04054D C9          0073*       ret
04054E             0074*   @scratch: ds 4
040552             0075*   
040552             0076*   ; hlu signed division by 256
040552             0077*   ; returns: hlu / 256
040552             0078*   ; destroys: af
040552             0079*   hlu_sdiv256:
       FF FF FF FF 
040552 AF          0080*       xor a ; assume hl is positive
040553 22 69 05 04 0081*       ld (@buffer),hl
040557             0082*       SIGN_HLU
040557 19          0001*M1     add hl,de ; 1 cycle
040558 B7          0002*M1     or a ; clear flags ; 1 cycle
040559 ED 52       0003*M1     sbc hl,de ; 2 cycles
04055B             0004*M1     ; 4 cycles total
04055B F2 60 05 04 0083*       jp p,@hl_pos
04055F 3D          0084*       dec a
040560             0085*   @hl_pos:
040560 32 6C 05 04 0086*       ld (@buffer+3),a
040564 2A 6A 05 04 0087*       ld hl,(@buffer+1)
040568 C9          0088*       ret
040569             0089*   @buffer: ds 4
04056D             0090*   
04056D             0091*   ; hlu 1 byte right shift, unsigned
04056D             0092*   ; returns: hlu / 256, fractional portion in a
04056D             0093*   ; destroys: af
04056D             0094*   hlu_udiv256:
       FF FF FF FF 
04056D AF          0095*       xor a
04056E 32 7F 05 04 0096*       ld (@buffer+3),a
040572 7D          0097*       ld a,l ; save the fractional portion
040573 22 7C 05 04 0098*       ld (@buffer),hl
040577 2A 7D 05 04 0099*       ld hl,(@buffer+1)
04057B C9          0100*       ret
04057C             0101*   @buffer: ds 4
040580             0102*   
       FF FF FF FF 
040580 00 00 00 00 0103*   add_bcd_arg1: db #00,#00,#00,#00
040584 00 00 00 00 0104*   add_bcd_arg2: db #00,#00,#00,#00
040588             0105*   
040588             0106*   ; set bcd values in a scratch memory address from registers bcde
040588             0107*   ; input: hl; scratch address,bcde; 8-place bcd number
040588             0108*   ; destroys ; hl
040588             0109*   set_bcd:
040588 73          0110*       ld (hl),e
040589 23          0111*       inc hl
04058A 72          0112*       ld (hl),d
04058B 23          0113*       inc hl
04058C 71          0114*       ld (hl),c
04058D 23          0115*       inc hl
04058E 70          0116*       ld (hl),b
04058F C9          0117*       ret
040590             0118*   
040590             0119*   ; load bcd values from a scratch memory address to bcde
040590             0120*   ; input: hl; scratch address
040590             0121*   ; output: bcde; 8-place bcd number
040590             0122*   ; destroys: hl
040590             0123*   get_bcd:
040590 5E          0124*       ld e,(hl)
040591 23          0125*       inc hl
040592 56          0126*       ld d,(hl)
040593 23          0127*       inc hl
040594 4E          0128*       ld c,(hl)
040595 23          0129*       inc hl
040596 46          0130*       ld b,(hl)
040597 C9          0131*       ret
040598             0132*   
040598             0133*   ; BCD addition
040598             0134*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
040598             0135*   ;       a is the number of bytes holding each number (number of places/2)
040598             0136*   ; outputs: (hl) + (de) --> (hl)
040598             0137*   ; destroys: a,b,de,hl
040598             0138*   add_bcd:
040598 47          0139*       ld b,a ; loop counter
040599 AF          0140*       xor a ; reset a, clear carry flag
04059A             0141*   adcec:
04059A 1A          0142*       ld a,(de) ; addend to acc
04059B 8E          0143*       adc a,(hl) ; add (hl) to acc
04059C 27          0144*       daa ; adjust result to bcd
04059D 77          0145*       ld (hl),a ; store result
04059E 23          0146*       inc hl ; advance memory pointers
04059F 13          0147*       inc de
0405A0 10 F8       0148*       djnz adcec ; loop until b == 0
0405A2 C9          0149*       ret
0405A3             0150*   
0405A3             0151*   ; BCD subtraction
0405A3             0152*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0405A3             0153*   ;       a is the number of bytes holding each number (number of places/2)
0405A3             0154*   ; outputs: (hl) - (de) --> (hl)
0405A3             0155*   ; destroys: a,b,de,hl
0405A3             0156*   sub_bcd:
0405A3 47          0157*       ld b,a ; loop counter
0405A4 AF          0158*       xor a ; reset a,clear carry flag
0405A5             0159*   subdec:
0405A5 1A          0160*       ld a,(de) ; subtrahend to acc
0405A6 9E          0161*       sbc a,(hl) ; subtract (hl) from acc
0405A7 27          0162*       daa ; adjust result to bcd
0405A8 77          0163*       ld (hl),a ; store result
0405A9 23          0164*       inc hl ; advance memory pointers
0405AA 13          0165*       inc de
0405AB 10 F8       0166*       djnz subdec ; loop until b == 0
0405AD C9          0167*       ret
0405AE             0168*   
0405AE             0169*   ; http://www.z80.info/pseudo-random.txt
0405AE             0170*   rand_8:
0405AE C5          0171*       push bc
0405AF 3A C2 05 04 0172*       ld a,(r_seed)
0405B3 4F          0173*       ld c,a
0405B4             0174*   
0405B4 0F          0175*       rrca ; multiply by 32
0405B5 0F          0176*       rrca
0405B6 0F          0177*       rrca
0405B7 EE 1F       0178*       xor 0x1f
0405B9             0179*   
0405B9 81          0180*       add a,c
0405BA DE FF       0181*       sbc a,255 ; carry
0405BC             0182*   
0405BC 32 C2 05 04 0183*       ld (r_seed),a
0405C0 C1          0184*       pop bc
0405C1 C9          0185*       ret
0405C2 50          0186*   r_seed: defb $50
0405C3             0187*   
0405C3             0188*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
0405C3             0189*   prng24:
0405C3             0190*   ;;Expects ADL mode.
0405C3             0191*   ;;Output: HL
0405C3             0192*   ;;50cc
0405C3             0193*   ;;33 bytes
0405C3             0194*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
0405C3 ED 5B E4 05 0195*       ld de,(seed1)
       04          
0405C8 B7          0196*       or a
0405C9 ED 62       0197*       sbc hl,hl
0405CB 19          0198*       add hl,de
0405CC 29          0199*       add hl,hl
0405CD 29          0200*       add hl,hl
0405CE 2C          0201*       inc l
0405CF 19          0202*       add hl,de
0405D0 22 E4 05 04 0203*       ld (seed1),hl
0405D4 2A E7 05 04 0204*       ld hl,(seed2)
0405D8 29          0205*       add hl,hl
0405D9 9F          0206*       sbc a,a
0405DA E6 1B       0207*       and %00011011
0405DC AD          0208*       xor l
0405DD 6F          0209*       ld l,a
0405DE 22 E7 05 04 0210*       ld (seed2),hl
0405E2 19          0211*       add hl,de
0405E3 C9          0212*       ret
0405E4 00 00 00    0213*   seed1: dl 0
0405E7 00 00 00    0214*   seed2: dl 0
0405EA             0034        include "files.inc"
0405EA             0001*   ; load to onboard 8k sram
0405EA             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
0405EA             0035        include "fixed168.inc"
0405EA FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
040600             0002*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
040600             0003*   ; uses EZ80 MLT instruction for speed
040600             0004*   ; operation: UHL * A --> UHL
040600             0005*   ; destroys: AF, HL
040600             0006*   smul24x8:
040600             0007*   ; make hl positive and store sign flag
040600 CD 06 05 04 0008*       call hlu_abs
040604 F5          0009*       push af
040605             0010*   ; do the division
040605 CD 10 06 04 0011*       call mul24x8 ; hl = product
040609             0012*   ; adjust sign of result
040609 F1          0013*       pop af ; sign de
04060A F0          0014*       ret p ; hl was positive, nothing to do
04060B CD 16 05 04 0015*       call neg_hlu ; result is negative
04060F C9          0016*       ret
040610             0017*   
040610             0018*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040610             0019*   ; uses EZ80 MLT instruction for speed
040610             0020*   ; operation: UHL * A --> AUHL
040610             0021*   ; destroys: AF, HL
040610             0022*   mul24x8:
040610 D5          0023*       push de ; preserve de
040611             0024*   ; low byte
040611 5D          0025*       ld e,l
040612 57          0026*       ld d,a
040613 ED 5C       0027*       mlt de
040615 6B          0028*       ld l,e ; product low byte
040616 08          0029*       ex af,af' ; save multiplier
040617 7A          0030*       ld a,d ; carry
040618 08          0031*       ex af,af' ; save carry, restore multiplier
040619             0032*   ; high byte
040619 5C          0033*       ld e,h
04061A 57          0034*       ld d,a
04061B ED 5C       0035*       mlt de
04061D 08          0036*       ex af,af' ; save multiplier, restore carry
04061E 83          0037*       add a,e ; add carry
04061F 67          0038*       ld h,a ; product middle byte
040620 7A          0039*       ld a,d ; carry
040621 08          0040*       ex af,af' ; save carry, restore multiplier
040622             0041*   ; upper byte
040622 22 3D 06 04 0042*       ld (@scratch),hl ; 7 cycles
040626 5F          0043*       ld e,a
040627 3A 3F 06 04 0044*       ld a,(@scratch+2)
04062B 57          0045*       ld d,a
04062C ED 5C       0046*       mlt de
04062E 08          0047*       ex af,af' ; restore carry
04062F 8B          0048*       adc a,e ; add carry
040630 32 3F 06 04 0049*       ld (@scratch+2),a ; 5 cycles
040634 2A 3D 06 04 0050*       ld hl,(@scratch) ; 7 cycles
040638             0051*   ; highest byte
040638 3E 00       0052*       ld a,0 ; preserve carry flag
04063A 8A          0053*       adc a,d ; product highest byte
04063B D1          0054*       pop de ; restore de
04063C C9          0055*       ret
04063D             0056*   @scratch: ds 3
040640             0057*   
       FF FF FF 
040640 00 00 00 00 0058*   mul24out: blkb 6,0
       00 00       
040646             0059*   
040646             0060*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040646             0061*   ; operation: UHL * UDE --> mul24out
040646             0062*   mul24:
040646 DD E5       0063*       push ix ; preserve
040648             0064*   ; point to output buffer and clear it
040648 DD 21 40 06 0065*       ld ix,mul24out
       04          
04064D C5          0066*       push bc
04064E 01 00 00 00 0067*       ld bc,0
040652 DD 0F 00    0068*       ld (ix),bc
040655 DD 0F 03    0069*       ld (ix+3),bc
040658 C1          0070*       pop bc
040659             0071*   ; STEP 1: UHL * E
040659 7B          0072*       ld a,e
04065A E5          0073*       push hl
04065B CD 10 06 04 0074*       call mul24x8
04065F DD 2F 00    0075*       ld (ix+0),hl
040662 DD 77 03    0076*       ld (ix+3),a
040665             0077*   ; STEP 2: UHL * D
040665 E1          0078*       pop hl
040666 E5          0079*       push hl
040667 7A          0080*       ld a,d
040668 CD 10 06 04 0081*       call mul24x8
04066C CD 85 06 04 0082*       call @accumulate
040670             0083*   ; STEP 3: UHL * DEU
040670 E1          0084*       pop hl
040671 ED 53 B5 06 0085*       ld (@de),de
       04          
040676 3A B7 06 04 0086*       ld a,(@de+2)
04067A CD 10 06 04 0087*       call mul24x8
04067E CD 85 06 04 0088*       call @accumulate
040682             0089*   ; all done
040682 DD E1       0090*       pop ix ; restore
040684 C9          0091*       ret
040685             0092*   @accumulate:
040685 DD 23       0093*       inc ix
040687             0094*   ; highest byte of product to carry
040687 DD 77 03    0095*       ld (ix+3),a
04068A             0096*   ; low byte of product
04068A 7D          0097*       ld a,l
04068B DD 86 00    0098*       add a,(ix+0)
04068E DD 77 00    0099*       ld (ix+0),a
040691             0100*   ; high byte of product
040691 7C          0101*       ld a,h
040692 DD 8E 01    0102*       adc a,(ix+1)
040695 DD 77 01    0103*       ld (ix+1),a
040698             0104*   ; uppper byte of product
040698 22 B2 06 04 0105*       ld (@hl),hl
04069C 3A B4 06 04 0106*       ld a,(@hl+2)
0406A0 DD 8E 02    0107*       adc a,(ix+2)
0406A3 DD 77 02    0108*       ld (ix+2),a
0406A6             0109*   ; carry
0406A6 3E 00       0110*       ld a,0 ; preserve flags
0406A8 DD 8E 03    0111*       adc a,(ix+3)
0406AB DD 77 03    0112*       ld (ix+3),a
0406AE C9          0113*       ret
0406AF             0114*   
0406AF 00 00 00    0115*   @ix: dl 0
0406B2 00 00 00    0116*   @hl: dl 0
0406B5 00 00 00    0117*   @de: dl 0
0406B8             0118*   
0406B8             0119*   ; ; UHL * UDE --> UHL (unsigned)
0406B8             0120*   ; umul24:
0406B8             0121*   ;     call mul24
0406B8             0122*   ;     ld hl,(mul24out)
0406B8             0123*   ;     ret
0406B8             0124*   
0406B8             0125*   ; UH.L = UH.L*UD.E (unsigned)
0406B8             0126*   umul168:
0406B8 CD 46 06 04 0127*       call mul24
0406BC 2A 41 06 04 0128*       ld hl,(mul24out+1)
0406C0 C9          0129*       ret
0406C1             0130*   
0406C1             0131*   ; UH.L * UD.E --> UH.L (signed)
0406C1             0132*   smul168:
0406C1             0133*   ; make everything positive and store sign flags
0406C1 CD 06 05 04 0134*       call hlu_abs
0406C5 F5          0135*       push af
0406C6 EB          0136*       ex de,hl
0406C7 CD 06 05 04 0137*       call hlu_abs
0406CB EB          0138*       ex de,hl
0406CC F5          0139*       push af
0406CD             0140*   ; do the division
0406CD CD B8 06 04 0141*       call umul168 ; hl = product
0406D1             0142*   ; adjust sign of result
0406D1 F1          0143*       pop af ; sign de
0406D2 FA DD 06 04 0144*       jp m,@de_neg
0406D6 F1          0145*       pop af ; sign hl
0406D7 F0          0146*       ret p ; both positive, nothing to do
0406D8             0147*   @hl_neg:
0406D8 CD 16 05 04 0148*       call neg_hlu ; de pos, hl neg, result is negative
0406DC C9          0149*       ret
0406DD             0150*   @de_neg:
0406DD F1          0151*       pop af
0406DE F8          0152*       ret m ; both negative, nothing to do
0406DF CD 16 05 04 0153*       call neg_hlu ; result is negative
0406E3 C9          0154*       ret
0406E4             0155*   
0406E4             0156*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0406E4             0157*   ; perform unsigned division of 16.8 fixed place values
0406E4             0158*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
0406E4             0159*   udiv168:
0406E4             0160*   ; back up divisor
0406E4 ED 53 1B 07 0161*       ld (@ude),de
       04          
0406E9             0162*   ; get the 16-bit integer part of the quotient
0406E9 CD 07 04 04 0163*       call udiv24 ; de = quotient, hl = remainder
0406ED             0164*   ; load quotient to upper three bytes of output
0406ED ED 53 22 07 0165*       ld (div168_out+1),de
       04          
0406F2             0166*   @div256:
0406F2             0167*   ; multiply remainder by 256
0406F2             0168*       hlu_mul256
0406F2 29          0001*M1     add hl,hl ; * 2
0406F3 29          0002*M1     add hl,hl ; * 4
0406F4 29          0003*M1     add hl,hl ; * 8
0406F5 29          0004*M1     add hl,hl ; * 16
0406F6 29          0005*M1     add hl,hl ; * 32
0406F7 29          0006*M1     add hl,hl ; * 64
0406F8 29          0007*M1     add hl,hl ; * 128
0406F9 29          0008*M1     add hl,hl ; * 256
0406FA             0169*   ; skip fractional computation if remainder is zero
0406FA             0170*       SIGN_HLU
0406FA 19          0001*M1     add hl,de ; 1 cycle
0406FB B7          0002*M1     or a ; clear flags ; 1 cycle
0406FC ED 52       0003*M1     sbc hl,de ; 2 cycles
0406FE             0004*M1     ; 4 cycles total
0406FE 20 03       0171*       jr nz,@div_frac
040700 AF          0172*       xor a
040701 18 0A       0173*       jr @write_frac
040703             0174*   ; now divide the shifted remainder by the divisor
040703             0175*   @div_frac:
040703 ED 5B 1B 07 0176*       ld de,(@ude) ; get back divisor
       04          
040708 CD 07 04 04 0177*       call udiv24 ; de = quotient, hl = remainder
04070C             0178*   ; load low byte of quotient to low byte of output
04070C 7B          0179*       ld a,e
04070D             0180*   @write_frac:
04070D 32 21 07 04 0181*       ld (div168_out),a
040711             0182*   ; load de with return value
040711 ED 5B 21 07 0183*       ld de,(div168_out)
       04          
040716             0184*   ; load a with any overflow
040716 3A 24 07 04 0185*       ld a,(div168_out+3)
04071A C9          0186*       ret ; ud.e is the 16.8 result
04071B             0187*   @ude: ds 6
040721             0188*   div168_out: ds 4 ; the extra byte is for overflow
040725             0189*   
040725             0190*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
040725             0191*   ; perform signed division of 16.8 fixed place values
040725             0192*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
040725             0193*   sdiv168:
040725             0194*   ; make everything positive and store sign flags
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
040725 CD 06 05 04 0195*       call hlu_abs
040729 F5          0196*       push af
04072A EB          0197*       ex de,hl
04072B CD 06 05 04 0198*       call hlu_abs
04072F EB          0199*       ex de,hl
040730 F5          0200*       push af
040731             0201*   ; do the division
040731 CD E4 06 04 0202*       call udiv168 ; de = quotient, hl = remainder
040735             0203*   ; adjust sign of result
040735 F1          0204*       pop af ; sign de
040736 FA 43 07 04 0205*       jp m,@de_neg
04073A F1          0206*       pop af ; sign hl
04073B F0          0207*       ret p ; both positive, nothing to do
04073C             0208*   @hl_neg:
04073C EB          0209*       ex de,hl ; hl = quotient, de = remainder
04073D CD 16 05 04 0210*       call neg_hlu ; de pos, hl neg, result is negative
040741 EB          0211*       ex de,hl ; de = negated quotient, hl = remainder
040742 C9          0212*       ret
040743             0213*   @de_neg:
040743 F1          0214*       pop af
040744 F8          0215*       ret m ; both negative, nothing to do
040745 EB          0216*       ex de,hl ; hl = quotient, de = remainder
040746 CD 16 05 04 0217*       call neg_hlu ; result is negative
04074A EB          0218*       ex de,hl ; de = negated quotient, hl = remainder
04074B C9          0219*       ret
04074C             0220*   
04074C             0221*   ; convert signed angles from a 360 to 256 degree circle
04074C             0222*   ; inputs: uh.l is the angle360 in 16.8 fixed format
04074C             0223*   ; outputs: uh.l is the angle256 in 16.8 fixed format
04074C             0224*   ; destroys: TODO
04074C             0225*   deg_360_to_256:
04074C D5          0226*       push de ; preserve de
04074D             0227*   ; make angle positive and store sign flag
04074D CD 06 05 04 0228*       call hlu_abs
040751 F5          0229*       push af
040752             0230*   ; multiply by coversion factor of 256/360
040752 11 B6 00 00 0231*       ld de,0x0000B6 ; 0.711
040756 CD B8 06 04 0232*       call umul168 ; uh.l = uh.l * 0.711
04075A             0233*   ; restore sign flag and adjust output accordingly
04075A F1          0234*       pop af
04075B F2 63 07 04 0235*       jp p,@pos ; positive number
04075F CD 16 05 04 0236*       call neg_hlu
040763             0237*   @pos:
040763             0238*   ; restore de and return uh.l as the result
040763 D1          0239*       pop de
040764 C9          0240*       ret
040765             0241*   
040765             0242*   ; convert signed angles from a 256 to 360 degree circle
040765             0243*   ; inputs: uh.l is the angle256 in 16.8 fixed format
040765             0244*   ; outputs: uh.l is the angle360 in 16.8 fixed format
040765             0245*   ; destroys: TODO
040765             0246*   deg_256_to_360:
040765 D5          0247*       push de ; preserve de
040766             0248*   ; make angle positive and store sign flag
040766 CD 06 05 04 0249*       call hlu_abs
04076A F5          0250*       push af
04076B             0251*   ; multiply by coversion factor of 360/256
04076B 11 68 01 00 0252*       ld de,0x000168 ; 1.406
04076F CD B8 06 04 0253*       call umul168 ; uh.l = uh.l * 1.406
040773             0254*   ; restore sign flag and adjust output accordingly
040773 F1          0255*       pop af
040774 F2 7C 07 04 0256*       jp p,@pos ; positive number
040778 CD 16 05 04 0257*       call neg_hlu
04077C             0258*   @pos:
04077C             0259*   ; restore de and return uh.l as the result
04077C D1          0260*       pop de
04077D C9          0261*       ret
04077E             0262*   
04077E             0263*   ; fixed 16.8 routine
04077E             0264*   ; cos(uh.l) --> uh.l
04077E             0265*   ; destroys: f, hl
04077E             0266*   cos168:
04077E D5          0267*       push de ; preserve de
04077F             0268*   ; for cos we simply increment the angle by 90 degrees
04077F             0269*   ; or 0x004000 in 16.8 degrees256
04077F             0270*   ; which makes it a sin problem
04077F 11 00 40 00 0271*       ld de,0x004000
040783 19          0272*       add hl,de ; modulo 256 happens below
040784 D1          0273*       pop de ; restore de
040785             0274*   ; fall through to sin168
040785             0275*   
040785             0276*   ; ---------------------
040785             0277*   ; fixed 16.8 routine
040785             0278*   ; sin(uh.l) --> uh.l
040785             0279*   ; destroys: f, hl
040785             0280*   sin168:
040785 D5          0281*       push de
040786             0282*   ; handle negative angles appropriately
040786 CD 06 05 04 0283*       call hlu_abs
04078A F2 93 07 04 0284*       jp p,@F
04078E 11 00 00 FF 0285*       ld de,-256*256
040792 19          0286*       add hl,de
040793             0287*   @@:
040793 2E 03       0288*       ld l,3 ; multiply by 3 to get our lookup index
040795 ED 6C       0289*       mlt hl
040797 11 4B 0A 04 0290*       ld de,sin_lut_168 ; grab the lut address
04079B 19          0291*       add hl,de ; bump hl by the index
04079C ED 27       0292*       ld hl,(hl) ; don't try this on a z80!
04079E D1          0293*       pop de
04079F C9          0294*       ret
0407A0             0295*   
0407A0             0296*   ; 16.8 fixed inputs / outputs
0407A0             0297*   ; takes: uh.l as angle in degrees 256
0407A0             0298*   ;        ud.e as radius
0407A0             0299*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0407A0             0300*   ;        displacements from origin (0,0)
0407A0             0301*   ; destroys: everything except indexes
0407A0             0302*   polar_to_cartesian:
0407A0             0303*   ; back up input parameters
0407A0 22 CF 07 04 0304*       ld (@angle), hl
0407A4 ED 53 D2 07 0305*       ld (@radius), de
       04          
0407A9             0306*   ; compute dx = sin(uh.l) * ud.e
0407A9 CD 85 07 04 0307*       call sin168 ; uh.l = sin(uh.l)
0407AD ED 5B D2 07 0308*       ld de,(@radius)
       04          
0407B2 CD C1 06 04 0309*       call smul168 ; uh.l = dx
0407B6 E5          0310*       push hl
0407B7             0311*   ; compute dy = -cos(uh.l) * ud.e
0407B7 2A CF 07 04 0312*       ld hl,(@angle)
0407BB CD 7E 07 04 0313*       call cos168 ; uh.l = cos(uh.l)
0407BF ED 5B D2 07 0314*       ld de,(@radius)
       04          
0407C4 CD C1 06 04 0315*       call smul168 ; uh.l = dy
0407C8 CD 16 05 04 0316*       call neg_hlu ; invert dy for screen coords convention
0407CC EB          0317*       ex de,hl ; de = dy for output
0407CD C1          0318*       pop bc ; bc = dx for output
0407CE             0319*   ; and out
0407CE C9          0320*       ret
0407CF             0321*   @angle: ds 3
0407D2             0322*   @radius: ds 3
0407D5             0323*   
0407D5             0324*   ; 16.8 fixed inputs / outputs
0407D5             0325*   ; inputs: ub.c as dx, ud.e as dy
0407D5             0326*   ;        displacements from origin (0,0)
0407D5             0327*   ; returns: uh.l as angle in degrees 256
0407D5             0328*   ;        ud.e as radius
0407D5             0329*   ; destroys: everything except indexes
0407D5             0330*   cartesian_to_polar:
       FF FF FF FF 
       FF FF 
0407D5 ED 43 2E 08 0331*       ld (dx168),bc ; dx argument for distance168
       04          
0407DA ED 53 34 08 0332*       ld (dy168),de ; dy argument for distance168
       04          
0407DF             0333*   ; compute radius
0407DF CD 3A 08 04 0334*       call distance168 ; uh.l = radius
0407E3 E5          0335*       push hl ; save radius
0407E4             0336*   ; compute angle
0407E4 ED 4B 2E 08 0337*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
0407E9 ED 5B 34 08 0338*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
0407EE CD 9A 08 04 0339*       call atan2_168fast ; uh.l = angle
0407F2             0340*   ; return result
0407F2 D1          0341*       pop de ; de = radius (was hl)
0407F3 C9          0342*       ret
0407F4             0343*   ; end cartesian_to_polar
0407F4             0344*   
0407F4             0345*   ; 16.8 fixed inputs / outputs
0407F4             0346*   ; inputs: ub.c as dx, ud.e as dy
0407F4             0347*   ;        displacements from origin (0,0)
0407F4             0348*   ; returns: uh.l as angle in degrees 256
0407F4             0349*   ;        ud.e as radius
0407F4             0350*   ; destroys: everything except indexes
0407F4             0351*   ; note: uses distance168sm which is more accurate for small deltas
0407F4             0352*   cartesian_to_polar_sm:
0407F4 ED 43 2E 08 0353*       ld (dx168),bc ; dx argument for distance168
       04          
0407F9 ED 53 34 08 0354*       ld (dy168),de ; dy argument for distance168
       04          
0407FE             0355*   ; compute radius
0407FE CD 75 08 04 0356*       call distance168sm ; uh.l = radius
040802 E5          0357*       push hl ; save radius
040803             0358*   ; compute angle
040803 ED 4B 2E 08 0359*       ld bc,(dx168) ; dx argument for atan2_168fast
       04          
040808 ED 5B 34 08 0360*       ld de,(dy168) ; dy argument for atan2_168fast
       04          
04080D CD 9A 08 04 0361*       call atan2_168fast ; uh.l = angle
040811             0362*   ; return result
040811 D1          0363*       pop de ; de = radius (was hl)
040812 C9          0364*       ret
040813             0365*   ; end cartesian_to_polar
040813             0366*   
040813             0367*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040813             0368*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040813             0369*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040813             0370*   ;         also populates scratch locations dx168 and dy168
040813             0371*   ; destroys: a,hl,bc,de
040813             0372*   dxy168:
040813             0373*   ; compute dx = x1-x0
040813 AF          0374*       xor a ; clear carry
040814 DD E5       0375*       push ix ; move ix to hl via the stack
040816 E1          0376*       pop hl ; hl = x1
040817 ED 42       0377*       sbc hl,bc ; hl = dx
040819 22 2E 08 04 0378*       ld (dx168),hl ; dx to scratch
04081D             0379*   ; compute dy = y1-y0
04081D AF          0380*       xor a ; clear carry
04081E FD E5       0381*       push iy ; move iy to hl via the stack
040820 E1          0382*       pop hl ; hl = y1
040821 ED 52       0383*       sbc hl,de ; hl = dy
040823 22 34 08 04 0384*       ld (dy168),hl ; dy to scratch
040827             0385*   ; populate output registers and return
040827 EB          0386*       ex de,hl ; ud.e = dy
040828 ED 4B 2E 08 0387*       ld bc,(dx168) ; ub.c = dx
       04          
04082D C9          0388*       ret
04082E 00 00 00 00 0389*   dx168: blkb 6,0
       00 00       
040834 00 00 00 00 0390*   dy168: blkb 6,0
       00 00       
04083A             0391*   
04083A             0392*   ; compute the euclidian distance between two cartesian coordinates
04083A             0393*   ; using the formula d = sqrt(dx^2+dy^2)
04083A             0394*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
04083A             0395*   ; output; uh.l is the 16.8 fixed format distance
04083A             0396*   ;         also populates scratch locations dx168 and dy168
04083A             0397*   ; destroys: a,hl,bc,de
04083A             0398*   ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
04083A             0399*   ;       thus the result will always be an integer, albeit in 16.8 format
04083A             0400*   distance168:
04083A             0401*   ; compute dy^2
04083A 2A 34 08 04 0402*       ld hl,(dy168)
04083E CD 06 05 04 0403*       call hlu_abs
040842             0404*       ; call hlu_udiv256 ; make integer to avoid overflow
040842             0405*       SRL_UHL ; make integer to avoid overflow
040842 3B          0001*M1     dec sp ; 1 cycle
040843 E5          0002*M1     push hl ; 4 cycles
040844 33          0003*M1     inc sp ; 1 cycle
040845 E1          0004*M1     pop hl ; 4 cycles
040846 23          0005*M1     inc hl ; 1 cycle
040847 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040849             0007*M1     ; 13 cycles total
040849 E5          0406*       push hl
04084A D1          0407*       pop de
04084B CD EE 03 04 0408*       call umul24 ; hl = dy^2
04084F E5          0409*       push hl ; save dy^2
040850             0410*   ; compute dx^2
040850 2A 2E 08 04 0411*       ld hl,(dx168)
040854 CD 06 05 04 0412*       call hlu_abs
040858             0413*       ; call hlu_udiv256 ; make integer to avoid overflow
040858             0414*       SRL_UHL ; make integer to avoid overflow
040858 3B          0001*M1     dec sp ; 1 cycle
040859 E5          0002*M1     push hl ; 4 cycles
04085A 33          0003*M1     inc sp ; 1 cycle
04085B E1          0004*M1     pop hl ; 4 cycles
04085C 23          0005*M1     inc hl ; 1 cycle
04085D 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
04085F             0007*M1     ; 13 cycles total
04085F E5          0415*       push hl
040860 D1          0416*       pop de
040861 CD EE 03 04 0417*       call umul24 ; hl = dx^2
040865             0418*   ; add dx^2 and dy^2
040865 D1          0419*       pop de ; de = dy^2 (was hl)
040866 19          0420*       add hl,de ; hl = dx^2 + dy^2
040867             0421*   ; compute the square root
040867 CD 65 09 04 0422*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
04086B EB          0423*       ex de,hl ; hl = distance
04086C             0424*       hlu_mul256 ; convert back to 16.8 fixed
04086C 29          0001*M1     add hl,hl ; * 2
04086D 29          0002*M1     add hl,hl ; * 4
04086E 29          0003*M1     add hl,hl ; * 8
04086F 29          0004*M1     add hl,hl ; * 16
040870 29          0005*M1     add hl,hl ; * 32
040871 29          0006*M1     add hl,hl ; * 64
040872 29          0007*M1     add hl,hl ; * 128
040873 29          0008*M1     add hl,hl ; * 256
040874 C9          0425*       ret
040875             0426*   
040875             0427*   ; compute the euclidian distance between two cartesian coordinates
040875             0428*   ; using the formula d = sqrt(dx^2+dy^2)
040875             0429*   ; inputs: dx168 and dy168 are dx and dy in 16.8 fixed format
040875             0430*   ; output; uh.l is the 16.8 fixed format distance
040875             0431*   ;         also populates scratch locations dx168 and dy168
040875             0432*   ; destroys: a,hl,bc,de
040875             0433*   ; NOTE: sm means 'small' because it doesn't round down the deltas
040875             0434*   ;       making it more accurate for small deltas,
040875             0435*   ;       but will overflow if used for screen-sized deltas
040875             0436*   distance168sm:
040875             0437*   ; compute dy^2
040875 2A 34 08 04 0438*       ld hl,(dy168)
040879 CD 06 05 04 0439*       call hlu_abs
04087D E5          0440*       push hl
04087E D1          0441*       pop de
04087F CD EE 03 04 0442*       call umul24 ; hl = dy^2
040883 E5          0443*       push hl ; save dy^2
040884             0444*   ; compute dx^2
040884 2A 2E 08 04 0445*       ld hl,(dx168)
040888 CD 06 05 04 0446*       call hlu_abs
04088C E5          0447*       push hl
04088D D1          0448*       pop de
04088E CD EE 03 04 0449*       call umul24 ; hl = dx^2
040892             0450*   ; add dx^2 and dy^2
040892 D1          0451*       pop de ; de = dy^2 (was hl)
040893 19          0452*       add hl,de ; hl = dx^2 + dy^2
040894             0453*   ; compute the square root
040894 CD 65 09 04 0454*       call sqrt24 ; de = sqrt(dx^2 + dy^2)
040898 EB          0455*       ex de,hl ; hl = distance
040899 C9          0456*       ret
04089A             0457*   
04089A             0458*   ; atan2_(ub.c,ud.e) --> uh.l
04089A             0459*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
04089A             0460*   ;   whether inputs are integers or fractional doesn't matter
04089A             0461*   ;   so long as the sign bit of the upper byte is correct
04089A             0462*   ; output: uh.l is the 16.8 fixed angle in degrees 256
04089A             0463*   ; angles are COMPASS HEADINGS based on
04089A             0464*   ; screen coordinate conventions,where the y axis is flipped
04089A             0465*   ; #E0 224      0       32 #20
04089A             0466*   ;        -x,-y | +x,-y
04089A             0467*   ; #C0 192------+------ 64 #40
04089A             0468*   ;        -x,+y | +x,+y
04089A             0469*   ; #A0 160   128 #80   96 #60
04089A             0470*   atan2_168fast:
04089A             0471*   ; get signs and make everything positive
04089A             0472*   ; get abs(x) and store its original sign
04089A C5          0473*       push bc
04089B E1          0474*       pop hl
04089C CD 06 05 04 0475*       call hlu_abs ; if x was negative this also sets the sign flag
0408A0 E5          0476*       push hl ; store abs(x)
0408A1 C1          0477*       pop bc ; bc = abs(x)
0408A2 F5          0478*       push af ; store sign of x
0408A3             0479*   ; get abs(y) and store its original sign
0408A3 EB          0480*       ex de,hl ; hl = y
0408A4 CD 06 05 04 0481*       call hlu_abs ; if y was negative this also sets the sign flag
0408A8 EB          0482*       ex de,hl ; de = abs(y)
0408A9 F5          0483*       push af ; store sign of y
0408AA             0484*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0408AA             0485*   ; this ensures that our lookup value is between 0 and 1 inclusive
0408AA AF          0486*       xor a ; clear the carry flag
0408AB D5          0487*       push de
0408AC E1          0488*       pop hl
0408AD ED 42       0489*       sbc hl,bc
0408AF F5          0490*       push af ; save sign of de - bc
0408B0 F2 B9 08 04 0491*       jp p,@1 ; bc <= de, so we skip ahead
0408B4             0492*   ; otherwise we swap bc and de
0408B4 C5          0493*       push bc
0408B5 E1          0494*       pop hl
0408B6 EB          0495*       ex de,hl
0408B7 E5          0496*       push hl
0408B8 C1          0497*       pop bc
0408B9             0498*   @1:
0408B9             0499*   ; now we're ready to snag our preliminary result
0408B9 C5          0500*       push bc
0408BA E1          0501*       pop hl
0408BB CD 29 09 04 0502*       call atan_168fast ; uh.l comes back with prelim result
0408BF             0503*   ; now we adjust uh.l based on sign of de - bc
0408BF F1          0504*       pop af
0408C0 F2 CC 08 04 0505*       jp p,@2 ; bc <= de,so we skip ahead
0408C4 EB          0506*       ex de,hl
0408C5 21 00 40 00 0507*       ld hl,64*256 ; subtract from 64 (90) degrees
0408C9 AF          0508*       xor a ; clear the carry flag
0408CA ED 52       0509*       sbc hl,de
0408CC             0510*   @2:
0408CC             0511*   ; adjust the result based on quadrant
0408CC             0512*   ; #E0 224      0       32 #20
0408CC             0513*   ;        -x,-y | +x,-y
0408CC             0514*   ; #C0 192------+------ 64 #40
0408CC             0515*   ;        -x,+y | +x,+y
0408CC             0516*   ; #A0 160   128 #80   96 #60
0408CC F1          0517*       pop af ; sign of y
0408CD CA 0A 09 04 0518*       jp z,@y_zero
0408D1 F2 EA 08 04 0519*       jp p,@y_pos
0408D5             0520*   ; y neg,check x
0408D5 F1          0521*       pop af ; sign of x
0408D6 CA E4 08 04 0522*       jp z,@y_neg_x_zero
0408DA F2 E9 08 04 0523*       jp p,@y_neg_x_pos
0408DE             0524*   ; y neg,x neg
0408DE             0525*   ; angle is 128 to 256 (270 to 360)
0408DE             0526*   ; negating the intermediate does the trick
0408DE CD 16 05 04 0527*       call neg_hlu
0408E2 18 31       0528*       jr @zero_hlu
0408E4             0529*   
0408E4             0530*   @y_neg_x_zero:
0408E4             0531*   ; y neg,x zero
0408E4             0532*   ; angle is 0
0408E4 21 00 00 00 0533*       ld hl,0
0408E8 C9          0534*       ret
0408E9             0535*   @y_neg_x_pos:
0408E9             0536*   ; y neg,x pos
0408E9             0537*   ; angle is 0 to 64 (0 to 90)
0408E9             0538*   ; so we're good
0408E9 C9          0539*       ret
0408EA             0540*   
0408EA             0541*   @y_pos:
0408EA F1          0542*       pop af ; sign of x
0408EB CA FA 08 04 0543*       jp z,@y_pos_x_zero
0408EF F2 FF 08 04 0544*       jp p,@y_pos_x_pos
0408F3             0545*   ; y pos,x neg
0408F3             0546*   ; angle is 128 to 192 (180-270)
0408F3             0547*   ; so we add 128 to intermediate
0408F3 11 00 80 00 0548*       ld de,128*256
0408F7 19          0549*       add hl,de
0408F8 18 1B       0550*       jr @zero_hlu
0408FA             0551*   @y_pos_x_zero:
0408FA             0552*   ; y pos,x zero
0408FA             0553*   ; angle is 128 (180)
0408FA 21 00 80 00 0554*       ld hl,128*256
0408FE C9          0555*       ret
0408FF             0556*   @y_pos_x_pos:
0408FF             0557*   ; y pos,x pos
0408FF             0558*   ; angle is 64 to 128 (90 to 180)
0408FF             0559*   ; neg the intermediate and add 180 degrees
0408FF CD 16 05 04 0560*       call neg_hlu
040903 11 00 80 00 0561*       ld de,128*256
040907 19          0562*       add hl,de
040908 18 0B       0563*       jr @zero_hlu
04090A             0564*   
04090A             0565*   @y_zero:
04090A F1          0566*       pop af ; sign of x
04090B FA 10 09 04 0567*       jp m,@y_zero_x_neg
04090F             0568*   ; y zero,x pos
04090F             0569*   ; angle is 64 (90),nothing to do
04090F C9          0570*       ret
040910             0571*   @y_zero_x_neg:
040910             0572*   ; y zero ,x neg
040910             0573*   ; angle is 192 (270)
040910 21 00 C0 00 0574*       ld hl,192*256
040914 C9          0575*       ret
040915             0576*   @zero_hlu:
040915 AF          0577*       xor a
040916 22 23 09 04 0578*       ld (@scratch),hl
04091A 32 25 09 04 0579*       ld (@scratch+2),a
04091E 2A 23 09 04 0580*       ld hl,(@scratch)
040922 C9          0581*       ret
040923             0582*   @scratch: ds 6
040929             0583*   
040929             0584*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040929             0585*   ; output: uh.l is the 16.8 fixed format angle in degrees 256
040929             0586*   ; destroys: a,hl,bc,de
040929             0587*   ; note: only works for angles from 0 to 32 (45) degrees
040929             0588*   ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
040929             0589*   atan_168fast:
040929             0590*   ; because we use compass headings instead of geometric angles
040929             0591*   ; we compute dx/dy which is 1/tan(theta) in the maths world
040929             0592*   ; we can do faster unsigned division here because we know dx and dy are positive
       FF FF FF FF 
       FF FF 
040929 CD E4 06 04 0593*       call udiv168 ; ud.e = dx/dy
04092D EB          0594*       ex de,hl ; uh.l = dx/dy
04092E             0595*   ; test uh.l for 0
04092E 19          0596*       add hl,de
04092F B7          0597*       or a
040930 ED 52       0598*       sbc hl,de
040932 28 22       0599*       jr z,@is_zero
040934             0600*   ; test uh.l for 1
040934 AF          0601*       xor a ; clear carry
040935 EB          0602*       ex de,hl
040936 21 00 01 00 0603*       ld hl,1*256 ; 1 in 16.8 fixed format
04093A ED 52       0604*       sbc hl,de
04093C 28 13       0605*       jr z,@is_45
04093E EB          0606*       ex de,hl
04093F             0607*   ; no special cases so we move on
04093F             0608*   ; l contains the fractional portion of tan(uh.l)
04093F             0609*   ; we multiply it by three to get our lookup table index
04093F 26 03       0610*       ld h,3
040941 ED 6C       0611*       mlt hl ; index into lut
040943 11 00 00 00 0612*       ld de,0 ; clear deu
040947 54          0613*       ld d,h ; copy hl to de
040948 5D          0614*       ld e,l ; de contains our index
040949 21 4E 0D 04 0615*       ld hl,atan_lut_168 ; grab the lut address
04094D 19          0616*       add hl,de ; bump hl by the index
04094E ED 27       0617*       ld hl,(hl) ; don't try this on a z80!
040950 C9          0618*       ret ; and out
040951             0619*   @is_45:
040951 21 00 20 00 0620*       ld hl,32*256
040955 C9          0621*       ret
040956             0622*   ; for the case tan(0)
040956             0623*   @is_zero:
040956 21 00 00 00 0624*       ld hl,0*256
04095A C9          0625*       ret
04095B             0626*   
04095B             0627*   ; Expects  ADL mode
04095B             0628*   ; Inputs:  UH.L
04095B             0629*   ; Outputs: UH.L is the 16.8 square root
04095B             0630*   ;          UDE is the integer difference inputHL-DE^2
04095B             0631*   sqrt168:
04095B CD 65 09 04 0632*       call sqrt24
04095F EB          0633*       ex de,hl
040960 29          0634*       add hl,hl
040961 29          0635*       add hl,hl
040962 29          0636*       add hl,hl
040963 29          0637*       add hl,hl
040964 C9          0638*       ret
040965             0639*   
040965             0640*   ; credit: xeda112358
040965             0641*   ; https://www.cemetech.net/forum/viewtopic.php?t=11178&postdays=0&postorder=asc&start=0
040965             0642*   sqrt24:
040965             0643*   ; Expects ADL mode
040965             0644*   ; Inputs: HL
040965             0645*   ; Outputs: DE is the integer square root
040965             0646*   ;  HL is the difference inputHL-DE^2
040965             0647*   ;  c flag reset
040965 01 00 00 00 0648*       ld bc,0 ; clear bcu
040969 11 00 00 00 0649*       ld de,0 ; clear deu
04096D AF          0650*       xor a
04096E 45          0651*       ld b,l
04096F C5          0652*       push bc
040970 47          0653*       ld b,a
040971 6F          0654*       ld l,a
040972             0655*   ; Iteration 1
040972 29          0656*       add hl,hl
040973 CB 11       0657*       rl c
040975 29          0658*       add hl,hl
040976 CB 11       0659*       rl c
040978 91          0660*       sub c
040979 30 04       0661*       jr nc,$+6
04097B 1C          0662*       inc e
04097C 1C          0663*       inc e
04097D 2F          0664*       cpl
04097E 4F          0665*       ld c,a
04097F             0666*   ; Iteration 2
04097F 29          0667*       add hl,hl
040980 CB 11       0668*       rl c
040982 29          0669*       add hl,hl
040983 CB 11       0670*       rl c
040985 CB 13       0671*       rl e
040987 7B          0672*       ld a,e
040988 91          0673*       sub c
040989 30 04       0674*       jr nc,$+6
04098B 1C          0675*       inc e
04098C 1C          0676*       inc e
04098D 2F          0677*       cpl
04098E 4F          0678*       ld c,a
04098F             0679*   ; Iteration 3
04098F 29          0680*       add hl,hl
040990 CB 11       0681*       rl c
040992 29          0682*       add hl,hl
040993 CB 11       0683*       rl c
040995 CB 13       0684*       rl e
040997 7B          0685*       ld a,e
040998 91          0686*       sub c
040999 30 04       0687*       jr nc,$+6
04099B 1C          0688*       inc e
04099C 1C          0689*       inc e
04099D 2F          0690*       cpl
04099E 4F          0691*       ld c,a
04099F             0692*   ; Iteration 4
04099F 29          0693*       add hl,hl
0409A0 CB 11       0694*       rl c
0409A2 29          0695*       add hl,hl
0409A3 CB 11       0696*       rl c
0409A5 CB 13       0697*       rl e
0409A7 7B          0698*       ld a,e
0409A8 91          0699*       sub c
0409A9 30 04       0700*       jr nc,$+6
0409AB 1C          0701*       inc e
0409AC 1C          0702*       inc e
0409AD 2F          0703*       cpl
0409AE 4F          0704*       ld c,a
0409AF             0705*   ; Iteration 5
0409AF 29          0706*       add hl,hl
0409B0 CB 11       0707*       rl c
0409B2 29          0708*       add hl,hl
0409B3 CB 11       0709*       rl c
0409B5 CB 13       0710*       rl e
0409B7 7B          0711*       ld a,e
0409B8 91          0712*       sub c
0409B9 30 04       0713*       jr nc,$+6
0409BB 1C          0714*       inc e
0409BC 1C          0715*       inc e
0409BD 2F          0716*       cpl
0409BE 4F          0717*       ld c,a
0409BF             0718*   ; Iteration 6
0409BF 29          0719*       add hl,hl
0409C0 CB 11       0720*       rl c
0409C2 29          0721*       add hl,hl
0409C3 CB 11       0722*       rl c
0409C5 CB 13       0723*       rl e
0409C7 7B          0724*       ld a,e
0409C8 91          0725*       sub c
0409C9 30 04       0726*       jr nc,$+6
0409CB 1C          0727*       inc e
0409CC 1C          0728*       inc e
0409CD 2F          0729*       cpl
0409CE 4F          0730*       ld c,a
0409CF             0731*   ; Iteration 7
0409CF 29          0732*       add hl,hl
0409D0 CB 11       0733*       rl c
0409D2 29          0734*       add hl,hl
0409D3 CB 11       0735*       rl c
0409D5 CB 10       0736*       rl b
0409D7 EB          0737*       ex de,hl
0409D8 29          0738*       add hl,hl
0409D9 E5          0739*       push hl
0409DA ED 42       0740*       sbc hl,bc
0409DC 30 06       0741*       jr nc,$+8
0409DE 7C          0742*       ld a,h
0409DF 2F          0743*       cpl
0409E0 47          0744*       ld b,a
0409E1 7D          0745*       ld a,l
0409E2 2F          0746*       cpl
0409E3 4F          0747*       ld c,a
0409E4 E1          0748*       pop hl
0409E5 30 02       0749*       jr nc,$+4
0409E7 23          0750*       inc hl
0409E8 23          0751*       inc hl
0409E9 EB          0752*       ex de,hl
0409EA             0753*   ; Iteration 8
0409EA 29          0754*       add hl,hl
0409EB 69          0755*       ld l,c
0409EC 60          0756*       ld h,b
0409ED ED 6A       0757*       adc hl,hl
0409EF ED 6A       0758*       adc hl,hl
0409F1 EB          0759*       ex de,hl
0409F2 29          0760*       add hl,hl
0409F3 ED 52       0761*       sbc hl,de
0409F5 19          0762*       add hl,de
0409F6 EB          0763*       ex de,hl
0409F7 30 04       0764*       jr nc,$+6
0409F9 ED 52       0765*       sbc hl,de
0409FB 13          0766*       inc de
0409FC 13          0767*       inc de
0409FD             0768*   ; Iteration 9
0409FD F1          0769*       pop af
0409FE 17          0770*       rla
0409FF ED 6A       0771*       adc hl,hl
040A01 17          0772*       rla
040A02 ED 6A       0773*       adc hl,hl
040A04 EB          0774*       ex de,hl
040A05 29          0775*       add hl,hl
040A06 ED 52       0776*       sbc hl,de
040A08 19          0777*       add hl,de
040A09 EB          0778*       ex de,hl
040A0A 30 04       0779*       jr nc,$+6
040A0C ED 52       0780*       sbc hl,de
040A0E 13          0781*       inc de
040A0F 13          0782*       inc de
040A10             0783*   ; Iteration 10
040A10 17          0784*       rla
040A11 ED 6A       0785*       adc hl,hl
040A13 17          0786*       rla
040A14 ED 6A       0787*       adc hl,hl
040A16 EB          0788*       ex de,hl
040A17 29          0789*       add hl,hl
040A18 ED 52       0790*       sbc hl,de
040A1A 19          0791*       add hl,de
040A1B EB          0792*       ex de,hl
040A1C 30 04       0793*       jr nc,$+6
040A1E ED 52       0794*       sbc hl,de
040A20 13          0795*       inc de
040A21 13          0796*       inc de
040A22             0797*   ; Iteration 11
040A22 17          0798*       rla
040A23 ED 6A       0799*       adc hl,hl
040A25 17          0800*       rla
040A26 ED 6A       0801*       adc hl,hl
040A28 EB          0802*       ex de,hl
040A29 29          0803*       add hl,hl
040A2A ED 52       0804*       sbc hl,de
040A2C 19          0805*       add hl,de
040A2D EB          0806*       ex de,hl
040A2E 30 04       0807*       jr nc,$+6
040A30 ED 52       0808*       sbc hl,de
040A32 13          0809*       inc de
040A33 13          0810*       inc de
040A34             0811*   ; Iteration 12
040A34 17          0812*       rla
040A35 ED 6A       0813*       adc hl,hl
040A37 17          0814*       rla
040A38 ED 6A       0815*       adc hl,hl
040A3A EB          0816*       ex de,hl
040A3B 29          0817*       add hl,hl
040A3C ED 52       0818*       sbc hl,de
040A3E 19          0819*       add hl,de
040A3F EB          0820*       ex de,hl
040A40 30 04       0821*       jr nc,$+6
040A42 ED 52       0822*       sbc hl,de
040A44 13          0823*       inc de
040A45 13          0824*       inc de
040A46 CB 1A       0825*       rr d
040A48 CB 1B       0826*       rr e
040A4A C9          0827*       ret
040A4B             0828*   
040A4B             0829*   sin_lut_168:
040A4B 00 00 00    0830*       dl 0x000000 ; 0.000 00, 0.000
040A4E 06 00 00    0831*       dl 0x000006 ; 1.406 01, 0.025
040A51 0C 00 00    0832*       dl 0x00000C ; 2.813 02, 0.049
040A54 12 00 00    0833*       dl 0x000012 ; 4.219 03, 0.074
040A57 19 00 00    0834*       dl 0x000019 ; 5.625 04, 0.098
040A5A 1F 00 00    0835*       dl 0x00001F ; 7.031 05, 0.122
040A5D 25 00 00    0836*       dl 0x000025 ; 8.438 06, 0.147
040A60 2B 00 00    0837*       dl 0x00002B ; 9.844 07, 0.171
040A63 31 00 00    0838*       dl 0x000031 ; 11.250 08, 0.195
040A66 38 00 00    0839*       dl 0x000038 ; 12.656 09, 0.219
040A69 3E 00 00    0840*       dl 0x00003E ; 14.063 0A, 0.243
040A6C 44 00 00    0841*       dl 0x000044 ; 15.469 0B, 0.267
040A6F 4A 00 00    0842*       dl 0x00004A ; 16.875 0C, 0.290
040A72 50 00 00    0843*       dl 0x000050 ; 18.281 0D, 0.314
040A75 56 00 00    0844*       dl 0x000056 ; 19.688 0E, 0.337
040A78 5C 00 00    0845*       dl 0x00005C ; 21.094 0F, 0.360
040A7B 61 00 00    0846*       dl 0x000061 ; 22.500 10, 0.383
040A7E 67 00 00    0847*       dl 0x000067 ; 23.906 11, 0.405
040A81 6D 00 00    0848*       dl 0x00006D ; 25.313 12, 0.428
040A84 73 00 00    0849*       dl 0x000073 ; 26.719 13, 0.450
040A87 78 00 00    0850*       dl 0x000078 ; 28.125 14, 0.471
040A8A 7E 00 00    0851*       dl 0x00007E ; 29.531 15, 0.493
040A8D 83 00 00    0852*       dl 0x000083 ; 30.938 16, 0.514
040A90 88 00 00    0853*       dl 0x000088 ; 32.344 17, 0.535
040A93 8E 00 00    0854*       dl 0x00008E ; 33.750 18, 0.556
040A96 93 00 00    0855*       dl 0x000093 ; 35.156 19, 0.576
040A99 98 00 00    0856*       dl 0x000098 ; 36.563 1A, 0.596
040A9C 9D 00 00    0857*       dl 0x00009D ; 37.969 1B, 0.615
040A9F A2 00 00    0858*       dl 0x0000A2 ; 39.375 1C, 0.634
040AA2 A7 00 00    0859*       dl 0x0000A7 ; 40.781 1D, 0.653
040AA5 AB 00 00    0860*       dl 0x0000AB ; 42.188 1E, 0.672
040AA8 B0 00 00    0861*       dl 0x0000B0 ; 43.594 1F, 0.690
040AAB B5 00 00    0862*       dl 0x0000B5 ; 45.000 20, 0.707
040AAE B9 00 00    0863*       dl 0x0000B9 ; 46.406 21, 0.724
040AB1 BD 00 00    0864*       dl 0x0000BD ; 47.813 22, 0.741
040AB4 C1 00 00    0865*       dl 0x0000C1 ; 49.219 23, 0.757
040AB7 C5 00 00    0866*       dl 0x0000C5 ; 50.625 24, 0.773
040ABA C9 00 00    0867*       dl 0x0000C9 ; 52.031 25, 0.788
040ABD CD 00 00    0868*       dl 0x0000CD ; 53.438 26, 0.803
040AC0 D1 00 00    0869*       dl 0x0000D1 ; 54.844 27, 0.818
040AC3 D4 00 00    0870*       dl 0x0000D4 ; 56.250 28, 0.831
040AC6 D8 00 00    0871*       dl 0x0000D8 ; 57.656 29, 0.845
040AC9 DB 00 00    0872*       dl 0x0000DB ; 59.063 2A, 0.858
040ACC DE 00 00    0873*       dl 0x0000DE ; 60.469 2B, 0.870
040ACF E1 00 00    0874*       dl 0x0000E1 ; 61.875 2C, 0.882
040AD2 E4 00 00    0875*       dl 0x0000E4 ; 63.281 2D, 0.893
040AD5 E7 00 00    0876*       dl 0x0000E7 ; 64.688 2E, 0.904
040AD8 EA 00 00    0877*       dl 0x0000EA ; 66.094 2F, 0.914
040ADB EC 00 00    0878*       dl 0x0000EC ; 67.500 30, 0.924
040ADE EE 00 00    0879*       dl 0x0000EE ; 68.906 31, 0.933
040AE1 F1 00 00    0880*       dl 0x0000F1 ; 70.313 32, 0.942
040AE4 F3 00 00    0881*       dl 0x0000F3 ; 71.719 33, 0.950
040AE7 F4 00 00    0882*       dl 0x0000F4 ; 73.125 34, 0.957
040AEA F6 00 00    0883*       dl 0x0000F6 ; 74.531 35, 0.964
040AED F8 00 00    0884*       dl 0x0000F8 ; 75.938 36, 0.970
040AF0 F9 00 00    0885*       dl 0x0000F9 ; 77.344 37, 0.976
040AF3 FB 00 00    0886*       dl 0x0000FB ; 78.750 38, 0.981
040AF6 FC 00 00    0887*       dl 0x0000FC ; 80.156 39, 0.985
040AF9 FD 00 00    0888*       dl 0x0000FD ; 81.563 3A, 0.989
040AFC FE 00 00    0889*       dl 0x0000FE ; 82.969 3B, 0.992
040AFF FE 00 00    0890*       dl 0x0000FE ; 84.375 3C, 0.995
040B02 FF 00 00    0891*       dl 0x0000FF ; 85.781 3D, 0.997
040B05 FF 00 00    0892*       dl 0x0000FF ; 87.188 3E, 0.999
040B08 FF 00 00    0893*       dl 0x0000FF ; 88.594 3F, 1.000
040B0B 00 01 00    0894*       dl 0x000100 ; 90.000 40, 1.000
040B0E FF 00 00    0895*       dl 0x0000FF ; 91.406 41, 1.000
040B11 FF 00 00    0896*       dl 0x0000FF ; 92.813 42, 0.999
040B14 FF 00 00    0897*       dl 0x0000FF ; 94.219 43, 0.997
040B17 FE 00 00    0898*       dl 0x0000FE ; 95.625 44, 0.995
040B1A FE 00 00    0899*       dl 0x0000FE ; 97.031 45, 0.992
040B1D FD 00 00    0900*       dl 0x0000FD ; 98.438 46, 0.989
040B20 FC 00 00    0901*       dl 0x0000FC ; 99.844 47, 0.985
040B23 FB 00 00    0902*       dl 0x0000FB ; 101.250 48, 0.981
040B26 F9 00 00    0903*       dl 0x0000F9 ; 102.656 49, 0.976
040B29 F8 00 00    0904*       dl 0x0000F8 ; 104.063 4A, 0.970
040B2C F6 00 00    0905*       dl 0x0000F6 ; 105.469 4B, 0.964
040B2F F4 00 00    0906*       dl 0x0000F4 ; 106.875 4C, 0.957
040B32 F3 00 00    0907*       dl 0x0000F3 ; 108.281 4D, 0.950
040B35 F1 00 00    0908*       dl 0x0000F1 ; 109.688 4E, 0.942
040B38 EE 00 00    0909*       dl 0x0000EE ; 111.094 4F, 0.933
040B3B EC 00 00    0910*       dl 0x0000EC ; 112.500 50, 0.924
040B3E EA 00 00    0911*       dl 0x0000EA ; 113.906 51, 0.914
040B41 E7 00 00    0912*       dl 0x0000E7 ; 115.313 52, 0.904
040B44 E4 00 00    0913*       dl 0x0000E4 ; 116.719 53, 0.893
040B47 E1 00 00    0914*       dl 0x0000E1 ; 118.125 54, 0.882
040B4A DE 00 00    0915*       dl 0x0000DE ; 119.531 55, 0.870
040B4D DB 00 00    0916*       dl 0x0000DB ; 120.938 56, 0.858
040B50 D8 00 00    0917*       dl 0x0000D8 ; 122.344 57, 0.845
040B53 D4 00 00    0918*       dl 0x0000D4 ; 123.750 58, 0.831
040B56 D1 00 00    0919*       dl 0x0000D1 ; 125.156 59, 0.818
040B59 CD 00 00    0920*       dl 0x0000CD ; 126.563 5A, 0.803
040B5C C9 00 00    0921*       dl 0x0000C9 ; 127.969 5B, 0.788
040B5F C5 00 00    0922*       dl 0x0000C5 ; 129.375 5C, 0.773
040B62 C1 00 00    0923*       dl 0x0000C1 ; 130.781 5D, 0.757
040B65 BD 00 00    0924*       dl 0x0000BD ; 132.188 5E, 0.741
040B68 B9 00 00    0925*       dl 0x0000B9 ; 133.594 5F, 0.724
040B6B B5 00 00    0926*       dl 0x0000B5 ; 135.000 60, 0.707
040B6E B0 00 00    0927*       dl 0x0000B0 ; 136.406 61, 0.690
040B71 AB 00 00    0928*       dl 0x0000AB ; 137.813 62, 0.672
040B74 A7 00 00    0929*       dl 0x0000A7 ; 139.219 63, 0.653
040B77 A2 00 00    0930*       dl 0x0000A2 ; 140.625 64, 0.634
040B7A 9D 00 00    0931*       dl 0x00009D ; 142.031 65, 0.615
040B7D 98 00 00    0932*       dl 0x000098 ; 143.438 66, 0.596
040B80 93 00 00    0933*       dl 0x000093 ; 144.844 67, 0.576
040B83 8E 00 00    0934*       dl 0x00008E ; 146.250 68, 0.556
040B86 88 00 00    0935*       dl 0x000088 ; 147.656 69, 0.535
040B89 83 00 00    0936*       dl 0x000083 ; 149.063 6A, 0.514
040B8C 7E 00 00    0937*       dl 0x00007E ; 150.469 6B, 0.493
040B8F 78 00 00    0938*       dl 0x000078 ; 151.875 6C, 0.471
040B92 73 00 00    0939*       dl 0x000073 ; 153.281 6D, 0.450
040B95 6D 00 00    0940*       dl 0x00006D ; 154.688 6E, 0.428
040B98 67 00 00    0941*       dl 0x000067 ; 156.094 6F, 0.405
040B9B 61 00 00    0942*       dl 0x000061 ; 157.500 70, 0.383
040B9E 5C 00 00    0943*       dl 0x00005C ; 158.906 71, 0.360
040BA1 56 00 00    0944*       dl 0x000056 ; 160.313 72, 0.337
040BA4 50 00 00    0945*       dl 0x000050 ; 161.719 73, 0.314
040BA7 4A 00 00    0946*       dl 0x00004A ; 163.125 74, 0.290
040BAA 44 00 00    0947*       dl 0x000044 ; 164.531 75, 0.267
040BAD 3E 00 00    0948*       dl 0x00003E ; 165.938 76, 0.243
040BB0 38 00 00    0949*       dl 0x000038 ; 167.344 77, 0.219
040BB3 31 00 00    0950*       dl 0x000031 ; 168.750 78, 0.195
040BB6 2B 00 00    0951*       dl 0x00002B ; 170.156 79, 0.171
040BB9 25 00 00    0952*       dl 0x000025 ; 171.563 7A, 0.147
040BBC 1F 00 00    0953*       dl 0x00001F ; 172.969 7B, 0.122
040BBF 19 00 00    0954*       dl 0x000019 ; 174.375 7C, 0.098
040BC2 12 00 00    0955*       dl 0x000012 ; 175.781 7D, 0.074
040BC5 0C 00 00    0956*       dl 0x00000C ; 177.188 7E, 0.049
040BC8 06 00 00    0957*       dl 0x000006 ; 178.594 7F, 0.025
040BCB 00 00 00    0958*       dl 0x000000 ; 180.000 80, 0.000
040BCE FA FF FF    0959*       dl 0xFFFFFA ; 181.406 81, -0.025
040BD1 F4 FF FF    0960*       dl 0xFFFFF4 ; 182.813 82, -0.049
040BD4 EE FF FF    0961*       dl 0xFFFFEE ; 184.219 83, -0.074
040BD7 E7 FF FF    0962*       dl 0xFFFFE7 ; 185.625 84, -0.098
040BDA E1 FF FF    0963*       dl 0xFFFFE1 ; 187.031 85, -0.122
040BDD DB FF FF    0964*       dl 0xFFFFDB ; 188.438 86, -0.147
040BE0 D5 FF FF    0965*       dl 0xFFFFD5 ; 189.844 87, -0.171
040BE3 CF FF FF    0966*       dl 0xFFFFCF ; 191.250 88, -0.195
040BE6 C8 FF FF    0967*       dl 0xFFFFC8 ; 192.656 89, -0.219
040BE9 C2 FF FF    0968*       dl 0xFFFFC2 ; 194.063 8A, -0.243
040BEC BC FF FF    0969*       dl 0xFFFFBC ; 195.469 8B, -0.267
040BEF B6 FF FF    0970*       dl 0xFFFFB6 ; 196.875 8C, -0.290
040BF2 B0 FF FF    0971*       dl 0xFFFFB0 ; 198.281 8D, -0.314
040BF5 AA FF FF    0972*       dl 0xFFFFAA ; 199.688 8E, -0.337
040BF8 A4 FF FF    0973*       dl 0xFFFFA4 ; 201.094 8F, -0.360
040BFB 9F FF FF    0974*       dl 0xFFFF9F ; 202.500 90, -0.383
040BFE 99 FF FF    0975*       dl 0xFFFF99 ; 203.906 91, -0.405
040C01 93 FF FF    0976*       dl 0xFFFF93 ; 205.313 92, -0.428
040C04 8D FF FF    0977*       dl 0xFFFF8D ; 206.719 93, -0.450
040C07 88 FF FF    0978*       dl 0xFFFF88 ; 208.125 94, -0.471
040C0A 82 FF FF    0979*       dl 0xFFFF82 ; 209.531 95, -0.493
040C0D 7D FF FF    0980*       dl 0xFFFF7D ; 210.938 96, -0.514
040C10 78 FF FF    0981*       dl 0xFFFF78 ; 212.344 97, -0.535
040C13 72 FF FF    0982*       dl 0xFFFF72 ; 213.750 98, -0.556
040C16 6D FF FF    0983*       dl 0xFFFF6D ; 215.156 99, -0.576
040C19 68 FF FF    0984*       dl 0xFFFF68 ; 216.563 9A, -0.596
040C1C 63 FF FF    0985*       dl 0xFFFF63 ; 217.969 9B, -0.615
040C1F 5E FF FF    0986*       dl 0xFFFF5E ; 219.375 9C, -0.634
040C22 59 FF FF    0987*       dl 0xFFFF59 ; 220.781 9D, -0.653
040C25 55 FF FF    0988*       dl 0xFFFF55 ; 222.188 9E, -0.672
040C28 50 FF FF    0989*       dl 0xFFFF50 ; 223.594 9F, -0.690
040C2B 4B FF FF    0990*       dl 0xFFFF4B ; 225.000 A0, -0.707
040C2E 47 FF FF    0991*       dl 0xFFFF47 ; 226.406 A1, -0.724
040C31 43 FF FF    0992*       dl 0xFFFF43 ; 227.813 A2, -0.741
040C34 3F FF FF    0993*       dl 0xFFFF3F ; 229.219 A3, -0.757
040C37 3B FF FF    0994*       dl 0xFFFF3B ; 230.625 A4, -0.773
040C3A 37 FF FF    0995*       dl 0xFFFF37 ; 232.031 A5, -0.788
040C3D 33 FF FF    0996*       dl 0xFFFF33 ; 233.438 A6, -0.803
040C40 2F FF FF    0997*       dl 0xFFFF2F ; 234.844 A7, -0.818
040C43 2C FF FF    0998*       dl 0xFFFF2C ; 236.250 A8, -0.831
040C46 28 FF FF    0999*       dl 0xFFFF28 ; 237.656 A9, -0.845
040C49 25 FF FF    1000*       dl 0xFFFF25 ; 239.063 AA, -0.858
040C4C 22 FF FF    1001*       dl 0xFFFF22 ; 240.469 AB, -0.870
040C4F 1F FF FF    1002*       dl 0xFFFF1F ; 241.875 AC, -0.882
040C52 1C FF FF    1003*       dl 0xFFFF1C ; 243.281 AD, -0.893
040C55 19 FF FF    1004*       dl 0xFFFF19 ; 244.688 AE, -0.904
040C58 16 FF FF    1005*       dl 0xFFFF16 ; 246.094 AF, -0.914
040C5B 14 FF FF    1006*       dl 0xFFFF14 ; 247.500 B0, -0.924
040C5E 12 FF FF    1007*       dl 0xFFFF12 ; 248.906 B1, -0.933
040C61 0F FF FF    1008*       dl 0xFFFF0F ; 250.313 B2, -0.942
040C64 0D FF FF    1009*       dl 0xFFFF0D ; 251.719 B3, -0.950
040C67 0C FF FF    1010*       dl 0xFFFF0C ; 253.125 B4, -0.957
040C6A 0A FF FF    1011*       dl 0xFFFF0A ; 254.531 B5, -0.964
040C6D 08 FF FF    1012*       dl 0xFFFF08 ; 255.938 B6, -0.970
040C70 07 FF FF    1013*       dl 0xFFFF07 ; 257.344 B7, -0.976
040C73 05 FF FF    1014*       dl 0xFFFF05 ; 258.750 B8, -0.981
040C76 04 FF FF    1015*       dl 0xFFFF04 ; 260.156 B9, -0.985
040C79 03 FF FF    1016*       dl 0xFFFF03 ; 261.563 BA, -0.989
040C7C 02 FF FF    1017*       dl 0xFFFF02 ; 262.969 BB, -0.992
040C7F 02 FF FF    1018*       dl 0xFFFF02 ; 264.375 BC, -0.995
040C82 01 FF FF    1019*       dl 0xFFFF01 ; 265.781 BD, -0.997
040C85 01 FF FF    1020*       dl 0xFFFF01 ; 267.188 BE, -0.999
040C88 01 FF FF    1021*       dl 0xFFFF01 ; 268.594 BF, -1.000
040C8B 00 FF FF    1022*       dl 0xFFFF00 ; 270.000 C0, -1.000
040C8E 01 FF FF    1023*       dl 0xFFFF01 ; 271.406 C1, -1.000
040C91 01 FF FF    1024*       dl 0xFFFF01 ; 272.813 C2, -0.999
040C94 01 FF FF    1025*       dl 0xFFFF01 ; 274.219 C3, -0.997
040C97 02 FF FF    1026*       dl 0xFFFF02 ; 275.625 C4, -0.995
040C9A 02 FF FF    1027*       dl 0xFFFF02 ; 277.031 C5, -0.992
040C9D 03 FF FF    1028*       dl 0xFFFF03 ; 278.438 C6, -0.989
040CA0 04 FF FF    1029*       dl 0xFFFF04 ; 279.844 C7, -0.985
040CA3 05 FF FF    1030*       dl 0xFFFF05 ; 281.250 C8, -0.981
040CA6 07 FF FF    1031*       dl 0xFFFF07 ; 282.656 C9, -0.976
040CA9 08 FF FF    1032*       dl 0xFFFF08 ; 284.063 CA, -0.970
040CAC 0A FF FF    1033*       dl 0xFFFF0A ; 285.469 CB, -0.964
040CAF 0C FF FF    1034*       dl 0xFFFF0C ; 286.875 CC, -0.957
040CB2 0D FF FF    1035*       dl 0xFFFF0D ; 288.281 CD, -0.950
040CB5 0F FF FF    1036*       dl 0xFFFF0F ; 289.688 CE, -0.942
040CB8 12 FF FF    1037*       dl 0xFFFF12 ; 291.094 CF, -0.933
040CBB 14 FF FF    1038*       dl 0xFFFF14 ; 292.500 D0, -0.924
040CBE 16 FF FF    1039*       dl 0xFFFF16 ; 293.906 D1, -0.914
040CC1 19 FF FF    1040*       dl 0xFFFF19 ; 295.313 D2, -0.904
040CC4 1C FF FF    1041*       dl 0xFFFF1C ; 296.719 D3, -0.893
040CC7 1F FF FF    1042*       dl 0xFFFF1F ; 298.125 D4, -0.882
040CCA 22 FF FF    1043*       dl 0xFFFF22 ; 299.531 D5, -0.870
040CCD 25 FF FF    1044*       dl 0xFFFF25 ; 300.938 D6, -0.858
040CD0 28 FF FF    1045*       dl 0xFFFF28 ; 302.344 D7, -0.845
040CD3 2C FF FF    1046*       dl 0xFFFF2C ; 303.750 D8, -0.831
040CD6 2F FF FF    1047*       dl 0xFFFF2F ; 305.156 D9, -0.818
040CD9 33 FF FF    1048*       dl 0xFFFF33 ; 306.563 DA, -0.803
040CDC 37 FF FF    1049*       dl 0xFFFF37 ; 307.969 DB, -0.788
040CDF 3B FF FF    1050*       dl 0xFFFF3B ; 309.375 DC, -0.773
040CE2 3F FF FF    1051*       dl 0xFFFF3F ; 310.781 DD, -0.757
040CE5 43 FF FF    1052*       dl 0xFFFF43 ; 312.188 DE, -0.741
040CE8 47 FF FF    1053*       dl 0xFFFF47 ; 313.594 DF, -0.724
040CEB 4B FF FF    1054*       dl 0xFFFF4B ; 315.000 E0, -0.707
040CEE 50 FF FF    1055*       dl 0xFFFF50 ; 316.406 E1, -0.690
040CF1 55 FF FF    1056*       dl 0xFFFF55 ; 317.813 E2, -0.672
040CF4 59 FF FF    1057*       dl 0xFFFF59 ; 319.219 E3, -0.653
040CF7 5E FF FF    1058*       dl 0xFFFF5E ; 320.625 E4, -0.634
040CFA 63 FF FF    1059*       dl 0xFFFF63 ; 322.031 E5, -0.615
040CFD 68 FF FF    1060*       dl 0xFFFF68 ; 323.438 E6, -0.596
040D00 6D FF FF    1061*       dl 0xFFFF6D ; 324.844 E7, -0.576
040D03 72 FF FF    1062*       dl 0xFFFF72 ; 326.250 E8, -0.556
040D06 78 FF FF    1063*       dl 0xFFFF78 ; 327.656 E9, -0.535
040D09 7D FF FF    1064*       dl 0xFFFF7D ; 329.063 EA, -0.514
040D0C 82 FF FF    1065*       dl 0xFFFF82 ; 330.469 EB, -0.493
040D0F 88 FF FF    1066*       dl 0xFFFF88 ; 331.875 EC, -0.471
040D12 8D FF FF    1067*       dl 0xFFFF8D ; 333.281 ED, -0.450
040D15 93 FF FF    1068*       dl 0xFFFF93 ; 334.688 EE, -0.428
040D18 99 FF FF    1069*       dl 0xFFFF99 ; 336.094 EF, -0.405
040D1B 9F FF FF    1070*       dl 0xFFFF9F ; 337.500 F0, -0.383
040D1E A4 FF FF    1071*       dl 0xFFFFA4 ; 338.906 F1, -0.360
040D21 AA FF FF    1072*       dl 0xFFFFAA ; 340.313 F2, -0.337
040D24 B0 FF FF    1073*       dl 0xFFFFB0 ; 341.719 F3, -0.314
040D27 B6 FF FF    1074*       dl 0xFFFFB6 ; 343.125 F4, -0.290
040D2A BC FF FF    1075*       dl 0xFFFFBC ; 344.531 F5, -0.267
040D2D C2 FF FF    1076*       dl 0xFFFFC2 ; 345.938 F6, -0.243
040D30 C8 FF FF    1077*       dl 0xFFFFC8 ; 347.344 F7, -0.219
040D33 CF FF FF    1078*       dl 0xFFFFCF ; 348.750 F8, -0.195
040D36 D5 FF FF    1079*       dl 0xFFFFD5 ; 350.156 F9, -0.171
040D39 DB FF FF    1080*       dl 0xFFFFDB ; 351.563 FA, -0.147
040D3C E1 FF FF    1081*       dl 0xFFFFE1 ; 352.969 FB, -0.122
040D3F E7 FF FF    1082*       dl 0xFFFFE7 ; 354.375 FC, -0.098
040D42 EE FF FF    1083*       dl 0xFFFFEE ; 355.781 FD, -0.074
040D45 F4 FF FF    1084*       dl 0xFFFFF4 ; 357.188 FE, -0.049
040D48 FA FF FF    1085*       dl 0xFFFFFA ; 358.594 FF, -0.025
040D4B 00 00 00    1086*       dl 0x000000 ; 0.000 00, 0.000 for interpolation
040D4E             1087*   
040D4E             1088*   atan_lut_168:
040D4E 00 00 00    1089*       dl 0x000000 ; 000000, 0.000
040D51 28 00 00    1090*       dl 0x000028 ; 000001, 0.224
040D54 51 00 00    1091*       dl 0x000051 ; 000002, 0.448
040D57 7A 00 00    1092*       dl 0x00007A ; 000003, 0.671
040D5A A2 00 00    1093*       dl 0x0000A2 ; 000004, 0.895
040D5D CB 00 00    1094*       dl 0x0000CB ; 000005, 1.119
040D60 F4 00 00    1095*       dl 0x0000F4 ; 000006, 1.343
040D63 1D 01 00    1096*       dl 0x00011D ; 000007, 1.566
040D66 45 01 00    1097*       dl 0x000145 ; 000008, 1.790
040D69 6E 01 00    1098*       dl 0x00016E ; 000009, 2.013
040D6C 97 01 00    1099*       dl 0x000197 ; 00000A, 2.237
040D6F BF 01 00    1100*       dl 0x0001BF ; 00000B, 2.460
040D72 E8 01 00    1101*       dl 0x0001E8 ; 00000C, 2.684
040D75 11 02 00    1102*       dl 0x000211 ; 00000D, 2.907
040D78 39 02 00    1103*       dl 0x000239 ; 00000E, 3.130
040D7B 62 02 00    1104*       dl 0x000262 ; 00000F, 3.353
040D7E 8B 02 00    1105*       dl 0x00028B ; 000010, 3.576
040D81 B3 02 00    1106*       dl 0x0002B3 ; 000011, 3.799
040D84 DC 02 00    1107*       dl 0x0002DC ; 000012, 4.022
040D87 04 03 00    1108*       dl 0x000304 ; 000013, 4.245
040D8A 2D 03 00    1109*       dl 0x00032D ; 000014, 4.467
040D8D 55 03 00    1110*       dl 0x000355 ; 000015, 4.690
040D90 7E 03 00    1111*       dl 0x00037E ; 000016, 4.912
040D93 A6 03 00    1112*       dl 0x0003A6 ; 000017, 5.134
040D96 CE 03 00    1113*       dl 0x0003CE ; 000018, 5.356
040D99 F7 03 00    1114*       dl 0x0003F7 ; 000019, 5.578
040D9C 1F 04 00    1115*       dl 0x00041F ; 00001A, 5.799
040D9F 48 04 00    1116*       dl 0x000448 ; 00001B, 6.021
040DA2 70 04 00    1117*       dl 0x000470 ; 00001C, 6.242
040DA5 98 04 00    1118*       dl 0x000498 ; 00001D, 6.463
040DA8 C0 04 00    1119*       dl 0x0004C0 ; 00001E, 6.684
040DAB E8 04 00    1120*       dl 0x0004E8 ; 00001F, 6.905
040DAE 11 05 00    1121*       dl 0x000511 ; 000020, 7.125
040DB1 39 05 00    1122*       dl 0x000539 ; 000021, 7.345
040DB4 61 05 00    1123*       dl 0x000561 ; 000022, 7.565
040DB7 89 05 00    1124*       dl 0x000589 ; 000023, 7.785
040DBA B1 05 00    1125*       dl 0x0005B1 ; 000024, 8.005
040DBD D9 05 00    1126*       dl 0x0005D9 ; 000025, 8.224
040DC0 01 06 00    1127*       dl 0x000601 ; 000026, 8.443
040DC3 28 06 00    1128*       dl 0x000628 ; 000027, 8.662
040DC6 50 06 00    1129*       dl 0x000650 ; 000028, 8.881
040DC9 78 06 00    1130*       dl 0x000678 ; 000029, 9.099
040DCC A0 06 00    1131*       dl 0x0006A0 ; 00002A, 9.317
040DCF C7 06 00    1132*       dl 0x0006C7 ; 00002B, 9.535
040DD2 EF 06 00    1133*       dl 0x0006EF ; 00002C, 9.752
040DD5 16 07 00    1134*       dl 0x000716 ; 00002D, 9.970
040DD8 3E 07 00    1135*       dl 0x00073E ; 00002E, 10.187
040DDB 65 07 00    1136*       dl 0x000765 ; 00002F, 10.403
040DDE 8D 07 00    1137*       dl 0x00078D ; 000030, 10.620
040DE1 B4 07 00    1138*       dl 0x0007B4 ; 000031, 10.836
040DE4 DB 07 00    1139*       dl 0x0007DB ; 000032, 11.051
040DE7 03 08 00    1140*       dl 0x000803 ; 000033, 11.267
040DEA 2A 08 00    1141*       dl 0x00082A ; 000034, 11.482
040DED 51 08 00    1142*       dl 0x000851 ; 000035, 11.697
040DF0 78 08 00    1143*       dl 0x000878 ; 000036, 11.911
040DF3 9F 08 00    1144*       dl 0x00089F ; 000037, 12.125
040DF6 C6 08 00    1145*       dl 0x0008C6 ; 000038, 12.339
040DF9 ED 08 00    1146*       dl 0x0008ED ; 000039, 12.553
040DFC 13 09 00    1147*       dl 0x000913 ; 00003A, 12.766
040DFF 3A 09 00    1148*       dl 0x00093A ; 00003B, 12.978
040E02 61 09 00    1149*       dl 0x000961 ; 00003C, 13.191
040E05 87 09 00    1150*       dl 0x000987 ; 00003D, 13.403
040E08 AE 09 00    1151*       dl 0x0009AE ; 00003E, 13.614
040E0B D4 09 00    1152*       dl 0x0009D4 ; 00003F, 13.825
040E0E FB 09 00    1153*       dl 0x0009FB ; 000040, 14.036
040E11 21 0A 00    1154*       dl 0x000A21 ; 000041, 14.247
040E14 47 0A 00    1155*       dl 0x000A47 ; 000042, 14.457
040E17 6D 0A 00    1156*       dl 0x000A6D ; 000043, 14.666
040E1A 94 0A 00    1157*       dl 0x000A94 ; 000044, 14.876
040E1D BA 0A 00    1158*       dl 0x000ABA ; 000045, 15.085
040E20 E0 0A 00    1159*       dl 0x000AE0 ; 000046, 15.293
040E23 05 0B 00    1160*       dl 0x000B05 ; 000047, 15.501
040E26 2B 0B 00    1161*       dl 0x000B2B ; 000048, 15.709
040E29 51 0B 00    1162*       dl 0x000B51 ; 000049, 15.916
040E2C 77 0B 00    1163*       dl 0x000B77 ; 00004A, 16.123
040E2F 9C 0B 00    1164*       dl 0x000B9C ; 00004B, 16.329
040E32 C2 0B 00    1165*       dl 0x000BC2 ; 00004C, 16.535
040E35 E7 0B 00    1166*       dl 0x000BE7 ; 00004D, 16.740
040E38 0C 0C 00    1167*       dl 0x000C0C ; 00004E, 16.945
040E3B 32 0C 00    1168*       dl 0x000C32 ; 00004F, 17.150
040E3E 57 0C 00    1169*       dl 0x000C57 ; 000050, 17.354
040E41 7C 0C 00    1170*       dl 0x000C7C ; 000051, 17.558
040E44 A1 0C 00    1171*       dl 0x000CA1 ; 000052, 17.761
040E47 C6 0C 00    1172*       dl 0x000CC6 ; 000053, 17.964
040E4A EB 0C 00    1173*       dl 0x000CEB ; 000054, 18.166
040E4D 0F 0D 00    1174*       dl 0x000D0F ; 000055, 18.368
040E50 34 0D 00    1175*       dl 0x000D34 ; 000056, 18.569
040E53 58 0D 00    1176*       dl 0x000D58 ; 000057, 18.770
040E56 7D 0D 00    1177*       dl 0x000D7D ; 000058, 18.970
040E59 A1 0D 00    1178*       dl 0x000DA1 ; 000059, 19.170
040E5C C6 0D 00    1179*       dl 0x000DC6 ; 00005A, 19.370
040E5F EA 0D 00    1180*       dl 0x000DEA ; 00005B, 19.569
040E62 0E 0E 00    1181*       dl 0x000E0E ; 00005C, 19.767
040E65 32 0E 00    1182*       dl 0x000E32 ; 00005D, 19.965
040E68 56 0E 00    1183*       dl 0x000E56 ; 00005E, 20.163
040E6B 7A 0E 00    1184*       dl 0x000E7A ; 00005F, 20.360
040E6E 9E 0E 00    1185*       dl 0x000E9E ; 000060, 20.556
040E71 C1 0E 00    1186*       dl 0x000EC1 ; 000061, 20.752
040E74 E5 0E 00    1187*       dl 0x000EE5 ; 000062, 20.947
040E77 08 0F 00    1188*       dl 0x000F08 ; 000063, 21.142
040E7A 2C 0F 00    1189*       dl 0x000F2C ; 000064, 21.337
040E7D 4F 0F 00    1190*       dl 0x000F4F ; 000065, 21.531
040E80 72 0F 00    1191*       dl 0x000F72 ; 000066, 21.724
040E83 95 0F 00    1192*       dl 0x000F95 ; 000067, 21.917
040E86 B8 0F 00    1193*       dl 0x000FB8 ; 000068, 22.109
040E89 DB 0F 00    1194*       dl 0x000FDB ; 000069, 22.301
040E8C FE 0F 00    1195*       dl 0x000FFE ; 00006A, 22.493
040E8F 21 10 00    1196*       dl 0x001021 ; 00006B, 22.683
040E92 44 10 00    1197*       dl 0x001044 ; 00006C, 22.874
040E95 66 10 00    1198*       dl 0x001066 ; 00006D, 23.063
040E98 89 10 00    1199*       dl 0x001089 ; 00006E, 23.253
040E9B AB 10 00    1200*       dl 0x0010AB ; 00006F, 23.441
040E9E CD 10 00    1201*       dl 0x0010CD ; 000070, 23.629
040EA1 EF 10 00    1202*       dl 0x0010EF ; 000071, 23.817
040EA4 11 11 00    1203*       dl 0x001111 ; 000072, 24.004
040EA7 33 11 00    1204*       dl 0x001133 ; 000073, 24.191
040EAA 55 11 00    1205*       dl 0x001155 ; 000074, 24.376
040EAD 77 11 00    1206*       dl 0x001177 ; 000075, 24.562
040EB0 99 11 00    1207*       dl 0x001199 ; 000076, 24.747
040EB3 BA 11 00    1208*       dl 0x0011BA ; 000077, 24.931
040EB6 DC 11 00    1209*       dl 0x0011DC ; 000078, 25.115
040EB9 FD 11 00    1210*       dl 0x0011FD ; 000079, 25.298
040EBC 1E 12 00    1211*       dl 0x00121E ; 00007A, 25.481
040EBF 3F 12 00    1212*       dl 0x00123F ; 00007B, 25.663
040EC2 60 12 00    1213*       dl 0x001260 ; 00007C, 25.844
040EC5 81 12 00    1214*       dl 0x001281 ; 00007D, 26.025
040EC8 A2 12 00    1215*       dl 0x0012A2 ; 00007E, 26.206
040ECB C3 12 00    1216*       dl 0x0012C3 ; 00007F, 26.386
040ECE E4 12 00    1217*       dl 0x0012E4 ; 000080, 26.565
040ED1 04 13 00    1218*       dl 0x001304 ; 000081, 26.744
040ED4 25 13 00    1219*       dl 0x001325 ; 000082, 26.922
040ED7 45 13 00    1220*       dl 0x001345 ; 000083, 27.100
040EDA 65 13 00    1221*       dl 0x001365 ; 000084, 27.277
040EDD 85 13 00    1222*       dl 0x001385 ; 000085, 27.453
040EE0 A5 13 00    1223*       dl 0x0013A5 ; 000086, 27.629
040EE3 C5 13 00    1224*       dl 0x0013C5 ; 000087, 27.805
040EE6 E5 13 00    1225*       dl 0x0013E5 ; 000088, 27.979
040EE9 05 14 00    1226*       dl 0x001405 ; 000089, 28.154
040EEC 24 14 00    1227*       dl 0x001424 ; 00008A, 28.327
040EEF 44 14 00    1228*       dl 0x001444 ; 00008B, 28.501
040EF2 63 14 00    1229*       dl 0x001463 ; 00008C, 28.673
040EF5 83 14 00    1230*       dl 0x001483 ; 00008D, 28.845
040EF8 A2 14 00    1231*       dl 0x0014A2 ; 00008E, 29.017
040EFB C1 14 00    1232*       dl 0x0014C1 ; 00008F, 29.187
040EFE E0 14 00    1233*       dl 0x0014E0 ; 000090, 29.358
040F01 FF 14 00    1234*       dl 0x0014FF ; 000091, 29.527
040F04 1E 15 00    1235*       dl 0x00151E ; 000092, 29.697
040F07 3C 15 00    1236*       dl 0x00153C ; 000093, 29.865
040F0A 5B 15 00    1237*       dl 0x00155B ; 000094, 30.033
040F0D 79 15 00    1238*       dl 0x001579 ; 000095, 30.201
040F10 98 15 00    1239*       dl 0x001598 ; 000096, 30.368
040F13 B6 15 00    1240*       dl 0x0015B6 ; 000097, 30.534
040F16 D4 15 00    1241*       dl 0x0015D4 ; 000098, 30.700
040F19 F2 15 00    1242*       dl 0x0015F2 ; 000099, 30.865
040F1C 10 16 00    1243*       dl 0x001610 ; 00009A, 31.030
040F1F 2E 16 00    1244*       dl 0x00162E ; 00009B, 31.194
040F22 4C 16 00    1245*       dl 0x00164C ; 00009C, 31.357
040F25 6A 16 00    1246*       dl 0x00166A ; 00009D, 31.520
040F28 87 16 00    1247*       dl 0x001687 ; 00009E, 31.682
040F2B A5 16 00    1248*       dl 0x0016A5 ; 00009F, 31.844
040F2E C2 16 00    1249*       dl 0x0016C2 ; 0000A0, 32.005
040F31 DF 16 00    1250*       dl 0x0016DF ; 0000A1, 32.166
040F34 FC 16 00    1251*       dl 0x0016FC ; 0000A2, 32.326
040F37 19 17 00    1252*       dl 0x001719 ; 0000A3, 32.486
040F3A 36 17 00    1253*       dl 0x001736 ; 0000A4, 32.645
040F3D 53 17 00    1254*       dl 0x001753 ; 0000A5, 32.803
040F40 70 17 00    1255*       dl 0x001770 ; 0000A6, 32.961
040F43 8C 17 00    1256*       dl 0x00178C ; 0000A7, 33.118
040F46 A9 17 00    1257*       dl 0x0017A9 ; 0000A8, 33.275
040F49 C5 17 00    1258*       dl 0x0017C5 ; 0000A9, 33.431
040F4C E2 17 00    1259*       dl 0x0017E2 ; 0000AA, 33.587
040F4F FE 17 00    1260*       dl 0x0017FE ; 0000AB, 33.742
040F52 1A 18 00    1261*       dl 0x00181A ; 0000AC, 33.896
040F55 36 18 00    1262*       dl 0x001836 ; 0000AD, 34.050
040F58 52 18 00    1263*       dl 0x001852 ; 0000AE, 34.203
040F5B 6E 18 00    1264*       dl 0x00186E ; 0000AF, 34.356
040F5E 8A 18 00    1265*       dl 0x00188A ; 0000B0, 34.509
040F61 A5 18 00    1266*       dl 0x0018A5 ; 0000B1, 34.660
040F64 C1 18 00    1267*       dl 0x0018C1 ; 0000B2, 34.811
040F67 DC 18 00    1268*       dl 0x0018DC ; 0000B3, 34.962
040F6A F7 18 00    1269*       dl 0x0018F7 ; 0000B4, 35.112
040F6D 13 19 00    1270*       dl 0x001913 ; 0000B5, 35.262
040F70 2E 19 00    1271*       dl 0x00192E ; 0000B6, 35.410
040F73 49 19 00    1272*       dl 0x001949 ; 0000B7, 35.559
040F76 64 19 00    1273*       dl 0x001964 ; 0000B8, 35.707
040F79 7F 19 00    1274*       dl 0x00197F ; 0000B9, 35.854
040F7C 99 19 00    1275*       dl 0x001999 ; 0000BA, 36.001
040F7F B4 19 00    1276*       dl 0x0019B4 ; 0000BB, 36.147
040F82 CE 19 00    1277*       dl 0x0019CE ; 0000BC, 36.293
040F85 E9 19 00    1278*       dl 0x0019E9 ; 0000BD, 36.438
040F88 03 1A 00    1279*       dl 0x001A03 ; 0000BE, 36.582
040F8B 1D 1A 00    1280*       dl 0x001A1D ; 0000BF, 36.726
040F8E 37 1A 00    1281*       dl 0x001A37 ; 0000C0, 36.870
040F91 51 1A 00    1282*       dl 0x001A51 ; 0000C1, 37.013
040F94 6B 1A 00    1283*       dl 0x001A6B ; 0000C2, 37.155
040F97 85 1A 00    1284*       dl 0x001A85 ; 0000C3, 37.297
040F9A 9F 1A 00    1285*       dl 0x001A9F ; 0000C4, 37.439
040F9D B9 1A 00    1286*       dl 0x001AB9 ; 0000C5, 37.579
040FA0 D2 1A 00    1287*       dl 0x001AD2 ; 0000C6, 37.720
040FA3 EC 1A 00    1288*       dl 0x001AEC ; 0000C7, 37.859
040FA6 05 1B 00    1289*       dl 0x001B05 ; 0000C8, 37.999
040FA9 1E 1B 00    1290*       dl 0x001B1E ; 0000C9, 38.137
040FAC 37 1B 00    1291*       dl 0x001B37 ; 0000CA, 38.276
040FAF 50 1B 00    1292*       dl 0x001B50 ; 0000CB, 38.413
040FB2 69 1B 00    1293*       dl 0x001B69 ; 0000CC, 38.550
040FB5 82 1B 00    1294*       dl 0x001B82 ; 0000CD, 38.687
040FB8 9B 1B 00    1295*       dl 0x001B9B ; 0000CE, 38.823
040FBB B4 1B 00    1296*       dl 0x001BB4 ; 0000CF, 38.959
040FBE CC 1B 00    1297*       dl 0x001BCC ; 0000D0, 39.094
040FC1 E5 1B 00    1298*       dl 0x001BE5 ; 0000D1, 39.228
040FC4 FD 1B 00    1299*       dl 0x001BFD ; 0000D2, 39.362
040FC7 16 1C 00    1300*       dl 0x001C16 ; 0000D3, 39.496
040FCA 2E 1C 00    1301*       dl 0x001C2E ; 0000D4, 39.629
040FCD 46 1C 00    1302*       dl 0x001C46 ; 0000D5, 39.762
040FD0 5E 1C 00    1303*       dl 0x001C5E ; 0000D6, 39.894
040FD3 76 1C 00    1304*       dl 0x001C76 ; 0000D7, 40.025
040FD6 8E 1C 00    1305*       dl 0x001C8E ; 0000D8, 40.156
040FD9 A5 1C 00    1306*       dl 0x001CA5 ; 0000D9, 40.286
040FDC BD 1C 00    1307*       dl 0x001CBD ; 0000DA, 40.416
040FDF D5 1C 00    1308*       dl 0x001CD5 ; 0000DB, 40.546
040FE2 EC 1C 00    1309*       dl 0x001CEC ; 0000DC, 40.675
040FE5 04 1D 00    1310*       dl 0x001D04 ; 0000DD, 40.803
040FE8 1B 1D 00    1311*       dl 0x001D1B ; 0000DE, 40.931
040FEB 32 1D 00    1312*       dl 0x001D32 ; 0000DF, 41.059
040FEE 49 1D 00    1313*       dl 0x001D49 ; 0000E0, 41.186
040FF1 60 1D 00    1314*       dl 0x001D60 ; 0000E1, 41.312
040FF4 77 1D 00    1315*       dl 0x001D77 ; 0000E2, 41.438
040FF7 8E 1D 00    1316*       dl 0x001D8E ; 0000E3, 41.564
040FFA A5 1D 00    1317*       dl 0x001DA5 ; 0000E4, 41.689
040FFD BB 1D 00    1318*       dl 0x001DBB ; 0000E5, 41.814
041000 D2 1D 00    1319*       dl 0x001DD2 ; 0000E6, 41.938
041003 E9 1D 00    1320*       dl 0x001DE9 ; 0000E7, 42.061
041006 FF 1D 00    1321*       dl 0x001DFF ; 0000E8, 42.184
041009 15 1E 00    1322*       dl 0x001E15 ; 0000E9, 42.307
04100C 2C 1E 00    1323*       dl 0x001E2C ; 0000EA, 42.429
04100F 42 1E 00    1324*       dl 0x001E42 ; 0000EB, 42.551
041012 58 1E 00    1325*       dl 0x001E58 ; 0000EC, 42.672
041015 6E 1E 00    1326*       dl 0x001E6E ; 0000ED, 42.793
041018 84 1E 00    1327*       dl 0x001E84 ; 0000EE, 42.913
04101B 99 1E 00    1328*       dl 0x001E99 ; 0000EF, 43.033
04101E AF 1E 00    1329*       dl 0x001EAF ; 0000F0, 43.152
041021 C5 1E 00    1330*       dl 0x001EC5 ; 0000F1, 43.271
041024 DA 1E 00    1331*       dl 0x001EDA ; 0000F2, 43.390
041027 F0 1E 00    1332*       dl 0x001EF0 ; 0000F3, 43.508
04102A 05 1F 00    1333*       dl 0x001F05 ; 0000F4, 43.625
04102D 1B 1F 00    1334*       dl 0x001F1B ; 0000F5, 43.742
041030 30 1F 00    1335*       dl 0x001F30 ; 0000F6, 43.859
041033 45 1F 00    1336*       dl 0x001F45 ; 0000F7, 43.975
041036 5A 1F 00    1337*       dl 0x001F5A ; 0000F8, 44.091
041039 6F 1F 00    1338*       dl 0x001F6F ; 0000F9, 44.206
04103C 84 1F 00    1339*       dl 0x001F84 ; 0000FA, 44.321
04103F 99 1F 00    1340*       dl 0x001F99 ; 0000FB, 44.435
041042 AD 1F 00    1341*       dl 0x001FAD ; 0000FC, 44.549
041045 C2 1F 00    1342*       dl 0x001FC2 ; 0000FD, 44.662
041048 D7 1F 00    1343*       dl 0x001FD7 ; 0000FE, 44.775
04104B EB 1F 00    1344*       dl 0x001FEB ; 0000FF, 44.888
04104E 00 20 00    1345*       dl 0x002000 ; 000100, 45.000 only needed for interpolation
041051             0036        include "images.inc"
041051             0001*   image_type: equ 0
041051             0002*   image_width: equ image_type+3
041051             0003*   image_height: equ image_width+3
041051             0004*   image_filesize: equ image_height+3
041051             0005*   image_filename: equ image_filesize+3
041051             0006*   image_bufferId: equ image_filename+3
041051             0007*   image_record_size: equ image_bufferId+3
041051             0008*   
041051 00 00 00    0009*   cur_image_list: dl 0
041054 00 00 00    0010*   cur_file_idx: dl 0
041057 00 00 00    0011*   cur_filename: dl 0
04105A 00 00 00    0012*   cur_buffer_id: dl 0
04105D             0013*   
04105D             0014*   ; load_ui_images:
04105D             0015*   ; ; initialize image loading variables
04105D             0016*   ;     ld hl,0
04105D             0017*   ;     ld (cur_file_idx),hl
04105D             0018*   ;     ld hl,ui_image_list
04105D             0019*   ;     ld (cur_image_list),hl
04105D             0020*   ; ; load images
04105D             0021*   ;     ld b,ui_num_images
04105D             0022*   ; @loop:
04105D             0023*   ;     push bc
04105D             0024*   ;     call load_next_image
04105D             0025*   ;     pop bc
04105D             0026*   ;     djnz @loop
04105D             0027*   ;     ret
04105D             0028*   
04105D             0029*   load_sprite_images:
04105D             0030*   ; initialize image loading variables
04105D 21 00 00 00 0031*       ld hl,0
041061 22 54 10 04 0032*       ld (cur_file_idx),hl
041065 21 54 1B 04 0033*       ld hl,sprites_image_list
041069 22 51 10 04 0034*       ld (cur_image_list),hl
04106D 01 71 00 00 0035*       ld bc,sprites_num_images
041071             0036*   ; load images
041071 CD 76 10 04 0037*       call img_load_main
041075 C9          0038*       ret
041076             0039*   
041076             0040*   ; inputs: bc is the number of images to load, cur_image_list set
041076             0041*   img_load_main:
041076 AF          0042*       xor a
041077 32 54 10 04 0043*       ld (cur_file_idx),a
04107B             0044*   
04107B             0045*   img_load_main_loop:
04107B             0046*   ; back up loop counter
04107B C5          0047*       push bc
04107C             0048*   
04107C             0049*   ; load the next image
04107C CD 97 10 04 0050*       call load_next_image
041080             0051*   
041080             0052*   ; ; plot the background
041080             0053*   ;     call vdu_cls
041080             0054*   ;     ld hl,BUF_SPLASH_BG
041080             0055*   ;     call vdu_buff_select
041080             0056*   ;     ld bc,0
041080             0057*   ;     ld de,0
041080             0058*   ;     call vdu_plot_bmp
041080             0059*   
041080             0060*   ; ; draw the most recently loaded image
041080             0061*   ; 	ld hl,(cur_buffer_id)
041080             0062*   ; 	call vdu_buff_select
041080             0063*   ; 	ld bc,0
041080             0064*   ; 	ld de,0
041080             0065*   ; 	call vdu_plot_bmp
041080             0066*   
041080             0067*   ; ; move logo
041080             0068*   ;     call move_logo
041080             0069*   
041080             0070*   ; print current filename
041080 2A 57 10 04 0071*       ld hl,(cur_filename)
041084 CD 07 01 04 0072*       call printString
041088             0073*   
041088             0074*   ; flip the framebuffer
041088             0075*       ; call vdu_flip
041088             0076*   
041088             0077*   ; decrement loop counter
041088 C1          0078*       pop bc
041089 0B          0079*       dec bc
04108A 79          0080*       ld a,c
04108B B7          0081*       or a
04108C C2 7B 10 04 0082*       jp nz,img_load_main_loop
041090 78          0083*       ld a,b
041091 B7          0084*       or a
041092 C2 7B 10 04 0085*       jp nz,img_load_main_loop
041096 C9          0086*       ret
041097             0087*   
041097             0088*   load_next_image:
041097 16 12       0089*       ld d,image_record_size
041099 3A 54 10 04 0090*       ld a,(cur_file_idx)
04109D 5F          0091*       ld e,a
04109E ED 5C       0092*       mlt de
0410A0 FD 2A 51 10 0093*       ld iy,(cur_image_list)
       04          
0410A5 FD 19       0094*       add iy,de
0410A7             0095*   
0410A7 FD 7E 00    0096*       ld a,(iy+image_type) ; get image type
0410AA FD 07 03    0097*       ld bc,(iy+image_width) ; get image width
0410AD FD 17 06    0098*       ld de,(iy+image_height) ; get image height
0410B0 FD 31 09    0099*       ld ix,(iy+image_filesize) ; get image file size
0410B3 FD 27 0F    0100*       ld hl,(iy+image_bufferId) ; get image bufferId
0410B6 22 5A 10 04 0101*       ld (cur_buffer_id),hl
0410BA FD 37 0C    0102*       ld iy,(iy+image_filename) ; get image filename
0410BD FD 22 57 10 0103*       ld (cur_filename),iy
       04          
0410C2 CD 56 15 04 0104*       call vdu_load_img
0410C6 FD 21 54 10 0105*       ld iy,cur_file_idx
       04          
0410CB FD 34 00    0106*       inc (iy)
0410CE C9          0107*       ret
0410CF             0108*   
0410CF             0109*   ; img_load_init:
0410CF             0110*   ; ; initialize logo's position parameters
0410CF             0111*   ;     ld hl,0
0410CF             0112*   ;     ld (logo_xvel),hl
0410CF             0113*   ;     ld (logo_xpos),hl
0410CF             0114*   ; ; begin 16.8 maths to determine logo's y position and velocity
0410CF             0115*   ;     ld hl,240-16*256 ; allow space for text at bottom of screen
0410CF             0116*   ;     ld (logo_ypos),hl
0410CF             0117*   ;     ex de,hl
0410CF             0118*   ;     ld hl,-8*256 ; 8 pixels from top of screen
0410CF             0119*   ;     add hl,de ; distance for logo to travel
0410CF             0120*   ;     ld de,-sprites_num_images*256
0410CF             0121*   ;     call sdiv168 ; ud.e = distance / num images = y velocity
0410CF             0122*   ;     ld (logo_yvel),de
0410CF             0123*   ; ; all done
0410CF             0124*   ;     ret
0410CF             0125*   
0410CF             0126*   ; move_logo:
0410CF             0127*   ; ; activate logo bitmap
0410CF             0128*   ;     ld hl, BUF_SPLASH_LOGO
0410CF             0129*   ;     call vdu_buff_select
0410CF             0130*   ; ; update position based on velocity parameters
0410CF             0131*   ;     ld hl,(logo_ypos)
0410CF             0132*   ;     ld de,(logo_yvel)
0410CF             0133*   ;     add hl,de
0410CF             0134*   ;     ld (logo_ypos),hl
0410CF             0135*   ; ; draw logo
0410CF             0136*   ;     ld bc,(logo_xpos)
0410CF             0137*   ;     ld de,(logo_ypos)
0410CF             0138*   ;     call vdu_plot_bmp168
0410CF             0139*   ;     ret
0410CF             0140*   
0410CF             0141*   ; logo_xvel: dl 0
0410CF             0142*   ; logo_xpos: dl 0
0410CF             0143*   
0410CF             0144*   ; logo_yvel: dl 0
0410CF             0145*   ; logo_ypos: dl 0
0410CF             0037        include "timer.inc"
0410CF FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
041100             0002*   
041100             0003*   ; Table 32. Timer Control Registers
041100             0004*   ; this constant is the base address of the timer control registers
041100             0005*   ; each timer takes three bytes:
041100             0006*   ;   0: control register
041100             0007*   ;   1: low byte of timer reset value
041100             0008*   ;   2: high byte of timer reset value
041100             0009*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
041100             0010*   ; which correctly force the high and upper bytes of the address bus to zero
041100             0011*   TMR_CTL:     equ 80h
041100             0012*   
041100             0013*   ; Timer Control Register Bit Definitions
041100             0014*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
041100             0015*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
041100             0016*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
041100             0017*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
041100             0018*                               ; the TMRx_CTL register is read.
041100             0019*   
041100             0020*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
041100             0021*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
041100             0022*   
041100             0023*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
041100             0024*                               ;  0,and counting stops when the end-of-count value is reached.
041100             0025*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
041100             0026*                               ; written to the counter when the end-of-count value is reached.
041100             0027*   
041100             0028*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
041100             0029*   CLK_DIV_256:  equ %00001100 ;
041100             0030*   CLK_DIV_64:   equ %00001000 ;
041100             0031*   CLK_DIV_16:   equ %00000100 ;
041100             0032*   CLK_DIV_4:    equ %00000000 ;
041100             0033*   
041100             0034*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
041100             0035*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
041100             0036*                               ; When a 1 is written to this bit,the values in the reload registers
041100             0037*                               ;  are loaded into the downcounter when the timer restarts. The
041100             0038*                               ; programmer must ensure that this bit is set to 1 each time
041100             0039*                               ; SINGLE-PASS mode is used.
041100             0040*   
041100             0041*   ; disable/enable the programmable reload timer
041100             0042*   PRT_EN_0:     equ %00000000 ;
041100             0043*   PRT_EN_1:     equ %00000001 ;
041100             0044*   
041100             0045*   ; Table 37. Timer Input Source Select Register
041100             0046*   ; Each of the 4 timers are allocated two bits of the 8-bit register
041100             0047*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
041100             0048*   ;   00: System clock / CLK_DIV
041100             0049*   ;   01: RTC / CLK_DIV
041100             0050*   ;   NOTE: these are the values given in the manual,but it may be a typo
041100             0051*   ;   10: GPIO port B pin 1.
041100             0052*   ;   11: GPIO port B pin 1.
041100             0053*   TMR_ISS:   equ 92h ; register address
041100             0054*   
041100             0055*   ; Table 51. Real-Time Clock Control Register
041100             0056*   RTC_CTRL: equ EDh ; register address
041100             0057*   
041100             0058*   ; alarm interrupt disable/enable
041100             0059*   RTC_ALARM_0:    equ %00000000
041100             0060*   RTC_ALARM_1:    equ %10000000
041100             0061*   
041100             0062*   ; interrupt on alarm disable/enable
041100             0063*   RTC_INT_ENT_0:  equ %00000000
041100             0064*   RTC_INT_ENT_1:  equ %01000000
041100             0065*   
041100             0066*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
041100             0067*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
041100             0068*   
041100             0069*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
041100             0070*                                   ; On-chip 32768 Hz oscillator is enabled.
041100             0071*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
041100             0072*                                   ; On-chip 32768 Hz oscillator is disabled.
041100             0073*   
041100             0074*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
041100             0075*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
041100             0076*   
041100             0077*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
041100             0078*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
041100             0079*   
041100             0080*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
041100             0081*                                   ; RTC counter is enabled.
041100             0082*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
041100             0083*                                   ; RTC counter is disabled.
041100             0084*   
041100             0085*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
041100             0086*   
041100             0087*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
041100             0088*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
041100 00 00 00    0089*   prt_reload: dl 0x000000
041103             0090*   
041103             0091*   ; set PRT timer
041103             0092*   prt_set:
041103 21 00 00 00 0093*       ld hl,0
041107 22 51 11 04 0094*       ld (prt_irq_counter),hl
04110B 2A 00 11 04 0095*       ld hl,(prt_reload)
04110F ED 29 84    0096*       out0 ($84),l
041112 ED 21 85    0097*   	out0 ($85),h
041115             0098*   ; disable timer
041115 3E 06       0099*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
041117 ED 39 83    0100*   	out0 ($83),a
04111A             0101*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04111A 3E 57       0102*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04111C ED 39 83    0103*   	out0 ($83),a
04111F C9          0104*       ret
041120             0105*   
041120             0106*   ; ===============================================
041120             0107*   ; PRT Timer Interrupt Handling
041120             0108*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
041120             0109*   ; -----------------------------------------------
041120             0110*   prt_irq_init:
041120             0111*       ; set up interrupt vector table 2
041120 21 00 00 00 0112*   	ld hl,0
041124 3A 0C 01 00 0113*   	ld a,($10c)
041128 6F          0114*   	ld l,a
041129 3A 0D 01 00 0115*   	ld a,($10d)
04112D 67          0116*   	ld h,a
04112E             0117*   
04112E             0118*   	; skip over CALL ($c3)
04112E 23          0119*   	inc hl
04112F             0120*   	; load address of jump into vector table 2 (in ram)
04112F ED 27       0121*   	ld hl,(hl)
041131             0122*   
041131             0123*   	; write CALL prt_irq_handler to vector table 2
041131 3E C3       0124*   	ld a,$c3
041133 77          0125*   	ld (hl),a
041134 23          0126*   	inc hl
041135 11 3C 11 04 0127*   	ld de,prt_irq_handler
041139 ED 1F       0128*   	ld (hl),de
04113B             0129*   
04113B C9          0130*       ret
04113C             0131*   
04113C             0132*   prt_irq_handler:
04113C F3          0133*   	di
04113D F5          0134*   	push af
04113E E5          0135*       push hl
04113F ED 38 83    0136*   	in0 a,($83)
041142 2A 51 11 04 0137*   	ld hl,(prt_irq_counter)
041146 23          0138*   	inc hl
041147 22 51 11 04 0139*   	ld (prt_irq_counter),hl
04114B E1          0140*       pop hl
04114C F1          0141*   	pop af
04114D FB          0142*   	ei
04114E 5B ED 4D    0143*   	reti.l
041151             0144*   
041151             0145*   prt_irq_counter:
041151 00 00 00    0146*   	.dl 0
041154             0147*   prt_irq_counter_saved:
041154 00 00 00    0148*       .dl 0
041157             0149*   
041157             0150*   prt_loop_reset:
041157 E5          0151*       push hl
041158 21 00 00 00 0152*   	ld hl,0
04115C 22 51 11 04 0153*   	ld (prt_irq_counter),hl
041160 22 C2 11 04 0154*       ld (prt_loop_counter),hl
041164 22 C5 11 04 0155*       ld (prt_loops),hl
041168 CD 03 11 04 0156*       call prt_set
04116C E1          0157*       pop hl
04116D C9          0158*       ret
04116E             0159*   
04116E             0160*   prt_loop_start:
04116E E5          0161*       push hl
04116F 21 00 00 00 0162*   	ld hl,0
041173 22 51 11 04 0163*   	ld (prt_irq_counter),hl
041177 E1          0164*       pop hl
041178 C9          0165*       ret
041179             0166*   
041179             0167*   prt_loop_stop:
041179 E5          0168*       push hl
04117A D5          0169*       push de
04117B 2A 51 11 04 0170*       ld hl,(prt_irq_counter)
04117F ED 5B C2 11 0171*       ld de,(prt_loop_counter)
       04          
041184 19          0172*       add hl,de
041185 22 C2 11 04 0173*       ld (prt_loop_counter),hl
041189 21 00 00 00 0174*       ld hl,0
04118D 22 51 11 04 0175*       ld (prt_irq_counter),hl
041191 2A C5 11 04 0176*       ld hl,(prt_loops)
041195 23          0177*       inc hl
041196 22 C5 11 04 0178*       ld (prt_loops),hl
04119A D1          0179*       pop de
04119B E1          0180*       pop hl
04119C C9          0181*       ret
04119D             0182*   
04119D             0183*   ; inputs: bc = y,x text coordinates to print
04119D             0184*   prt_loop_print:
04119D F5          0185*       push af
04119E E5          0186*       push hl
04119F C5          0187*       push bc
0411A0 D5          0188*       push de
0411A1 DD E5       0189*       push ix
0411A3 FD E5       0190*       push iy
0411A5 CD 37 13 04 0191*       call vdu_move_cursor
0411A9             0192*   
0411A9 2A C2 11 04 0193*       ld hl,(prt_loop_counter)
0411AD CD 53 01 04 0194*       call printDec
0411B1             0195*   
0411B1 2A C5 11 04 0196*       ld hl,(prt_loops)
0411B5 CD 53 01 04 0197*       call printDec
0411B9             0198*   
0411B9 FD E1       0199*       pop iy
0411BB DD E1       0200*       pop ix
0411BD D1          0201*       pop de
0411BE C1          0202*       pop bc
0411BF E1          0203*       pop hl
0411C0 F1          0204*       pop af
0411C1 C9          0205*       ret
0411C2             0206*   
0411C2             0207*   prt_loop_counter:
0411C2 00 00 00    0208*       .dl 0
0411C5             0209*   prt_loops:
0411C5 00 00 00    0210*       .dl 0
0411C8             0211*   
0411C8             0212*   ; ===============================================
0411C8             0213*   ; Timer functions
0411C8             0214*   ; -----------------------------------------------
0411C8             0215*   ; set a countdown timer
0411C8             0216*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411C8             0217*   ; returns: hl = current time
0411C8             0218*   tmr_set:
0411C8 FD 2F 03    0219*       ld (iy+3),hl            ; set time remaining
0411CB             0220*       MOSCALL mos_sysvars     ; ix points to syvars table
0411CB 3E 08       0001*M1 			LD	A, function
0411CD 5B CF       0002*M1 			RST.LIL	08h
0411CF DD 27 00    0221*       ld hl,(ix+sysvar_time)  ; get current time
0411D2 FD 2F 00    0222*       ld (iy+0),hl            ; set start time
0411D5 C9          0223*       ret
0411D6             0224*   
0411D6             0225*   ; gets time remaining on a countdown timer
0411D6             0226*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411D6             0227*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0411D6             0228*   ;          sign flags: pos = time not expired,zero or neg = time expired
0411D6             0229*   tmr_get:
0411D6             0230*       MOSCALL mos_sysvars     ; ix points to syvars table
0411D6 3E 08       0001*M1 			LD	A, function
0411D8 5B CF       0002*M1 			RST.LIL	08h
0411DA DD 17 00    0231*       ld de,(ix+sysvar_time)  ; get current time
0411DD FD 27 00    0232*       ld hl,(iy+0)            ; get start time
0411E0 AF          0233*       xor a                   ; clear carry
0411E1 ED 52       0234*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0411E3 FD 17 03    0235*       ld de,(iy+3)            ; get timer set value
0411E6 AF          0236*       xor a                   ; clear carry
0411E7 ED 5A       0237*       adc hl,de               ; hl = time remaining
0411E9             0238*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0411E9 C9          0239*       ret
0411EA             0240*   
0411EA             0241*   tmr_test: ds 6 ; example of a buffer to hold timer data
0411F0             0242*   
       FF FF FF FF 
       FF FF 
0411F0 00 00 00    0243*   timestamp_now: dl 0
0411F3 00 00 00    0244*   timestamp_old: dl 0
0411F6 00 00 00    0245*   timestamp_chg: dl 0
0411F9             0246*   
0411F9             0247*   ; update the global timestamp from the system clock
0411F9             0248*   ; inputs: none
0411F9             0249*   ; returns: hl = time elapsed in 1/120ths of a second
0411F9             0250*   ;          ix = pointer to syvars table
0411F9             0251*   ; destroys: af,hl,de,ix
0411F9             0252*   timestamp_tick:
0411F9 ED 5B F0 11 0253*       ld de,(timestamp_now)   ; get previous time
       04          
0411FE ED 53 F3 11 0254*       ld (timestamp_old),de   ; save previous time
       04          
041203             0255*       MOSCALL mos_sysvars     ; ix points to syvars table
041203 3E 08       0001*M1 			LD	A, function
041205 5B CF       0002*M1 			RST.LIL	08h
041207 DD 27 00    0256*       ld hl,(ix+sysvar_time)  ; get current time
04120A 22 F0 11 04 0257*       ld (timestamp_now),hl   ; save current time
04120E AF          0258*       xor a                   ; clear carry
04120F ED 52       0259*       sbc hl,de               ; hl = time elapsed
041211 22 F6 11 04 0260*       ld (timestamp_chg),hl   ; save elapsed time
041215 C9          0261*       ret
041216             0262*   
041216             0263*   ; set a countdown timer
041216             0264*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041216             0265*   ; requires: timestamp_tick to be called at least once before this function
041216             0266*   ; returns: hl = current time
041216             0267*   ; destroys: hl
041216             0268*   timestamp_tmr_set:
041216 FD 2F 03    0269*       ld (iy+3),hl            ; set time remaining
041219 2A F0 11 04 0270*       ld hl,(timestamp_now)   ; get current timestamp
04121D FD 2F 00    0271*       ld (iy+0),hl            ; set start time
041220 C9          0272*       ret
041221             0273*   
041221             0274*   ; gets time remaining on a countdown timer following the global timestamp
041221             0275*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041221             0276*   ; requires: timestamp_tick to be called at least once before this function
041221             0277*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041221             0278*   ;          sign flags: pos = time not expired,zero or neg = time expired
041221             0279*   ; destroys: af,hl,de
041221             0280*   timestamp_tmr_get:
041221 ED 5B F0 11 0281*       ld de,(timestamp_now)   ; get current timestamp
       04          
041226 FD 27 00    0282*       ld hl,(iy+0)            ; get start time
041229 AF          0283*       xor a                   ; clear carry
04122A ED 52       0284*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
04122C FD 17 03    0285*       ld de,(iy+3)            ; get timer set value
04122F AF          0286*       xor a                   ; clear carry
041230 ED 5A       0287*       adc hl,de               ; hl = time remaining
041232             0288*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
041232 C9          0289*       ret
041233             0290*   
041233             0291*   ; set a stopwatch
041233             0292*   ; returns: hl = start time
041233             0293*   ; destroys: hl,ix
041233             0294*   stopwatch_set:
041233             0295*       MOSCALL mos_sysvars     ; ix points to syvars table
041233 3E 08       0001*M1 			LD	A, function
041235 5B CF       0002*M1 			RST.LIL	08h
041237 DD 27 00    0296*       ld hl,(ix+sysvar_time)  ; get current time
04123A 22 4F 12 04 0297*       ld (stopwatch_started),hl            ; set start time
04123E C9          0298*       ret
04123F             0299*   
04123F             0300*   ; gets time elapsed on a stopwatch
04123F             0301*   ; returns: hl = time elapsed in 1/120ths of a second
04123F             0302*   ; destroys: af,hl,de,ix
04123F             0303*   stopwatch_get:
04123F             0304*       MOSCALL mos_sysvars     ; ix points to syvars table
04123F 3E 08       0001*M1 			LD	A, function
041241 5B CF       0002*M1 			RST.LIL	08h
041243 DD 27 00    0305*       ld hl,(ix+sysvar_time)  ; get current time
041246 ED 5B 4F 12 0306*       ld de,(stopwatch_started)            ; get start time
       04          
04124B AF          0307*       xor a                   ; clear carry
04124C ED 52       0308*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04124E C9          0309*       ret
04124F             0310*   
04124F             0311*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041252             0312*   
041252             0313*   ; ------------------
041252             0314*   ; delay routine
041252             0315*   ; Author: Richard Turrnidge
041252             0316*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
041252             0317*   ; routine waits a fixed time,then returns
041252             0318*   ; arrive with A =  the delay byte. One bit to be set only.
041252             0319*   ; eg. ld A,00000100b
041252             0320*   
041252             0321*   multiPurposeDelay:
       FF FF FF 
041252 F5          0322*       push af
041253 C5          0323*       push bc
041254 DD E5       0324*       push ix
041256 47          0325*       ld b,a
041257 3E 08       0326*       ld a,$08
041259 5B CF       0327*       RST.LIL	08h                 ; get IX pointer to sysvars
04125B             0328*   
04125B             0329*   waitLoop:
04125B             0330*   
04125B DD 7E 00    0331*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04125E             0332*   
04125E             0333*                                   ;   we check if bit set is same as last time we checked.
04125E             0334*                                   ;   bit 0 - don't use
04125E             0335*                                   ;   bit 1 - changes 64 times per second
04125E             0336*                                   ;   bit 2 - changes 32 times per second
04125E             0337*                                   ;   bit 3 - changes 16 times per second
04125E             0338*   
04125E             0339*                                   ;   bit 4 - changes 8 times per second
04125E             0340*                                   ;   bit 5 - changes 4 times per second
04125E             0341*                                   ;   bit 6 - changes 2 times per second
04125E             0342*                                   ;   bit 7 - changes 1 times per second
04125E A0          0343*       and b
04125F 4F          0344*       ld c,a
041260 3A 71 12 04 0345*       ld a,(oldTimeStamp)
041264 B9          0346*       cp c                        ; is A same as last value?
041265 28 F4       0347*       jr z,waitLoop              ; loop here if it is
041267 79          0348*       ld a,c
041268 32 71 12 04 0349*       ld (oldTimeStamp),a        ; set new value
04126C             0350*   
04126C DD E1       0351*       pop ix
04126E C1          0352*       pop bc
04126F F1          0353*       pop af
041270 C9          0354*       ret
041271             0355*   
041271 00          0356*   oldTimeStamp:   .db 00h
041272             0038        include "vdu.inc"
041272 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
041300             0002*   
041300             0003*   ; VDU 30: Home cursor
041300             0004*   vdu_home_cursor:
041300 3E 1E       0005*       ld a,30
041302 5B D7       0006*   	rst.lil $10
041304 C9          0007*   	ret
041305             0008*   
041305             0009*   vdu_cursor_on:
041305 21 10 13 04 0010*   	ld hl,@cmd
041309 01 03 00 00 0011*   	ld bc,@end-@cmd
04130D 5B DF       0012*   	rst.lil $18
04130F C9          0013*   	ret
041310             0014*   @cmd:
041310 17 01 01    0015*   	db 23,1,1
041313             0016*   @end:
041313             0017*   
041313             0018*   vdu_cursor_off:
041313 21 1E 13 04 0019*   	ld hl,@cmd
041317 01 03 00 00 0020*   	ld bc,@end-@cmd
04131B 5B DF       0021*   	rst.lil $18
04131D C9          0022*   	ret
04131E             0023*   @cmd:
04131E 17 01 00    0024*   	db 23,1,0
041321             0025*   @end:
041321             0026*   
041321             0027*   ; VDU 5: Write text at graphics cursor
041321             0028*   ; inputs: a is the character to write to the screen
041321             0029*   ; prerequisites: the graphics cursor at the intended position on screen
041321             0030*   ; outputs: see the name of the function
041321             0031*   ; destroys: a, hl, bc
041321             0032*   vdu_char_to_gfx_cursor:
041321 32 31 13 04 0033*   	ld (@arg),a
041325 21 30 13 04 0034*   	ld hl,@cmd
041329 01 02 00 00 0035*   	ld bc,@end-@cmd
04132D 5B DF       0036*   	rst.lil $18
04132F C9          0037*   	ret
041330 05          0038*   @cmd: db 5
041331 00          0039*   @arg: db 0
041332             0040*   @end:
041332             0041*   ; VDU 9: Move cursor forward one character
041332             0042*   vdu_cursor_forward:
041332 3E 09       0043*       ld a,9
041334 5B D7       0044*   	rst.lil $10
041336 C9          0045*   	ret
041337             0046*   
041337             0047*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041337             0048*   ; inputs: c=x, b=y 8-bit unsigned integers
041337             0049*   vdu_move_cursor:
041337 ED 43 48 13 0050*       ld (@x0),bc
       04          
04133C 21 47 13 04 0051*   	ld hl,@cmd
041340 01 03 00 00 0052*   	ld bc,@end-@cmd
041344 5B DF       0053*   	rst.lil $18
041346 C9          0054*   	ret
041347 1F          0055*   @cmd: 	db 31
041348 00          0056*   @x0:	db 0
041349 00          0057*   @y0: 	db 0
04134A 00          0058*   @end: 	db 0 ; padding
04134B             0059*   
04134B             0060*   ; VDU 12: Clear text area (CLS)
04134B             0061*   vdu_cls:
04134B 3E 0C       0062*       ld a,12
04134D 5B D7       0063*   	rst.lil $10
04134F C9          0064*   	ret
041350             0065*   
041350             0066*   vdu_flip:
041350 21 5B 13 04 0067*   	ld hl,@cmd
041354 01 03 00 00 0068*   	ld bc,@end-@cmd
041358 5B DF       0069*   	rst.lil $18
04135A C9          0070*   	ret
04135B 17 00 C3    0071*   @cmd: db 23,0,0xC3
04135E             0072*   @end:
04135E             0073*   
04135E             0074*   ; VDU 16: Clear graphics area (CLG)
04135E             0075*   vdu_clg:
04135E 3E 10       0076*       ld a,16
041360 5B D7       0077*   	rst.lil $10
041362 C9          0078*   	ret
041363             0079*   
041363             0080*   ; https://github.com/breakintoprogram/agon-docs/wiki/VDP
041363             0081*   ; VDU 23, 7: Scrolling
041363             0082*   ;     VDU 23, 7, extent, direction, speed: Scroll the screen
041363             0083*   ; inputs: a, extent; l, direction; h; speed
041363             0084*   vdu_scroll_down:
041363 32 78 13 04 0085*   	ld (@extent),a
041367 22 79 13 04 0086*   	ld (@dir),hl ; implicitly populates @speed
04136B 21 76 13 04 0087*   	ld hl,@cmd
04136F 01 05 00 00 0088*   	ld bc,@end-@cmd
041373 5B DF       0089*   	rst.lil $18     ;; Sending command to VDP
041375 C9          0090*   	ret
041376 17 07       0091*   @cmd:       db 23,7
041378 00          0092*   @extent:    db 0x00 ; 0 current text window, 1 entire screen, 2 curr gfx viewport
041379 00          0093*   @dir:       db 0x00 ; 0 right, 1 left, 2 down, 3 up
04137A 00          0094*   @speed:     db 0x00 ; pixels
04137B 00          0095*   @end:		db 0x00 ; padding
04137C             0096*   
04137C             0097*   ; COLOUR MODES
04137C             0098*   ; Mode	Effect
04137C             0099*   ; 0	Set on-screen pixel to target colour value
04137C             0100*   ; 1	OR value with the on-screen pixel
04137C             0101*   ; 2	AND value with the on-screen pixel
04137C             0102*   ; 3	XOR value with the on-screen pixel
04137C             0103*   ; 4	Invert the on-screen pixel
04137C             0104*   ; 5	No operation
04137C             0105*   ; 6	AND the inverse of the specified colour with the on-screen pixel
04137C             0106*   ; 7	OR the inverse of the specified colour with the on-screen pixel
04137C             0107*   
04137C             0108*   ; VDU 17, colour: Define text colour (COLOUR)
04137C             0109*   vdu_colour_text:
04137C 32 8C 13 04 0110*   	ld (@arg),a
041380 21 8B 13 04 0111*   	ld hl,@cmd
041384 01 02 00 00 0112*   	ld bc,@end-@cmd
041388 5B DF       0113*   	rst.lil $18
04138A C9          0114*   	ret
04138B 11          0115*   @cmd: db 17
04138C 00          0116*   @arg: db 0
04138D             0117*   @end:
04138D             0118*   
04138D             0119*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04138D             0120*   ; inputs: a=mode, c=colour (add 128 to set background colour)
04138D             0121*   vdu_gcol:
04138D 32 A2 13 04 0122*   	ld (@mode),a
041391 79          0123*       ld a,c
041392 32 A3 13 04 0124*       ld (@col),a
041396 21 A1 13 04 0125*   	ld hl,@cmd
04139A 01 03 00 00 0126*   	ld bc,@end-@cmd
04139E 5B DF       0127*   	rst.lil $18
0413A0 C9          0128*   	ret
0413A1 12          0129*   @cmd:  db 18
0413A2 00          0130*   @mode: db 0
0413A3 00          0131*   @col:  db 0
0413A4             0132*   @end:
0413A4             0133*   
0413A4             0134*   
0413A4             0135*   ; VDU 28, left, bottom, right, top: Set text viewport **
0413A4             0136*   ; MIND THE LITTLE-ENDIANESS
0413A4             0137*   ; inputs: c=left,b=bottom,e=right,d=top
0413A4             0138*   ; outputs; nothing
0413A4             0139*   ; destroys: a might make it out alive
0413A4             0140*   vdu_set_txt_viewport:
0413A4 ED 43 BA 13 0141*       ld (@lb),bc
       04          
0413A9 ED 53 BC 13 0142*   	ld (@rt),de
       04          
0413AE 21 B9 13 04 0143*   	ld hl,@cmd
0413B2 01 05 00 00 0144*   	ld bc,@end-@cmd
0413B6 5B DF       0145*   	rst.lil $18
0413B8 C9          0146*   	ret
0413B9 1C          0147*   @cmd:   db 28 ; set text viewport command
0413BA 00 00       0148*   @lb: 	dw 0x0000 ; set by bc
0413BC 00 00       0149*   @rt: 	dw 0x0000 ; set by de
0413BE 00          0150*   @end:   db 0x00	  ; padding
0413BF             0151*   
0413BF             0152*   ; Wait for VBLANK interrupt
0413BF             0153*   vdu_vblank:
0413BF DD E5       0154*       PUSH 	IX
0413C1             0155*   	MOSCALL	mos_sysvars
0413C1 3E 08       0001*M1 			LD	A, function
0413C3 5B CF       0002*M1 			RST.LIL	08h
0413C5 DD 7E 00    0156*   	LD	A, (IX + sysvar_time + 0)
0413C8             0157*   @wait:
0413C8 DD BE 00    0158*       CP 	A, (IX + sysvar_time + 0)
0413CB 28 FB       0159*       JR	Z, @wait
0413CD DD E1       0160*       POP	IX
0413CF C9          0161*       RET
0413D0             0162*   
0413D0             0163*   ; VDU 29, x; y;: Set graphics origin
0413D0             0164*   ; This command sets the graphics origin.
0413D0             0165*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0413D0             0166*   ; inputs: bc=x0,de=y0
0413D0             0167*   ; outputs; nothing
0413D0             0168*   ; destroys: a might make it out alive
0413D0             0169*   vdu_set_gfx_origin:
0413D0 ED 43 E6 13 0170*       ld (@x0),bc
       04          
0413D5 ED 53 E8 13 0171*       ld (@y0),de
       04          
0413DA 21 E5 13 04 0172*       ld hl,@cmd
0413DE 01 05 00 00 0173*       ld bc,@end-@cmd
0413E2 5B DF       0174*       rst.lil $18
0413E4 C9          0175*       ret
0413E5 1D          0176*   @cmd:   db 29 ; set graphics origin command
0413E6 00 00       0177*   @x0: 	dw 0x0000 ; set by bc
0413E8 00 00       0178*   @y0: 	dw 0x0000 ; set by de
0413EA 00          0179*   @end:   db 0x00	  ; padding
0413EB             0180*   
0413EB             0181*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0413EB             0182*   ; NOTE: the order of the y-coordinate parameters are inverted
0413EB             0183*   ; 	because we have turned off logical screen scaling
0413EB             0184*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0413EB             0185*   ; outputs; nothing
0413EB             0186*   ; destroys: a might make it out alive
0413EB             0187*   vdu_set_gfx_viewport:
0413EB ED 43 0B 14 0188*       ld (@x0),bc
       04          
0413F0 FD 22 0D 14 0189*       ld (@y1),iy
       04          
0413F5 DD 22 0F 14 0190*   	ld (@x1),ix
       04          
0413FA ED 53 11 14 0191*   	ld (@y0),de
       04          
0413FF 21 0A 14 04 0192*   	ld hl,@cmd
041403 01 09 00 00 0193*   	ld bc,@end-@cmd
041407 5B DF       0194*   	rst.lil $18
041409 C9          0195*   	ret
04140A 18          0196*   @cmd:   db 24 ; set graphics viewport command
04140B 00 00       0197*   @x0: 	dw 0x0000 ; set by bc
04140D 00 00       0198*   @y1: 	dw 0x0000 ; set by iy
04140F 00 00       0199*   @x1: 	dw 0x0000 ; set by ix
041411 00 00       0200*   @y0: 	dw 0x0000 ; set by de
041413 00          0201*   @end:   db 0x00	  ; padding
041414             0202*   
041414             0203*   ; SCREEN MODES
041414             0204*   ; ===============================
041414             0205*   ; Mode  Horz  Vert  Cols  Refresh
041414             0206*   ; ---   ----  ----  ----  -------
041414             0207*   ; 11    320   240   2     60hz
041414             0208*   ; 139   320   240   2     60hz
041414             0209*   ; 23    512   384   2     60hz
041414             0210*   ; 151   512   384   2     60hz
041414             0211*   ; 6     640   240   2     60hz
041414             0212*   ; 134   640   240   2     60hz
041414             0213*   ; 2     640   480   2     60hz
041414             0214*   ; 130   640   480   2     60hz
041414             0215*   ; 17    800   600   2     60hz
041414             0216*   ; 145   800   600   2     60hz
041414             0217*   ; 18    1024  768   2     60hz
041414             0218*   ; 146   1024  768   2     60hz
041414             0219*   ; ---   ----  ----  ----  -------
041414             0220*   ; 10    320   240   4     60hz
041414             0221*   ; 138   320   240   4     60hz
041414             0222*   ; 22    512   384   4     60hz
041414             0223*   ; 150   512   384   4     60hz
041414             0224*   ; 5     640   240   4     60hz
041414             0225*   ; 133   640   240   4     60hz
041414             0226*   ; 1     640   480   4     60hz
041414             0227*   ; 129   640   480   4     60hz
041414             0228*   ; 16    800   600   4     60hz
041414             0229*   ; 19    1024  768   4     60hz
041414             0230*   ; ---   ----  ----  ----  -------
041414             0231*   ; 9     320   240   16    60hz
041414             0232*   ; 137   320   240   16    60hz
041414             0233*   ; 21    512   384   16    60hz
041414             0234*   ; 149   512   384   16    60hz
041414             0235*   ; 4     640   240   16    60hz
041414             0236*   ; 132   640   240   16    60hz
041414             0237*   ; 0     640   480   16    60hz
041414             0238*   ; 7     n/a   n/a   16    60hz
041414             0239*   ; ---   ----  ----  ----  -------
041414             0240*   ; 8     320   240   64    60hz
041414             0241*   ; 136   320   240   64    60hz
041414             0242*   ; 20    512   384   64    60hz
041414             0243*   ; 3     640   240   64    60hz
041414             0244*   ; ---   ----  ----  ----  -------
041414             0245*   vdu_set_screen_mode:
041414 32 24 14 04 0246*   	ld (@arg),a
041418 21 23 14 04 0247*   	ld hl,@cmd
04141C 01 02 00 00 0248*   	ld bc,@end-@cmd
041420 5B DF       0249*   	rst.lil $18
041422 C9          0250*   	ret
041423 16          0251*   @cmd: db 22 ; set screen mode
041424 00          0252*   @arg: db 0  ; screen mode parameter
041425             0253*   @end:
041425             0254*   
041425             0255*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041425             0256*   ; inputs: a is scaling mode, 1=on, 0=off
041425             0257*   ; note: default setting on boot is scaling ON
041425             0258*   vdu_set_scaling:
041425 32 37 14 04 0259*   	ld (@arg),a
041429 21 34 14 04 0260*   	ld hl,@cmd
04142D 01 04 00 00 0261*   	ld bc,@end-@cmd
041431 5B DF       0262*   	rst.lil $18
041433 C9          0263*   	ret
041434 17 00 C0    0264*   @cmd: db 23,0,0xC0
041437 00          0265*   @arg: db 0  ; scaling on/off
041438             0266*   @end:
041438             0267*   
041438             0268*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041438             0269*   ; inputs: hl=bufferId
041438             0270*   vdu_buff_select:
041438 22 4A 14 04 0271*   	ld (@bufferId),hl
04143C 21 47 14 04 0272*   	ld hl,@cmd
041440 01 05 00 00 0273*   	ld bc,@end-@cmd
041444 5B DF       0274*   	rst.lil $18
041446 C9          0275*   	ret
041447 17 1B 20    0276*   @cmd: db 23,27,0x20
04144A 00 00       0277*   @bufferId: dw 0x0000
04144C 00          0278*   @end: db 0x00 ; padding
04144D             0279*   
04144D             0280*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04144D             0281*   ; inputs: a=format; bc=width; de=height
04144D             0282*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04144D             0283*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04144D             0284*   ; 0 	RGBA8888 (4-bytes per pixel)
04144D             0285*   ; 1 	RGBA2222 (1-bytes per pixel)
04144D             0286*   ; 2 	Mono/Mask (1-bit per pixel)
04144D             0287*   ; 3 	Reserved for internal use by VDP (“native” format)
04144D             0288*   vdu_bmp_create:
04144D ED 43 69 14 0289*       ld (@width),bc
       04          
041452 ED 53 6B 14 0290*       ld (@height),de
       04          
041457 32 6D 14 04 0291*       ld (@fmt),a
04145B 21 66 14 04 0292*   	ld hl,@cmd
04145F 01 08 00 00 0293*   	ld bc,@end-@cmd
041463 5B DF       0294*   	rst.lil $18
041465 C9          0295*   	ret
041466 17 1B 21    0296*   @cmd:       db 23,27,0x21
041469 00 00       0297*   @width:     dw 0x0000
04146B 00 00       0298*   @height:    dw 0x0000
04146D 00          0299*   @fmt:       db 0x00
04146E             0300*   @end:
04146E             0301*   
04146E             0302*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04146E             0303*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04146E             0304*   vdu_load_img_rgba2_to_8:
04146E             0305*   ; backup the target buffer id and image dimensions
04146E E5          0306*       push hl
04146F D5          0307*       push de
041470 C5          0308*       push bc
041471             0309*   ; load the rgba2 image to working buffer 65534
041471 21 FE FF 00 0310*       ld hl,65534 ; temporary working buffer id
041475 CD 78 15 04 0311*   	call vdu_load_buffer_from_file
041479             0312*   ; restore the image dimensions and target buffer id
041479 C1          0313*       pop bc
04147A D1          0314*       pop de
04147B E1          0315*       pop hl
04147C             0316*   ; fall through to vdu_rgba2_to_8
04147C             0317*   
04147C             0318*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04147C             0319*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04147C             0320*   ; the "expand bitmap" command is:
04147C             0321*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04147C             0322*   ; and then to reverse the byte order to fix endian-ness:
04147C             0323*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04147C             0324*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04147C             0325*   ; VDU 23,27,&20,targetBufferID%;
04147C             0326*   ; VDU 23,27,&21,width%;height%;0
04147C             0327*   ; -------------------------------------------------------------------
04147C             0328*   ; inputs: bc,de image width,height ; hl = targetBufferId
04147C             0329*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04147C             0330*   vdu_rgba2_to_8:
04147C             0331*   ; load the image dimensions and buffer id parameters
04147C ED 43 D8 14 0332*       ld (@width),bc
       04          
041481 ED 53 DA 14 0333*       ld (@height),de
       04          
041486 22 BD 14 04 0334*       ld (@bufferId0),hl
04148A 22 CA 14 04 0335*       ld (@bufferId2),hl
04148E 22 D3 14 04 0336*       ld (@bufferId1),hl
041492             0337*   ; clean up bytes that got stomped on by the ID loads
041492 3E 48       0338*       ld a,0x48
041494 32 BF 14 04 0339*       ld (@bufferId0+2),a
041498 3E 17       0340*       ld a,23
04149A 32 D5 14 04 0341*       ld (@bufferId1+2),a
04149E 3E 18       0342*       ld a,24
0414A0 32 CC 14 04 0343*       ld (@bufferId2+2),a
0414A4 AF          0344*       xor a
0414A5 32 DC 14 04 0345*       ld (@height+2),a
0414A9             0346*   ; send the vdu command strings
0414A9 21 B4 14 04 0347*       ld hl,@beg
0414AD 01 29 00 00 0348*       ld bc,@end-@beg
0414B1 5B DF       0349*       rst.lil $18
0414B3 C9          0350*       ret
0414B4             0351*   @beg:
0414B4             0352*   ; Command 14: Consolidate blocks in a buffer
0414B4             0353*   ; VDU 23, 0, &A0, bufferId; 14
0414B4 17 00 A0    0354*       db 23,0,0xA0
0414B7 FE FF       0355*       dw 65534 ; workingBufferId
0414B9 0E          0356*       db 14 ; consolidate blocks
0414BA             0357*   ; the "expand bitmap" command is:
0414BA             0358*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0414BA 17 00 A0    0359*       db 23,0,0xA0
0414BD 00 00       0360*   @bufferId0: dw 0x0000 ; targetBufferId
0414BF 48          0361*       db 0x48 ; given as decimal command 72 in the docs
0414C0 02          0362*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0414C1 FE FF       0363*       dw 65534 ; sourceBufferId
0414C3 00 7F BF FF 0364*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0414C7             0365*   ; reverse the byte order to fix endian-ness:
0414C7             0366*   ; Command 24: Reverse the order of data of blocks within a buffer
0414C7             0367*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0414C7             0368*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0414C7 17 00 A0    0369*       db 23,0,0xA0
0414CA 00 00       0370*   @bufferId2:    dw 0x0000 ; targetBufferId
0414CC 18          0371*       db 24 ; reverse byte order
0414CD 04          0372*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0414CE 04 00       0373*       dw 4 ; size (4 bytes)
0414D0             0374*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0414D0             0375*   ; VDU 23,27,&20,targetBufferID%;
0414D0 17 1B 20    0376*       db 23,27,0x20 ; select bitmap
0414D3 00 00       0377*   @bufferId1: dw 0x0000 ; targetBufferId
0414D5             0378*   ; VDU 23,27,&21,width%;height%;0
0414D5 17 1B 21    0379*       db 23,27,0x21 ; create bitmap from buffer
0414D8 00 00       0380*   @width: dw 0x0000
0414DA 00 00       0381*   @height: dw 0x0000
0414DC 00          0382*       db 0x00 ; rgba8888 format
0414DD             0383*   @end:
0414DD             0384*   
0414DD             0385*   ; scratch variables
0414DD 00 00 00    0386*   bufferId0: dl 0x000000
0414E0 00 00 00    0387*   bufferId1: dl 0x000000
0414E3             0388*   
0414E3             0389*   ; load a vdu buffer from local memory
0414E3             0390*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0414E3             0391*   vdu_load_buffer:
0414E3 ED 43 0C 15 0392*       ld (@length),bc
       04          
0414E8 D5          0393*       push de ; save data pointer
0414E9             0394*   ; send the vdu command string
0414E9 7D          0395*       ld a,l
0414EA 32 09 15 04 0396*       ld (@bufferId),a
0414EE 7C          0397*       ld a,h
0414EF 32 0A 15 04 0398*       ld (@bufferId+1),a
0414F3 21 06 15 04 0399*       ld hl,@cmd
0414F7 01 08 00 00 0400*       ld bc,@end-@cmd
0414FB 5B DF       0401*       rst.lil $18
0414FD             0402*   ; send the buffer data
0414FD E1          0403*       pop hl ; pointer to data
0414FE ED 4B 0C 15 0404*       ld bc,(@length)
       04          
041503 5B DF       0405*       rst.lil $18 ; send it
041505 C9          0406*       ret
041506             0407*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
041506 17 00 A0    0408*   @cmd:       db 23,0,0xA0
041509 00 00       0409*   @bufferId:	dw 0x0000
04150B 00          0410*   		    db 0 ; load buffer
04150C 00 00       0411*   @length:	dw 0x0000
04150E 00          0412*   @end: db 0 ; padding
04150F             0413*   
04150F             0414*   ; clear a buffer
04150F             0415*   ; inputs: hl = bufferId
04150F             0416*   vdu_clear_buffer:
04150F 7D          0417*       ld a,l
041510 32 27 15 04 0418*       ld (@bufferId),a
041514 7C          0419*       ld a,h
041515 32 28 15 04 0420*       ld (@bufferId+1),a
041519 21 24 15 04 0421*       ld hl,@cmd
04151D 01 06 00 00 0422*       ld bc,@end-@cmd
041521 5B DF       0423*       rst.lil $18
041523 C9          0424*       ret
041524 17 00 A0    0425*   @cmd:       db 23,0,0xA0
041527 00 00       0426*   @bufferId:	dw 0x0000
041529 02          0427*   		    db 2 ; clear buffer
04152A             0428*   @end:
04152A             0429*   
04152A             0430*   vdu_clear_all_buffers:
04152A             0431*   ; clear all buffers
04152A 21 35 15 04 0432*       ld hl,@beg
04152E 01 06 00 00 0433*       ld bc,@end-@beg
041532 5B DF       0434*       rst.lil $18
041534 C9          0435*       ret
041535 17 00 A0    0436*   @beg: db 23,0,$A0
041538 FF FF       0437*         dw -1 ; clear all buffers
04153A 02          0438*         db 2  ; command 2: clear a buffer
04153B             0439*   @end:
04153B             0440*   
04153B             0441*   ; Command 14: Consolidate blocks in a buffer
04153B             0442*   vdu_consolidate_buffer:
04153B             0443*   ; set parameters for vdu call
04153B 7D          0444*       ld a,l
04153C 32 53 15 04 0445*       ld (@bufferId),a
041540 7C          0446*       ld a,h
041541 32 54 15 04 0447*       ld (@bufferId+1),a
041545 21 50 15 04 0448*       ld hl,@beg
041549 01 06 00 00 0449*       ld bc,@end-@beg
04154D 5B DF       0450*       rst.lil $18
04154F C9          0451*       ret
041550             0452*   ; VDU 23, 0, &A0, bufferId; 14
041550 17 00 A0    0453*   @beg: db 23,0,0xA0
041553 00 00       0454*   @bufferId: dw 0x0000
041555 0E          0455*              db 14
041556             0456*   @end:
041556             0457*   
041556             0458*   ; load an image file to a buffer and make it a bitmap
041556             0459*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041556             0460*   vdu_load_img:
041556             0461*   ; back up image type and dimension parameters
041556 22 DD 14 04 0462*       ld (bufferId0),hl
04155A F5          0463*       push af
04155B C5          0464*   	push bc
04155C D5          0465*   	push de
04155D             0466*   ; load the image
04155D CD 78 15 04 0467*   	call vdu_load_buffer_from_file
041561             0468*   ; now make it a bitmap
041561 2A DD 14 04 0469*       ld hl,(bufferId0)
041565 CD 3B 15 04 0470*       call vdu_consolidate_buffer
041569 2A DD 14 04 0471*       ld hl,(bufferId0)
04156D CD 38 14 04 0472*       call vdu_buff_select
041571 D1          0473*   	pop de ; image height
041572 C1          0474*   	pop bc ; image width
041573 F1          0475*   	pop af ; image type
041574 C3 4D 14 04 0476*   	jp vdu_bmp_create ; will return to caller from there
041578             0477*   
041578             0478*   ; inputs: hl = bufferId; iy = pointer to filename
041578             0479*   vdu_load_buffer_from_file:
041578 22 DD 14 04 0480*       ld (bufferId0),hl
04157C             0481*   
04157C             0482*   ; clear target buffer
04157C CD 0F 15 04 0483*       call vdu_clear_buffer
041580             0484*   
041580             0485*   ; open the file in read mode
041580             0486*   ; Open a file
041580             0487*   ; HLU: Filename
041580             0488*   ;   C: Mode
041580             0489*   ; Returns:
041580             0490*   ;   A: Filehandle, or 0 if couldn't open
041580 FD E5       0491*   	push iy ; pointer to filename
041582 E1          0492*   	pop hl
041583 0E 01       0493*   	ld c,fa_read
041585             0494*       MOSCALL mos_fopen
041585 3E 0A       0001*M1 			LD	A, function
041587 5B CF       0002*M1 			RST.LIL	08h
041589 32 C4 15 04 0495*       ld (@filehandle),a
04158D             0496*   
04158D             0497*   @read_file:
04158D             0498*   ; Read a block of data from a file
04158D             0499*   ;   C: Filehandle
04158D             0500*   ; HLU: Pointer to where to write the data to
04158D             0501*   ; DEU: Number of bytes to read
04158D             0502*   ; Returns:
04158D             0503*   ; DEU: Number of bytes read
04158D 3A C4 15 04 0504*       ld a,(@filehandle)
041591 4F          0505*       ld c,a
041592 21 00 E0 B7 0506*       ld hl,filedata
041596 11 00 20 00 0507*       ld de,8192 ; max we can read into onboard sram at one time
04159A             0508*       MOSCALL mos_fread
04159A 3E 1A       0001*M1 			LD	A, function
04159C 5B CF       0002*M1 			RST.LIL	08h
04159E             0509*   
04159E             0510*   ; test de for zero bytes read
04159E 21 00 00 00 0511*       ld hl,0
0415A2 AF          0512*       xor a ; clear carry
0415A3 ED 52       0513*       sbc hl,de
0415A5 CA BB 15 04 0514*       jp z,@close_file
0415A9             0515*   
0415A9             0516*   ; load a vdu buffer from local memory
0415A9             0517*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0415A9 2A DD 14 04 0518*       ld hl,(bufferId0)
0415AD D5          0519*       push de ; chunksize
0415AE C1          0520*       pop bc
0415AF 11 00 E0 B7 0521*       ld de,filedata
0415B3 CD E3 14 04 0522*       call vdu_load_buffer
0415B7             0523*   
0415B7             0524*   ; read the next block
0415B7 C3 8D 15 04 0525*       jp @read_file
0415BB             0526*   
0415BB             0527*   ; close the file
0415BB             0528*   @close_file:
0415BB 3A C4 15 04 0529*       ld a,(@filehandle)
0415BF             0530*       MOSCALL mos_fclose
0415BF 3E 0B       0001*M1 			LD	A, function
0415C1 5B CF       0002*M1 			RST.LIL	08h
0415C3 C9          0531*       ret ; vdu_load_buffer_from_file
0415C4             0532*   
0415C4 00          0533*   @filehandle: db 0 ; file handle
0415C5 00 00 00    0534*   @fil: dl 0 ; pointer to FIL struct
0415C8             0535*   
0415C8 00 00 00    0536*   @chunkpointer: dl 0 ; pointer to current chunk
0415CB             0537*   
0415CB             0538*   ; File information structure (FILINFO)
0415CB             0539*   @filinfo:
0415CB 00 00 00 00 0540*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0415CF 00 00       0541*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0415D1 00 00       0542*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0415D3 00          0543*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0415D4 00 00 00 00 0544*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0415E1 00 00 00 00 0545*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0416E1             0039        include "vdu_fonts.inc"
0416E1 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
041700             0002*   ; select font
041700             0003*   ; inputs: hl = bufferId, a = font flags
041700             0004*   ; Flags:
041700             0005*   ; Bit	Description
041700             0006*   ; 0	Adjust cursor position to ensure text baseline is aligned
041700             0007*   ;   0: Do not adjust cursor position (best for changing font on a new line)
041700             0008*   ;   1: Adjust cursor position (best for changing font in the middle of a line)
041700             0009*   ; 1-7	Reserved for future use
041700             0010*   ; VDU 23, 0, &95, 0, bufferId; flags: Select font
041700             0011*   vdu_font_select:
041700 22 17 17 04 0012*       ld (@bufferId),hl
041704 32 19 17 04 0013*       ld (@flags),a
041708 21 13 17 04 0014*       ld hl,@cmd
04170C 01 07 00 00 0015*       ld bc,@end-@cmd
041710 5B DF       0016*       rst.lil $18
041712 C9          0017*       ret
041713 17 00 95 00 0018*   @cmd: db 23, 0, 0x95, 0
041717 00 00       0019*   @bufferId: dw 0x0000
041719 00          0020*   @flags: db 0x00
04171A             0021*   @end:
04171A             0022*   
04171A             0023*   ; create font from buffer
04171A             0024*   ; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
04171A             0025*   ; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
04171A             0026*   vdu_font_create:
04171A 22 3F 17 04 0027*       ld (@bufferId),hl
04171E ED 53 41 17 0028*       ld (@width),de ; also loads height
       04          
041723 32 44 17 04 0029*       ld (@flags),a
041727 7A          0030*       ld a,d ; height
041728 32 43 17 04 0031*       ld (@ascent),a ; ascent = height
04172C             0032*   ; consolidate buffer
04172C CD 3B 15 04 0033*       call vdu_consolidate_buffer
041730             0034*   ; create font
041730 21 3B 17 04 0035*       ld hl,@cmd
041734 01 0A 00 00 0036*       ld bc,@end-@cmd
041738 5B DF       0037*       rst.lil $18
04173A C9          0038*       ret
04173B 17 00 95 01 0039*   @cmd: db 23, 0, 0x95, 1
04173F 00 00       0040*   @bufferId: dw 0x0000
041741 00          0041*   @width: db 0x00
041742 00          0042*   @height: db 0x00
041743 00          0043*   @ascent: db 0x00
041744 00          0044*   @flags: db 0x00
041745             0045*   @end:
041745             0046*   
041745             0047*   ; set or adjust font property
041745             0048*   ; inputs: hl = bufferId, a = field, de = value
041745             0049*   ; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
041745             0050*   vdu_font_property:
041745 22 61 17 04 0051*       ld (@bufferId),hl
041749 32 63 17 04 0052*       ld (@field),a
04174D ED 53 64 17 0053*       ld (@value),de
       04          
041752 21 5D 17 04 0054*       ld hl,@cmd
041756 01 09 00 00 0055*       ld bc,@end-@cmd
04175A 5B DF       0056*       rst.lil $18
04175C C9          0057*       ret
04175D 17 00 95 02 0058*   @cmd: db 23, 0, 0x95, 2
041761 00 00       0059*   @bufferId: dw 0x0000
041763 00          0060*   @field: db 0x00
041764 00 00       0061*   @value: dw 0x0000
041766 00          0062*   @end: db 0x00 ; padding
041767             0063*   
041767             0064*   ; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved
041767             0065*   
041767             0066*   ; Clear/Delete font
041767             0067*   ; inputs: hl = bufferId
041767             0068*   ; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
041767             0069*   vdu_font_clear:
041767 22 7A 17 04 0070*       ld (@bufferId),hl
04176B 21 76 17 04 0071*       ld hl,@cmd
04176F 01 06 00 00 0072*       ld bc,@end-@cmd
041773 5B DF       0073*       rst.lil $18
041775 C9          0074*       ret
041776 17 00 95 04 0075*   @cmd: db 23, 0, 0x95, 4
04177A 00 00       0076*   @bufferId: dw 0x0000
04177C 00          0077*   @end: db 0x00 ; padding
04177D             0078*   
04177D             0079*   ; Copy system font to buffer
04177D             0080*   ; inputs: hl = bufferId
04177D             0081*   ; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
04177D             0082*   vdu_font_copy_system:
04177D 22 90 17 04 0083*       ld (@bufferId),hl
041781 21 8C 17 04 0084*       ld hl,@cmd
041785 01 06 00 00 0085*       ld bc,@end-@cmd
041789 5B DF       0086*       rst.lil $18
04178B C9          0087*       ret
04178C 17 00 95 05 0088*   @cmd: db 23, 0, 0x95, 5
041790 00 00       0089*   @bufferId: dw 0x0000
041792 00          0090*   @end: db 0x00 ; padding
041793             0040        include "vdu_plot.inc"
041793 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
041800             0002*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041800             0003*   ; PLOT code 	(Decimal) 	Effect
041800             0004*   ; &00-&07 	0-7 	Solid line, includes both ends
041800             0005*   plot_sl_both: equ 0x00
041800             0006*   
041800             0007*   ; &08-&0F 	8-15 	Solid line, final point omitted
041800             0008*   plot_sl_first: equ 0x08
041800             0009*   
041800             0010*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
041800             0011*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
041800             0012*   
041800             0013*   ; &20-&27 	32-39 	Solid line, first point omitted
041800             0014*   plot_sl_last: equ 0x20
041800             0015*   
041800             0016*   ; &28-&2F 	40-47 	Solid line, both points omitted
041800             0017*   plot_sl_none: equ 0x28
041800             0018*   
041800             0019*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
041800             0020*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
041800             0021*   
041800             0022*   ; &40-&47 	64-71 	Point plot
041800             0023*   plot_pt: equ 0x40
041800             0024*   
041800             0025*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
041800             0026*   plot_lf_lr_non_bg: equ 0x48
041800             0027*   
041800             0028*   ; &50-&57 	80-87 	Triangle fill
041800             0029*   plot_tf: equ 0x50
041800             0030*   
041800             0031*   ; &58-&5F 	88-95 	Line fill right to background §§
041800             0032*   plot_lf_r_bg: equ 0x58
041800             0033*   
041800             0034*   ; &60-&67 	96-103 	Rectangle fill
041800             0035*   plot_rf: equ 0x60
041800             0036*   
041800             0037*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
041800             0038*   plot_lf_lr_fg: equ 0x60
041800             0039*   
041800             0040*   ; &70-&77 	112-119 	Parallelogram fill
041800             0041*   plot_pf: equ 0x70
041800             0042*   
041800             0043*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
041800             0044*   plot_lf_r_non_fg: equ 0x78
041800             0045*   
041800             0046*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
041800             0047*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
041800             0048*   
041800             0049*   ; &90-&97 	144-151 	Circle outline
041800             0050*   plot_co: equ 0x90
041800             0051*   
041800             0052*   ; &98-&9F 	152-159 	Circle fill
041800             0053*   plot_cf: equ 0x98
041800             0054*   
041800             0055*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
041800             0056*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
041800             0057*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
041800             0058*   
041800             0059*   ; &B8-&BF 	184-191 	Rectangle copy/move
041800             0060*   plot_rcm: equ 0xB8
041800             0061*   
041800             0062*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
041800             0063*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
041800             0064*   ; &D0-&D7 	208-215 	Not defined
041800             0065*   ; &D8-&DF 	216-223 	Not defined
041800             0066*   ; &E0-&E7 	224-231 	Not defined
041800             0067*   
041800             0068*   ; &E8-&EF 	232-239 	Bitmap plot §
041800             0069*   plot_bmp: equ 0xE8
041800             0070*   
041800             0071*   ; &F0-&F7 	240-247 	Not defined
041800             0072*   ; &F8-&FF 	248-255 	Not defined
041800             0073*   
041800             0074*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
041800             0075*   ; Agon Console8 VDP 2.2.0
041800             0076*   
041800             0077*   ; Within each group of eight plot codes, the effects are as follows:
041800             0078*   ; Plot code 	Effect
041800             0079*   ; 0 	Move relative
041800             0080*   mv_rel: equ 0
041800             0081*   
041800             0082*   ; 1 	Plot relative in current foreground colour
041800             0083*   dr_rel_fg: equ 1
041800             0084*   
041800             0085*   ; 2 	Not supported (Plot relative in logical inverse colour)
041800             0086*   ; 3 	Plot relative in current background colour
041800             0087*   dr_rel_bg: equ 3
041800             0088*   
041800             0089*   ; 4 	Move absolute
041800             0090*   mv_abs: equ 4
041800             0091*   
041800             0092*   ; 5 	Plot absolute in current foreground colour
041800             0093*   dr_abs_fg: equ 5
041800             0094*   
041800             0095*   ; 6 	Not supported (Plot absolute in logical inverse colour)
041800             0096*   ; 7 	Plot absolute in current background colour
041800             0097*   dr_abs_bg: equ 7
041800             0098*   
041800             0099*   ; Codes 0-3 use the position data provided as part of the command
041800             0100*   ; as a relative position, adding the position given to the current
041800             0101*   ; graphical cursor position. Codes 4-7 use the position data provided
041800             0102*   ; as part of the command as an absolute position, setting the current
041800             0103*   ; graphical cursor position to the position given.
041800             0104*   
041800             0105*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
041800             0106*   ; current pixel colour. These operations cannot currently be supported
041800             0107*   ; by the graphics system the Agon VDP uses, so these codes are not
041800             0108*   ; supported. Support for these codes may be added in a future version
041800             0109*   ; of the VDP firmware.
041800             0110*   
041800             0111*   ; 16 colour palette constants
041800             0112*   c_black: equ 0
041800             0113*   c_red_dk: equ 1
041800             0114*   c_green_dk: equ 2
041800             0115*   c_yellow_dk: equ 3
041800             0116*   c_blue_dk: equ 4
041800             0117*   c_magenta_dk: equ 5
041800             0118*   c_cyan_dk: equ 6
041800             0119*   c_grey: equ 7
041800             0120*   c_grey_dk: equ 8
041800             0121*   c_red: equ 9
041800             0122*   c_green: equ 10
041800             0123*   c_yellow: equ 11
041800             0124*   c_blue: equ 12
041800             0125*   c_magenta: equ 13
041800             0126*   c_cyan: equ 14
041800             0127*   c_white: equ 15
041800             0128*   
041800             0129*   ; VDU 25, mode, x; y;: PLOT command
041800             0130*   ; inputs: a=mode, bc=x0, de=y0
041800             0131*   vdu_plot:
041800 32 1A 18 04 0132*       ld (@mode),a
041804 ED 43 1B 18 0133*       ld (@x0),bc
       04          
041809 ED 53 1D 18 0134*       ld (@y0),de
       04          
04180E 21 19 18 04 0135*   	ld hl,@cmd
041812 01 06 00 00 0136*   	ld bc,@end-@cmd
041816 5B DF       0137*   	rst.lil $18
041818 C9          0138*   	ret
041819 19          0139*   @cmd:   db 25
04181A 00          0140*   @mode:  db 0
04181B 00 00       0141*   @x0: 	dw 0
04181D 00 00       0142*   @y0: 	dw 0
04181F 00          0143*   @end:   db 0 ; extra byte to soak up deu
041820             0144*   
041820             0145*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
041820             0146*   ; &E8-&EF 	232-239 	Bitmap plot §
041820             0147*   ; VDU 25, mode, x; y;: PLOT command
041820             0148*   ; inputs: bc=x0, de=y0
041820             0149*   ; prerequisites: vdu_buff_select
041820             0150*   vdu_plot_bmp:
041820 ED 43 37 18 0151*       ld (@x0),bc
       04          
041825 ED 53 39 18 0152*       ld (@y0),de
       04          
04182A 21 35 18 04 0153*   	ld hl,@cmd
04182E 01 06 00 00 0154*   	ld bc,@end-@cmd
041832 5B DF       0155*   	rst.lil $18
041834 C9          0156*   	ret
041835 19          0157*   @cmd:   db 25
041836 ED          0158*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041837 00 00       0159*   @x0: 	dw 0x0000
041839 00 00       0160*   @y0: 	dw 0x0000
04183B 00          0161*   @end:   db 0x00 ; padding
04183C             0162*   
04183C             0163*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04183C             0164*   ; &E8-&EF 	232-239 	Bitmap plot §
04183C             0165*   ; VDU 25, mode, x; y;: PLOT command
04183C             0166*   ; inputs: bc=x0, de=y0
04183C             0167*   ; USING 16.8 FIXED POINT COORDINATES
04183C             0168*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
04183C             0169*   ;   the fractional portiion of the inputs are truncated
04183C             0170*   ;   leaving only the 16-bit integer portion
04183C             0171*   ; prerequisites: vdu_buff_select
04183C             0172*   vdu_plot_bmp168:
04183C             0173*   ; populate in the reverse of normal to keep the
04183C             0174*   ; inputs from stomping on each other
04183C ED 53 5A 18 0175*       ld (@y0-1),de
       04          
041841 ED 43 58 18 0176*       ld (@x0-1),bc
       04          
041846 3E ED       0177*       ld a,plot_bmp+dr_abs_fg ; 0xED
041848 32 58 18 04 0178*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
04184C 21 57 18 04 0179*   	ld hl,@cmd
041850 01 06 00 00 0180*   	ld bc,@end-@cmd
041854 5B DF       0181*   	rst.lil $18
041856 C9          0182*   	ret
041857 19          0183*   @cmd:   db 25
041858 ED          0184*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
041859 00 00       0185*   @x0: 	dw 0x0000
04185B 00 00       0186*   @y0: 	dw 0x0000
04185D             0187*   @end:  ; no padding required b/c we shifted de right
04185D             0188*   
04185D             0189*   ; draw a filled rectangle
04185D             0190*   vdu_plot_rf:
04185D ED 43 84 18 0191*       ld (@x0),bc
       04          
041862 ED 53 86 18 0192*       ld (@y0),de
       04          
041867 DD 22 8A 18 0193*       ld (@x1),ix
       04          
04186C FD 22 8C 18 0194*       ld (@y1),iy
       04          
041871 3E 19       0195*       ld a,25 ; we have to reload the 2nd plot command
041873 32 88 18 04 0196*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041877 21 82 18 04 0197*   	ld hl,@cmd0
04187B 01 0C 00 00 0198*   	ld bc,@end-@cmd0
04187F 5B DF       0199*   	rst.lil $18
041881 C9          0200*       ret
041882 19          0201*   @cmd0:  db 25 ; plot
041883 04          0202*   @arg0:  db plot_sl_both+mv_abs
041884 00 00       0203*   @x0:    dw 0x0000
041886 00 00       0204*   @y0:    dw 0x0000
041888 19          0205*   @cmd1:  db 25 ; plot
041889 65          0206*   @arg1:  db plot_rf+dr_abs_fg
04188A 00 00       0207*   @x1:    dw 0x0000
04188C 00 00       0208*   @y1:    dw 0x0000
04188E 00          0209*   @end:   db 0x00 ; padding
04188F             0210*   
04188F             0211*   ; draw a filled circle
04188F             0212*   vdu_plot_cf:
04188F ED 43 B6 18 0213*       ld (@x0),bc
       04          
041894 ED 53 B8 18 0214*       ld (@y0),de
       04          
041899 DD 22 BC 18 0215*       ld (@x1),ix
       04          
04189E FD 22 BE 18 0216*       ld (@y1),iy
       04          
0418A3 3E 19       0217*       ld a,25 ; we have to reload the 2nd plot command
0418A5 32 BA 18 04 0218*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0418A9 21 B4 18 04 0219*   	ld hl,@cmd0
0418AD 01 0C 00 00 0220*   	ld bc,@end-@cmd0
0418B1 5B DF       0221*   	rst.lil $18
0418B3 C9          0222*       ret
0418B4 19          0223*   @cmd0:  db 25 ; plot
0418B5 04          0224*   @arg0:  db plot_sl_both+mv_abs
0418B6 00 00       0225*   @x0:    dw 0x0000
0418B8 00 00       0226*   @y0:    dw 0x0000
0418BA 19          0227*   @cmd1:  db 25 ; plot
0418BB 9D          0228*   @arg1:  db plot_cf+dr_abs_fg
0418BC 00 00       0229*   @x1:    dw 0x0000
0418BE 00 00       0230*   @y1:    dw 0x0000
0418C0 00          0231*   @end:   db 0x00 ; padding
0418C1             0041        include "vdu_sprites.inc"
0418C1 FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
041900             0002*   ; ; https://github.com/AgonConsole8/agon-docs/blob/main/VDP---Bitmaps-API.md
041900             0003*   ; the VDP can support up to 256 sprites. They must be defined
041900             0004*   ; contiguously, and so the first sprite is sprite 0.
041900             0005*   ; (In contrast, bitmaps can have any ID from 0 to 65534.)
041900             0006*   ; Once a selection of sprites have been defined, you can activate
041900             0007*   ; them using the VDU 23, 27, 7, n command, where n is the number
041900             0008*   ; of sprites to activate. This will activate the first n sprites,
041900             0009*   ; starting with sprite 0. All sprites from 0 to n-1 must be defined.
041900             0010*   
041900             0011*   ; A single sprite can have multiple "frames", referring to
041900             0012*   ; different bitmaps.
041900             0013*   ; (These bitmaps do not need to be the same size.)
041900             0014*   ; This allows a sprite to include an animation sequence,
041900             0015*   ; which can be stepped through one frame at a time, or picked
041900             0016*   ; in any order.
041900             0017*   
041900             0018*   ; Any format of bitmap can be used as a sprite frame. It should
041900             0019*   ; be noted however that "native" format bitmaps are not
041900             0020*   ; recommended for use as sprite frames, as they cannot get
041900             0021*   ; erased from the screen. (As noted above, the "native" bitmap
041900             0022*   ; format is not really intended for general use.) This is part
041900             0023*   ; of why from Agon Console8 VDP 2.6.0 bitmaps captured from the
041900             0024*   ; screen are now stored in RGBA2222 format.
041900             0025*   
041900             0026*   ; An "active" sprite can be hidden, so it will stop being drawn,
041900             0027*   ; and then later shown again.
041900             0028*   
041900             0029*   ; Moving sprites around the screen is done by changing the
041900             0030*   ; position of the sprite. This can be done either by setting
041900             0031*   ; the absolute position of the sprite, or by moving the sprite
041900             0032*   ; by a given number of pixels. (Sprites are positioned using
041900             0033*   ; pixel coordinates, and not by the logical OS coordinate system.)
041900             0034*   ; In the current sprite system, sprites will not update their
041900             0035*   ; position on-screen until either another drawing operation is
041900             0036*   ; performed or an explicit VDU 23, 27, 15 command is performed.
041900             0037*   
041900             0038*   ; VDU 23, 27, 4, n: Select sprite n
041900             0039*   ; inputs: a is the 8-bit sprite id
041900             0040*   vdu_sprite_select:
041900 32 12 19 04 0041*       ld (@sprite),a
041904 21 0F 19 04 0042*       ld hl,@cmd
041908 01 04 00 00 0043*       ld bc,@end-@cmd
04190C 5B DF       0044*       rst.lil $18
04190E C9          0045*       ret
04190F 17 1B 04    0046*   @cmd:    db 23,27,4
041912 00          0047*   @sprite: db 0x00
041913             0048*   @end:
041913             0049*   
041913             0050*   ; VDU 23, 27, 5: Clear frames in current sprite
041913             0051*   ; inputs: none
041913             0052*   ; prerequisites: vdu_sprite_select
041913             0053*   vdu_sprite_clear_frames:
041913 21 1E 19 04 0054*       ld hl,@cmd
041917 01 03 00 00 0055*       ld bc,@end-@cmd
04191B 5B DF       0056*       rst.lil $18
04191D C9          0057*       ret
04191E 17 1B 05    0058*   @cmd: db 23,27,5
041921             0059*   @end:
041921             0060*   
041921             0061*   ; VDU 23, 27, 6, n: Add bitmap n as a frame to current sprite (where bitmap's buffer ID is 64000+n)
041921             0062*   ; inputs: a is the 8-bit bitmap number
041921             0063*   ; prerequisites: vdu_sprite_select
041921             0064*   vdu_sprite_add_bmp:
041921 32 33 19 04 0065*       ld (@bmp),a
041925 21 30 19 04 0066*       ld hl,@cmd
041929 01 04 00 00 0067*       ld bc,@end-@cmd
04192D 5B DF       0068*       rst.lil $18
04192F C9          0069*       ret
041930 17 1B 06    0070*   @cmd: db 23,27,6
041933 00          0071*   @bmp: db 0x00
041934             0072*   @end:
041934             0073*   
041934             0074*   ; VDU 23, 27, 7, n: Activate n sprites
041934             0075*   ; inputs: a is the number of sprites to activate
041934             0076*   ; prerequisites: each sprite activated must have at least one frame attached to it
041934             0077*   vdu_sprite_activate:
041934 32 46 19 04 0078*       ld (@num),a
041938 21 43 19 04 0079*       ld hl,@cmd
04193C 01 04 00 00 0080*       ld bc,@end-@cmd
041940 5B DF       0081*       rst.lil $18
041942 C9          0082*       ret
041943 17 1B 07    0083*   @cmd: db 23,27,7
041946 00          0084*   @num: db 0x00
041947             0085*   @end:
041947             0086*   
041947             0087*   ; VDU 23, 27, 8: Select next frame of current sprite
041947             0088*   ; inputs: none
041947             0089*   ; prerequisites: vdu_sprite_select
041947             0090*   vdu_sprite_next_frame:
041947 21 52 19 04 0091*       ld hl,@cmd
04194B 01 03 00 00 0092*       ld bc,@end-@cmd
04194F 5B DF       0093*       rst.lil $18
041951 C9          0094*       ret
041952 17 1B 08    0095*   @cmd: db 23,27,8
041955             0096*   @end:
041955             0097*   
041955             0098*   ; VDU 23, 27, 9: Select previous frame of current sprite
041955             0099*   ; inputs: none
041955             0100*   ; prerequisites: vdu_sprite_select
041955             0101*   vdu_sprite_prev_frame:
041955 21 60 19 04 0102*       ld hl,@cmd
041959 01 03 00 00 0103*       ld bc,@end-@cmd
04195D 5B DF       0104*       rst.lil $18
04195F C9          0105*       ret
041960 17 1B 09    0106*   @cmd: db 23,27,9
041963             0107*   @end:
041963             0108*   
041963             0109*   ; VDU 23, 27, 10, n: Select the nth frame of current sprite
041963             0110*   ; inputs: a is frame number to select
041963             0111*   ; prerequisites: vdu_sprite_select
041963             0112*   vdu_sprite_select_frame:
041963 32 75 19 04 0113*       ld (@frame),a
041967 21 72 19 04 0114*       ld hl,@cmd
04196B 01 04 00 00 0115*       ld bc,@end-@cmd
04196F 5B DF       0116*       rst.lil $18
041971 C9          0117*       ret
041972 17 1B 0A    0118*   @cmd:    db 23,27,10
041975 00          0119*   @frame:  db 0x00
041976             0120*   @end:
041976             0121*   
041976             0122*   ; VDU 23, 27, 11: Show current sprite
041976             0123*   ; inputs: none
041976             0124*   ; prerequisites: vdu_sprite_select
041976             0125*   vdu_sprite_show:
041976 21 81 19 04 0126*       ld hl,@cmd
04197A 01 03 00 00 0127*       ld bc,@end-@cmd
04197E 5B DF       0128*       rst.lil $18
041980 C9          0129*       ret
041981 17 1B 0B    0130*   @cmd: db 23,27,11
041984             0131*   @end:
041984             0132*   
041984             0133*   ; VDU 23, 27, 12: Hide current sprite
041984             0134*   ; inputs: none
041984             0135*   ; prerequisites: vdu_sprite_select
041984             0136*   vdu_sprite_hide:
041984 21 8F 19 04 0137*       ld hl,@cmd
041988 01 03 00 00 0138*       ld bc,@end-@cmd
04198C 5B DF       0139*       rst.lil $18
04198E C9          0140*       ret
04198F 17 1B 0C    0141*   @cmd: db 23,27,12
041992             0142*   @end:
041992             0143*   
041992             0144*   ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
041992             0145*   ; inputs: bc is x coordinate, de is y coordinate
041992             0146*   ; prerequisites: vdu_sprite_select
041992             0147*   vdu_sprite_move_abs:
041992 ED 43 AA 19 0148*       ld (@xpos),bc
       04          
041997 ED 53 AC 19 0149*       ld (@ypos),de
       04          
04199C 21 A7 19 04 0150*       ld hl,@cmd
0419A0 01 07 00 00 0151*       ld bc,@end-@cmd
0419A4 5B DF       0152*       rst.lil $18
0419A6 C9          0153*       ret
0419A7 17 1B 0D    0154*   @cmd:  db 23,27,13
0419AA 00 00       0155*   @xpos: dw 0x0000
0419AC 00 00       0156*   @ypos: dw 0x0000
0419AE 00          0157*   @end:  db 0x00 ; padding
0419AF             0158*   
0419AF             0159*   ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0419AF             0160*   ; inputs: bc is x coordinate, de is y coordinate
0419AF             0161*   ; prerequisites: vdu_sprite_select
0419AF             0162*   vdu_sprite_move_rel:
0419AF ED 43 C7 19 0163*       ld (@dx),bc
       04          
0419B4 ED 53 C9 19 0164*       ld (@dy),de
       04          
0419B9 21 C4 19 04 0165*       ld hl,@cmd
0419BD 01 07 00 00 0166*       ld bc,@end-@cmd
0419C1 5B DF       0167*       rst.lil $18
0419C3 C9          0168*       ret
0419C4 17 1B 0E    0169*   @cmd: db 23,27,14
0419C7 00 00       0170*   @dx:  dw 0x0000
0419C9 00 00       0171*   @dy:  dw 0x0000
0419CB 00          0172*   @end: db 0x00 ; padding
0419CC             0173*   
0419CC             0174*   ; VDU 23, 27, 13, x; y;: Move current sprite to pixel position x, y
0419CC             0175*   ; USING 16.8 FIXED POINT COORDINATES
0419CC             0176*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
0419CC             0177*   ;   the fractional portiion of the inputs are truncated
0419CC             0178*   ;   leaving only the 16-bit integer portion
0419CC             0179*   ; prerequisites: vdu_sprite_select
0419CC             0180*   vdu_sprite_move_abs168:
0419CC             0181*   ; offset inputs by the gfx origin
0419CC             0182*   ; y coordinate
0419CC 21 00 00 00 0183*       ld hl,origin_top*256
0419D0 19          0184*       add hl,de
0419D1 22 F3 19 04 0185*       ld (@ypos-1),hl
0419D5             0186*   ; x coordinate
0419D5 21 00 80 00 0187*       ld hl,origin_left*256
0419D9 09          0188*       add hl,bc
0419DA 22 F1 19 04 0189*       ld (@xpos-1),hl
0419DE             0190*   ; prepare vdu command
0419DE 3E 0D       0191*       ld a,13       ; restore the final byte of the command
0419E0 32 F1 19 04 0192*       ld (@cmd+2),a ; string that got stomped on by bcu
0419E4 21 EF 19 04 0193*       ld hl,@cmd
0419E8 01 07 00 00 0194*       ld bc,@end-@cmd
0419EC 5B DF       0195*       rst.lil $18
0419EE C9          0196*       ret
0419EF 17 1B 0D    0197*   @cmd:  db 23,27,13
0419F2 00 00       0198*   @xpos: dw 0x0000
0419F4 00 00       0199*   @ypos: dw 0x0000
0419F6             0200*   @end:  ; no padding required b/c we shifted de right
0419F6             0201*   
0419F6             0202*   ; VDU 23, 27, 14, x; y;: Move current sprite by x, y pixels
0419F6             0203*   ; USING 16.8 FIXED POINT COORDINATES
0419F6             0204*   ; inputs: ub.c is dx, ud.e is dy
0419F6             0205*   ;   the fractional portiion of the inputs are truncated
0419F6             0206*   ;   leaving only the 16-bit integer portion
0419F6             0207*   ; prerequisites: vdu_sprite_select
0419F6             0208*   vdu_sprite_move_rel168:
0419F6             0209*   ; populate in the reverse of normal to keep the
0419F6             0210*   ; inputs from stomping on each other
0419F6 ED 53 15 1A 0211*       ld (@dy-1),de
       04          
0419FB ED 43 13 1A 0212*       ld (@dx-1),bc
       04          
041A00 3E 0E       0213*       ld a,14       ; restore the final byte of the command
041A02 32 13 1A 04 0214*       ld (@cmd+2),a ; string that got stomped on by bcu
041A06 21 11 1A 04 0215*       ld hl,@cmd
041A0A 01 07 00 00 0216*       ld bc,@end-@cmd
041A0E 5B DF       0217*       rst.lil $18
041A10 C9          0218*       ret
041A11 17 1B 0E    0219*   @cmd:  db 23,27,14
041A14 00 00       0220*   @dx: dw 0x0000
041A16 00 00       0221*   @dy: dw 0x0000
041A18             0222*   @end:  ; no padding required b/c we shifted de right
041A18             0223*   
041A18             0224*   ; VDU 23, 27, 15: Update the sprites in the GPU
041A18             0225*   ; inputs: none
041A18             0226*   vdu_sprite_update:
041A18 21 23 1A 04 0227*       ld hl,@cmd
041A1C 01 03 00 00 0228*       ld bc,@end-@cmd
041A20 5B DF       0229*       rst.lil $18
041A22 C9          0230*       ret
041A23 17 1B 0F    0231*   @cmd: db 23,27,15
041A26             0232*   @end:
041A26             0233*   
041A26             0234*   ; VDU 23, 27, 16: Reset bitmaps and sprites and clear all data
041A26             0235*   ; inputs: none
041A26             0236*   vdu_sprite_bmp_reset:
041A26 21 31 1A 04 0237*       ld hl,@cmd
041A2A 01 03 00 00 0238*       ld bc,@end-@cmd
041A2E 5B DF       0239*       rst.lil $18
041A30 C9          0240*       ret
041A31 17 1B 10    0241*   @cmd: db 23,27,16
041A34             0242*   @end:
041A34             0243*   
041A34             0244*   ; VDU 23, 27, 17: Reset sprites (only) and clear all data
041A34             0245*   ; inputs: none
041A34             0246*   vdu_sprite_reset:
041A34 21 3F 1A 04 0247*       ld hl,@cmd
041A38 01 03 00 00 0248*       ld bc,@end-@cmd
041A3C 5B DF       0249*       rst.lil $18
041A3E C9          0250*       ret
041A3F 17 1B 11    0251*   @cmd: db 23,27,17
041A42             0252*   @end:
041A42             0253*   
041A42             0254*   ; VDU 23, 27, 18, n: Set the current sprite GCOL paint mode to n **
041A42             0255*   ; inputs: a is the GCOL paint mode
041A42             0256*   ; prerequisites: vdu_sprite_select
041A42             0257*   vdu_sprite_set_gcol:
041A42 32 54 1A 04 0258*       ld (@mode),a
041A46 21 51 1A 04 0259*       ld hl,@cmd
041A4A 01 04 00 00 0260*       ld bc,@end-@cmd
041A4E 5B DF       0261*       rst.lil $18
041A50 C9          0262*       ret
041A51 17 1B 12    0263*   @cmd:  db 23,27,18
041A54 00          0264*   @mode: db 0x00
041A55             0265*   @end:
041A55             0266*   
041A55             0267*   ; VDU 23, 27, &26, n;: Add bitmap n as a frame to current sprite using a 16-bit buffer ID
041A55             0268*   ; inputs: hl=bufferId
041A55             0269*   ; prerequisites: vdu_sprite_select
041A55             0270*   vdu_sprite_add_buff:
041A55 22 67 1A 04 0271*       ld (@bufferId),hl
041A59 21 64 1A 04 0272*       ld hl,@cmd
041A5D 01 05 00 00 0273*       ld bc,@end-@cmd
041A61 5B DF       0274*       rst.lil $18
041A63 C9          0275*       ret
041A64 17 1B 26    0276*   @cmd:      db 23,27,0x26
041A67 00 00       0277*   @bufferId: dw 0x0000
041A69 00          0278*   @end:      db 0x00 ; padding
041A6A             0042    
041A6A             0043    ; APPLICATION INCLUDES
041A6A             0044        include "collisions.inc"
041A6A             0001*   ; ====== COLLISION DETECTION ======
041A6A             0002*   ; --- constants ---
041A6A             0003*   ; sprite_collisions flags
041A6A             0004*   collides_with_player: equ 0
041A6A             0005*   collides_with_laser: equ 1
041A6A             0006*   sprite_alive: equ 6 ; set when sprite is alive
041A6A             0007*   sprite_just_died: equ 7 ; set when sprite just died
041A6A             0008*   
041A6A             0009*   ; TODO: make these bit numbers instead of masks
041A6A             0010*   collide_top: equ %00001000
041A6A             0011*   collide_bottom: equ %00000100
041A6A             0012*   collide_left: equ %00000010
041A6A             0013*   collide_right: equ %00000001
041A6A             0014*   ; END TODO
041A6A             0015*   
041A6A             0016*   ; this routine detects collisions between two collidable objects,
041A6A             0017*   ; which can include sprites, active tiles, or any screen coordinate
041A6A             0018*   ; which has been set up with a sprite table structure that includes dim_x
041A6A             0019*   ; representing the radius of the collidable object
041A6A             0020*   ; inputs: ix and iy point to the colliding objects' sprite table records
041A6A             0021*   ; outputs: uh.l = distance - sum of radii
041A6A             0022*   ;          zero flag set or sign flag negative if collision detected
041A6A             0023*   ;          dx168 and dy168 are also populated with the signed displacements
041A6A             0024*   ; destroys: everything except indexes
041A6A             0025*   check_collision:
041A6A             0026*   ; compute dx = x1-x0
041A6A DD 27 0B    0027*       ld hl,(ix+sprite_x)
041A6D FD 17 0B    0028*       ld de,(iy+sprite_x)
041A70 AF          0029*       xor a ; clear carry
041A71 ED 52       0030*       sbc hl,de
041A73 22 2E 08 04 0031*       ld (dx168),hl ; dx to scratch
041A77             0032*   ; compute dy = y1-y0
041A77 DD 27 0E    0033*       ld hl,(ix+sprite_y)
041A7A FD 17 0E    0034*       ld de,(iy+sprite_y)
041A7D AF          0035*       xor a ; clear carry
041A7E ED 52       0036*       sbc hl,de ; hl = dy
041A80 22 34 08 04 0037*       ld (dy168),hl ; dy to scratch
041A84             0038*   ; compute euclidean distance between centers
041A84 CD 3A 08 04 0039*       call distance168 ; uh.l = distance
041A88             0040*   ; check for overlap by summing half the radii
041A88 DD 7E 09    0041*       ld a,(ix+sprite_dim_x)
041A8B CB 3F       0042*       srl a ; divide by 2
041A8D FD 5E 09    0043*       ld e,(iy+sprite_dim_x)
041A90 CB 3B       0044*       srl e ; divide by 2
041A92 83          0045*       add a,e
041A93 11 00 00 00 0046*       ld de,0 ; clear deu and e
041A97 57          0047*       ld d,a ; ud.e = sum of radii
041A98 B7          0048*       or a ; clear carry
041A99 ED 52       0049*       sbc hl,de ; uh.l = distance - sum of radii
041A9B C9          0050*       ret
041A9C             0051*   ; end check_collision
041A9C             0045        include "enemies.inc"
041A9C 04          0001*   max_enemy_sprites: db 4
041A9D             0002*   
041A9D             0003*   ; sprite_type
041A9D             0004*   enemy_dead: equ 0
041A9D             0005*   enemy_seeker: equ 1
041A9D             0006*   enemy_medium: equ 2
041A9D             0007*   enemy_large: equ 3
041A9D             0008*   landing_pad: equ 4
041A9D             0009*   laser_turret: equ 5
041A9D             0010*   fireballs: equ 6
041A9D             0011*   explosion: equ 7
041A9D             0012*   
041A9D             0013*   move_enemies:
041A9D             0014*   ; are there any active enemies or explosions?
041A9D 3A 70 41 04 0015*       ld a,(table_active_sprites)
041AA1 A7          0016*       and a ; will be zero if no alive enemies or explosions
041AA2 C2 AF 1A 04 0017*       jp nz,@they_live
041AA6 21 AA 43 04 0018*       ld hl,enemies_dead
041AAA 22 A7 43 04 0019*       ld (enemies_state),hl
041AAE C9          0020*       ret
041AAF             0021*   @they_live:
041AAF             0022*   ; initialize pointers and loop counter
041AAF FD 21 DD 3E 0023*       ld iy,table_base ; set iy to first record in table
       04          
041AB4 06 10       0024*       ld b,table_max_records ; loop counter
041AB6             0025*   @move_loop:
041AB6 FD 22 6D 41 0026*       ld (table_pointer),iy ; update table pointer
       04          
041ABB C5          0027*       push bc ; backup loop counter
041ABC             0028*   ; check sprite_type to see if sprite is active
041ABC FD 7E 01    0029*       ld a,(iy+sprite_type)
041ABF A7          0030*       and a ; if zero, sprite is dead
041AC0 CA F3 1A 04 0031*       jp z,@next_record ; ... and we skip to next record
041AC4             0032*   ; otherwise we prepare to move the sprite
041AC4 FD 7E 00    0033*       ld a,(iy+sprite_id) ; get spriteId
041AC7 CD 00 19 04 0034*       call vdu_sprite_select ; select sprite
041ACB FD 27 05    0035*       ld hl,(iy+sprite_move_program) ; load the behavior subroutine address
041ACE             0036*       CALL_HL
041ACE 01 D4 1A 04 0001*M1     ld bc,$+6 ; Address of first instruction after the jump
041AD2 C5          0002*M1     push bc ; which constitutes the return address
041AD3 E9          0003*M1     jp (hl) ; Jump to the address in HL
041AD4             0037*   ; move_enemies_loop_return: return from behavior subroutines
041AD4 FD 2A 6D 41 0038*       ld iy,(table_pointer) ; get back table pointer
       04          
041AD9             0039*   ; now we check results of all the moves
041AD9 FD CB 08 7E 0040*       bit sprite_just_died,(iy+sprite_collisions)
041ADD CA E9 1A 04 0041*       jp z,@draw_sprite ; if not dead, draw sprite
041AE1 CD B9 41 04 0042*       call table_deactivate_sprite
041AE5 C3 F3 1A 04 0043*       jp @next_record ; and to the next record
041AE9             0044*   @draw_sprite:
041AE9 FD 07 0B    0045*       ld bc,(iy+sprite_x)
041AEC FD 17 0E    0046*       ld de,(iy+sprite_y)
041AEF CD CC 19 04 0047*       call vdu_sprite_move_abs168
041AF3             0048*   ; fall through to @next_record
041AF3             0049*   @next_record:
041AF3 ED 33 29    0050*       lea iy,iy+table_bytes_per_record
041AF6 AF          0051*       xor a ; clears carry flag
041AF7 32 71 41 04 0052*       ld (sprite_screen_edge),a ; clear screen edge collision flag
041AFB C1          0053*       pop bc ; get back our loop counter
041AFC 10 B8       0054*       djnz @move_loop ; loop until we've checked all the records
041AFE C9          0055*       ret ; and we're out
041AFF             0056*   
041AFF             0057*   ; ; ######### SPRITE BEHAVIOR ROUTINES #########
041AFF             0058*   ; ; each sprite in the table must have one of these defined
041AFF             0059*   ; ; but they need not be unique to a particular sprite
041AFF             0060*   ; ; these are jumped to from move_enemies_do_program,but could come from other places
041AFF             0061*   ; ; and have the option but not obligation to go back to move_enemies_loop_return
041AFF             0062*   ; ; but they can call anything they want between those two endpoints
041AFF             0063*   ; move_programs: ; bookmark in case we want to know the first address of the first subroutine
041AFF             0064*   
041AFF             0065*   check_enemy_player_collisions:
041AFF             0066*   ; check for collisions with player
041AFF DD 21 C2 3C 0067*       ld ix,player_start_variables
       04          
041B04 DD CB 08 76 0068*       bit sprite_alive,(ix+sprite_collisions)
041B08 C8          0069*       ret z ; player dead, no collision
041B09 CD 6A 1A 04 0070*       call check_collision
041B0D F0          0071*       ret p ; no collision
041B0E C3 39 1B 04 0072*       jp enemy_kill
041B12             0073*   ; end move_enemy_seeker
041B12             0074*   orientation_to_player:
041B12 FD 2A 6D 41 0075*       ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
041B17 FD 07 0B    0076*       ld bc,(iy+sprite_x)
041B1A FD 17 0E    0077*       ld de,(iy+sprite_y)
041B1D DD 2A CD 3C 0078*       ld ix,(player_x)
       04          
041B22 FD 2A D0 3C 0079*       ld iy,(player_y)
       04          
041B27 CD 13 08 04 0080*       call dxy168
041B2B C5          0081*       push bc
041B2C D5          0082*       push de
041B2D CD 9A 08 04 0083*       call atan2_168fast
041B31 D1          0084*       pop de
041B32 C1          0085*       pop bc
041B33 FD 2A 6D 41 0086*       ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
041B38 C9          0087*       ret
041B39             0088*   
041B39             0089*   ; this routine vanquishes the enemy sprite
041B39             0090*   ; inputs: table_pointer set to sprite record
041B39             0091*   ; destroys: everything except index registers
041B39             0092*   ; returns: an incandescent ball of debris and gas
041B39             0093*   enemy_kill:
041B39 FD 2A 6D 41 0094*       ld iy,(table_pointer); TODO: see if we can get IY to land here with the proper value
       04          
041B3E             0095*   ; tally up points
041B3E 2A BE 3C 04 0096*       ld hl,(player_score)
041B42 01 00 00 00 0097*       ld bc,0 ; clear bcu
041B46 FD 4E 24    0098*       ld c,(iy+sprite_points)
041B49 09          0099*       add hl,bc
041B4A 22 BE 3C 04 0100*       ld (player_score),hl
041B4E FD CB 08 FE 0101*       set sprite_just_died,(iy+sprite_collisions)
041B52 C9          0102*       ret
041B53             0103*   ; end enemy_kill
041B53             0104*   
041B53             0105*   ; TODO: implement this
041B53             0106*   scare_ghosts:
041B53 C9          0107*       ret
041B54             0046        include "images_sprites.inc"
041B54             0001*   ; Generated by beegee747/build/scripts/build_99_asm_img_load.py
041B54             0002*   
041B54             0003*   sprites_num_images: equ 113
041B54             0004*   
041B54             0005*   ; buffer_ids:
041B54             0006*   BUF_BLINKY_0: equ 256
041B54             0007*   BUF_BLINKY_1: equ 257
041B54             0008*   BUF_BLINKY_2: equ 258
041B54             0009*   BUF_BLINKY_3: equ 259
041B54             0010*   BUF_BLINKY_4: equ 260
041B54             0011*   BUF_BLINKY_5: equ 261
041B54             0012*   BUF_BLINKY_6: equ 262
041B54             0013*   BUF_BLINKY_7: equ 263
041B54             0014*   BUF_CLYDE_0: equ 264
041B54             0015*   BUF_CLYDE_1: equ 265
041B54             0016*   BUF_CLYDE_2: equ 266
041B54             0017*   BUF_CLYDE_3: equ 267
041B54             0018*   BUF_CLYDE_4: equ 268
041B54             0019*   BUF_CLYDE_5: equ 269
041B54             0020*   BUF_CLYDE_6: equ 270
041B54             0021*   BUF_CLYDE_7: equ 271
041B54             0022*   BUF_FRUIT_0: equ 272
041B54             0023*   BUF_FRUIT_1: equ 273
041B54             0024*   BUF_FRUIT_2: equ 274
041B54             0025*   BUF_FRUIT_3: equ 275
041B54             0026*   BUF_FRUIT_4: equ 276
041B54             0027*   BUF_FRUIT_5: equ 277
041B54             0028*   BUF_FRUIT_6: equ 278
041B54             0029*   BUF_FRUIT_7: equ 279
041B54             0030*   BUF_INKY_0: equ 280
041B54             0031*   BUF_INKY_1: equ 281
041B54             0032*   BUF_INKY_2: equ 282
041B54             0033*   BUF_INKY_3: equ 283
041B54             0034*   BUF_INKY_4: equ 284
041B54             0035*   BUF_INKY_5: equ 285
041B54             0036*   BUF_INKY_6: equ 286
041B54             0037*   BUF_INKY_7: equ 287
041B54             0038*   BUF_MAZE_PELLETS_00: equ 288
041B54             0039*   BUF_MAZE_PELLETS_01: equ 289
041B54             0040*   BUF_MAZE_PELLETS_02: equ 290
041B54             0041*   BUF_PAC_BIG_00_00: equ 291
041B54             0042*   BUF_PAC_BIG_00_01: equ 292
041B54             0043*   BUF_PAC_BIG_00_02: equ 293
041B54             0044*   BUF_PAC_DED_00_00: equ 294
041B54             0045*   BUF_PAC_DED_00_01: equ 295
041B54             0046*   BUF_PAC_DED_00_02: equ 296
041B54             0047*   BUF_PAC_DED_00_03: equ 297
041B54             0048*   BUF_PAC_DED_00_04: equ 298
041B54             0049*   BUF_PAC_DED_00_05: equ 299
041B54             0050*   BUF_PAC_DED_00_06: equ 300
041B54             0051*   BUF_PAC_DED_00_07: equ 301
041B54             0052*   BUF_PAC_DED_00_08: equ 302
041B54             0053*   BUF_PAC_DED_00_09: equ 303
041B54             0054*   BUF_PAC_DED_00_10: equ 304
041B54             0055*   BUF_PAC_LIV_00_00: equ 305
041B54             0056*   BUF_PAC_MAN_00_00: equ 306
041B54             0057*   BUF_PAC_MAN_00_01: equ 307
041B54             0058*   BUF_PAC_MAN_00_02: equ 308
041B54             0059*   BUF_PAC_MAN_01_00: equ 309
041B54             0060*   BUF_PAC_MAN_01_01: equ 310
041B54             0061*   BUF_PAC_MAN_01_02: equ 311
041B54             0062*   BUF_PAC_MAN_02_00: equ 312
041B54             0063*   BUF_PAC_MAN_02_01: equ 313
041B54             0064*   BUF_PAC_MAN_02_02: equ 314
041B54             0065*   BUF_PAC_MAN_03_00: equ 315
041B54             0066*   BUF_PAC_MAN_03_01: equ 316
041B54             0067*   BUF_PAC_MAN_03_02: equ 317
041B54             0068*   BUF_PINKY_0: equ 318
041B54             0069*   BUF_PINKY_1: equ 319
041B54             0070*   BUF_PINKY_2: equ 320
041B54             0071*   BUF_PINKY_3: equ 321
041B54             0072*   BUF_PINKY_4: equ 322
041B54             0073*   BUF_PINKY_5: equ 323
041B54             0074*   BUF_PINKY_6: equ 324
041B54             0075*   BUF_PINKY_7: equ 325
041B54             0076*   BUF_REVERSE_0: equ 326
041B54             0077*   BUF_REVERSE_1: equ 327
041B54             0078*   BUF_REVERSE_2: equ 328
041B54             0079*   BUF_REVERSE_3: equ 329
041B54             0080*   BUF_REVERSE_4: equ 330
041B54             0081*   BUF_REVERSE_5: equ 331
041B54             0082*   BUF_REVERSE_6: equ 332
041B54             0083*   BUF_REVERSE_7: equ 333
041B54             0084*   BUF_TILE_00: equ 334
041B54             0085*   BUF_TILE_01: equ 335
041B54             0086*   BUF_TILE_02: equ 336
041B54             0087*   BUF_TILE_03: equ 337
041B54             0088*   BUF_TILE_04: equ 338
041B54             0089*   BUF_TILE_05: equ 339
041B54             0090*   BUF_TILE_06: equ 340
041B54             0091*   BUF_TILE_07: equ 341
041B54             0092*   BUF_TILE_08: equ 342
041B54             0093*   BUF_TILE_09: equ 343
041B54             0094*   BUF_TILE_10: equ 344
041B54             0095*   BUF_TILE_11: equ 345
041B54             0096*   BUF_TILE_12: equ 346
041B54             0097*   BUF_TILE_13: equ 347
041B54             0098*   BUF_TILE_14: equ 348
041B54             0099*   BUF_TILE_15: equ 349
041B54             0100*   BUF_TILE_16: equ 350
041B54             0101*   BUF_TILE_17: equ 351
041B54             0102*   BUF_TILE_18: equ 352
041B54             0103*   BUF_TILE_19: equ 353
041B54             0104*   BUF_TILE_20: equ 354
041B54             0105*   BUF_TILE_21: equ 355
041B54             0106*   BUF_TILE_22: equ 356
041B54             0107*   BUF_TILE_23: equ 357
041B54             0108*   BUF_TILE_24: equ 358
041B54             0109*   BUF_TILE_25: equ 359
041B54             0110*   BUF_TILE_26: equ 360
041B54             0111*   BUF_TILE_27: equ 361
041B54             0112*   BUF_TILE_28: equ 362
041B54             0113*   BUF_TILE_29: equ 363
041B54             0114*   BUF_TILE_30: equ 364
041B54             0115*   BUF_TILE_31: equ 365
041B54             0116*   BUF_TILE_32: equ 366
041B54             0117*   BUF_TILE_33: equ 367
041B54             0118*   BUF_TILE_34: equ 368
041B54             0119*   
041B54             0120*   sprites_image_list: ; type; width; height; filename; bufferId:
041B54 01 00 00 10 0121*   	dl 1, 16, 16, 256, fn_blinky_0, 256
       00 00 10 00 
       00 00 01 00 
       46 23 04 00 
       01 00       
041B66 01 00 00 10 0122*   	dl 1, 16, 16, 256, fn_blinky_1, 257
       00 00 10 00 
       00 00 01 00 
       5D 23 04 01 
       01 00       
041B78 01 00 00 10 0123*   	dl 1, 16, 16, 256, fn_blinky_2, 258
       00 00 10 00 
       00 00 01 00 
       74 23 04 02 
       01 00       
041B8A 01 00 00 10 0124*   	dl 1, 16, 16, 256, fn_blinky_3, 259
       00 00 10 00 
       00 00 01 00 
       8B 23 04 03 
       01 00       
041B9C 01 00 00 10 0125*   	dl 1, 16, 16, 256, fn_blinky_4, 260
       00 00 10 00 
       00 00 01 00 
       A2 23 04 04 
       01 00       
041BAE 01 00 00 10 0126*   	dl 1, 16, 16, 256, fn_blinky_5, 261
       00 00 10 00 
       00 00 01 00 
       B9 23 04 05 
       01 00       
041BC0 01 00 00 10 0127*   	dl 1, 16, 16, 256, fn_blinky_6, 262
       00 00 10 00 
       00 00 01 00 
       D0 23 04 06 
       01 00       
041BD2 01 00 00 10 0128*   	dl 1, 16, 16, 256, fn_blinky_7, 263
       00 00 10 00 
       00 00 01 00 
       E7 23 04 07 
       01 00       
041BE4 01 00 00 10 0129*   	dl 1, 16, 16, 256, fn_clyde_0, 264
       00 00 10 00 
       00 00 01 00 
       FE 23 04 08 
       01 00       
041BF6 01 00 00 10 0130*   	dl 1, 16, 16, 256, fn_clyde_1, 265
       00 00 10 00 
       00 00 01 00 
       14 24 04 09 
       01 00       
041C08 01 00 00 10 0131*   	dl 1, 16, 16, 256, fn_clyde_2, 266
       00 00 10 00 
       00 00 01 00 
       2A 24 04 0A 
       01 00       
041C1A 01 00 00 10 0132*   	dl 1, 16, 16, 256, fn_clyde_3, 267
       00 00 10 00 
       00 00 01 00 
       40 24 04 0B 
       01 00       
041C2C 01 00 00 10 0133*   	dl 1, 16, 16, 256, fn_clyde_4, 268
       00 00 10 00 
       00 00 01 00 
       56 24 04 0C 
       01 00       
041C3E 01 00 00 10 0134*   	dl 1, 16, 16, 256, fn_clyde_5, 269
       00 00 10 00 
       00 00 01 00 
       6C 24 04 0D 
       01 00       
041C50 01 00 00 10 0135*   	dl 1, 16, 16, 256, fn_clyde_6, 270
       00 00 10 00 
       00 00 01 00 
       82 24 04 0E 
       01 00       
041C62 01 00 00 10 0136*   	dl 1, 16, 16, 256, fn_clyde_7, 271
       00 00 10 00 
       00 00 01 00 
       98 24 04 0F 
       01 00       
041C74 01 00 00 10 0137*   	dl 1, 16, 16, 256, fn_fruit_0, 272
       00 00 10 00 
       00 00 01 00 
       AE 24 04 10 
       01 00       
041C86 01 00 00 10 0138*   	dl 1, 16, 16, 256, fn_fruit_1, 273
       00 00 10 00 
       00 00 01 00 
       C4 24 04 11 
       01 00       
041C98 01 00 00 10 0139*   	dl 1, 16, 16, 256, fn_fruit_2, 274
       00 00 10 00 
       00 00 01 00 
       DA 24 04 12 
       01 00       
041CAA 01 00 00 10 0140*   	dl 1, 16, 16, 256, fn_fruit_3, 275
       00 00 10 00 
       00 00 01 00 
       F0 24 04 13 
       01 00       
041CBC 01 00 00 10 0141*   	dl 1, 16, 16, 256, fn_fruit_4, 276
       00 00 10 00 
       00 00 01 00 
       06 25 04 14 
       01 00       
041CCE 01 00 00 10 0142*   	dl 1, 16, 16, 256, fn_fruit_5, 277
       00 00 10 00 
       00 00 01 00 
       1C 25 04 15 
       01 00       
041CE0 01 00 00 10 0143*   	dl 1, 16, 16, 256, fn_fruit_6, 278
       00 00 10 00 
       00 00 01 00 
       32 25 04 16 
       01 00       
041CF2 01 00 00 10 0144*   	dl 1, 16, 16, 256, fn_fruit_7, 279
       00 00 10 00 
       00 00 01 00 
       48 25 04 17 
       01 00       
041D04 01 00 00 10 0145*   	dl 1, 16, 16, 256, fn_inky_0, 280
       00 00 10 00 
       00 00 01 00 
       5E 25 04 18 
       01 00       
041D16 01 00 00 10 0146*   	dl 1, 16, 16, 256, fn_inky_1, 281
       00 00 10 00 
       00 00 01 00 
       73 25 04 19 
       01 00       
041D28 01 00 00 10 0147*   	dl 1, 16, 16, 256, fn_inky_2, 282
       00 00 10 00 
       00 00 01 00 
       88 25 04 1A 
       01 00       
041D3A 01 00 00 10 0148*   	dl 1, 16, 16, 256, fn_inky_3, 283
       00 00 10 00 
       00 00 01 00 
       9D 25 04 1B 
       01 00       
041D4C 01 00 00 10 0149*   	dl 1, 16, 16, 256, fn_inky_4, 284
       00 00 10 00 
       00 00 01 00 
       B2 25 04 1C 
       01 00       
041D5E 01 00 00 10 0150*   	dl 1, 16, 16, 256, fn_inky_5, 285
       00 00 10 00 
       00 00 01 00 
       C7 25 04 1D 
       01 00       
041D70 01 00 00 10 0151*   	dl 1, 16, 16, 256, fn_inky_6, 286
       00 00 10 00 
       00 00 01 00 
       DC 25 04 1E 
       01 00       
041D82 01 00 00 10 0152*   	dl 1, 16, 16, 256, fn_inky_7, 287
       00 00 10 00 
       00 00 01 00 
       F1 25 04 1F 
       01 00       
041D94 01 00 00 08 0153*   	dl 1, 8, 8, 64, fn_maze_pellets_00, 288
       00 00 08 00 
       00 40 00 00 
       06 26 04 20 
       01 00       
041DA6 01 00 00 08 0154*   	dl 1, 8, 8, 64, fn_maze_pellets_01, 289
       00 00 08 00 
       00 40 00 00 
       24 26 04 21 
       01 00       
041DB8 01 00 00 08 0155*   	dl 1, 8, 8, 64, fn_maze_pellets_02, 290
       00 00 08 00 
       00 40 00 00 
       42 26 04 22 
       01 00       
041DCA 01 00 00 20 0156*   	dl 1, 32, 32, 1024, fn_pac_big_00_00, 291
       00 00 20 00 
       00 00 04 00 
       60 26 04 23 
       01 00       
041DDC 01 00 00 20 0157*   	dl 1, 32, 32, 1024, fn_pac_big_00_01, 292
       00 00 20 00 
       00 00 04 00 
       7C 26 04 24 
       01 00       
041DEE 01 00 00 20 0158*   	dl 1, 32, 32, 1024, fn_pac_big_00_02, 293
       00 00 20 00 
       00 00 04 00 
       98 26 04 25 
       01 00       
041E00 01 00 00 10 0159*   	dl 1, 16, 16, 256, fn_pac_ded_00_00, 294
       00 00 10 00 
       00 00 01 00 
       B4 26 04 26 
       01 00       
041E12 01 00 00 10 0160*   	dl 1, 16, 16, 256, fn_pac_ded_00_01, 295
       00 00 10 00 
       00 00 01 00 
       D0 26 04 27 
       01 00       
041E24 01 00 00 10 0161*   	dl 1, 16, 16, 256, fn_pac_ded_00_02, 296
       00 00 10 00 
       00 00 01 00 
       EC 26 04 28 
       01 00       
041E36 01 00 00 10 0162*   	dl 1, 16, 16, 256, fn_pac_ded_00_03, 297
       00 00 10 00 
       00 00 01 00 
       08 27 04 29 
       01 00       
041E48 01 00 00 10 0163*   	dl 1, 16, 16, 256, fn_pac_ded_00_04, 298
       00 00 10 00 
       00 00 01 00 
       24 27 04 2A 
       01 00       
041E5A 01 00 00 10 0164*   	dl 1, 16, 16, 256, fn_pac_ded_00_05, 299
       00 00 10 00 
       00 00 01 00 
       40 27 04 2B 
       01 00       
041E6C 01 00 00 10 0165*   	dl 1, 16, 16, 256, fn_pac_ded_00_06, 300
       00 00 10 00 
       00 00 01 00 
       5C 27 04 2C 
       01 00       
041E7E 01 00 00 10 0166*   	dl 1, 16, 16, 256, fn_pac_ded_00_07, 301
       00 00 10 00 
       00 00 01 00 
       78 27 04 2D 
       01 00       
041E90 01 00 00 10 0167*   	dl 1, 16, 16, 256, fn_pac_ded_00_08, 302
       00 00 10 00 
       00 00 01 00 
       94 27 04 2E 
       01 00       
041EA2 01 00 00 10 0168*   	dl 1, 16, 16, 256, fn_pac_ded_00_09, 303
       00 00 10 00 
       00 00 01 00 
       B0 27 04 2F 
       01 00       
041EB4 01 00 00 10 0169*   	dl 1, 16, 16, 256, fn_pac_ded_00_10, 304
       00 00 10 00 
       00 00 01 00 
       CC 27 04 30 
       01 00       
041EC6 01 00 00 10 0170*   	dl 1, 16, 16, 256, fn_pac_liv_00_00, 305
       00 00 10 00 
       00 00 01 00 
       E8 27 04 31 
       01 00       
041ED8 01 00 00 10 0171*   	dl 1, 16, 16, 256, fn_pac_man_00_00, 306
       00 00 10 00 
       00 00 01 00 
       04 28 04 32 
       01 00       
041EEA 01 00 00 10 0172*   	dl 1, 16, 16, 256, fn_pac_man_00_01, 307
       00 00 10 00 
       00 00 01 00 
       20 28 04 33 
       01 00       
041EFC 01 00 00 10 0173*   	dl 1, 16, 16, 256, fn_pac_man_00_02, 308
       00 00 10 00 
       00 00 01 00 
       3C 28 04 34 
       01 00       
041F0E 01 00 00 10 0174*   	dl 1, 16, 16, 256, fn_pac_man_01_00, 309
       00 00 10 00 
       00 00 01 00 
       58 28 04 35 
       01 00       
041F20 01 00 00 10 0175*   	dl 1, 16, 16, 256, fn_pac_man_01_01, 310
       00 00 10 00 
       00 00 01 00 
       74 28 04 36 
       01 00       
041F32 01 00 00 10 0176*   	dl 1, 16, 16, 256, fn_pac_man_01_02, 311
       00 00 10 00 
       00 00 01 00 
       90 28 04 37 
       01 00       
041F44 01 00 00 10 0177*   	dl 1, 16, 16, 256, fn_pac_man_02_00, 312
       00 00 10 00 
       00 00 01 00 
       AC 28 04 38 
       01 00       
041F56 01 00 00 10 0178*   	dl 1, 16, 16, 256, fn_pac_man_02_01, 313
       00 00 10 00 
       00 00 01 00 
       C8 28 04 39 
       01 00       
041F68 01 00 00 10 0179*   	dl 1, 16, 16, 256, fn_pac_man_02_02, 314
       00 00 10 00 
       00 00 01 00 
       E4 28 04 3A 
       01 00       
041F7A 01 00 00 10 0180*   	dl 1, 16, 16, 256, fn_pac_man_03_00, 315
       00 00 10 00 
       00 00 01 00 
       00 29 04 3B 
       01 00       
041F8C 01 00 00 10 0181*   	dl 1, 16, 16, 256, fn_pac_man_03_01, 316
       00 00 10 00 
       00 00 01 00 
       1C 29 04 3C 
       01 00       
041F9E 01 00 00 10 0182*   	dl 1, 16, 16, 256, fn_pac_man_03_02, 317
       00 00 10 00 
       00 00 01 00 
       38 29 04 3D 
       01 00       
041FB0 01 00 00 10 0183*   	dl 1, 16, 16, 256, fn_pinky_0, 318
       00 00 10 00 
       00 00 01 00 
       54 29 04 3E 
       01 00       
041FC2 01 00 00 10 0184*   	dl 1, 16, 16, 256, fn_pinky_1, 319
       00 00 10 00 
       00 00 01 00 
       6A 29 04 3F 
       01 00       
041FD4 01 00 00 10 0185*   	dl 1, 16, 16, 256, fn_pinky_2, 320
       00 00 10 00 
       00 00 01 00 
       80 29 04 40 
       01 00       
041FE6 01 00 00 10 0186*   	dl 1, 16, 16, 256, fn_pinky_3, 321
       00 00 10 00 
       00 00 01 00 
       96 29 04 41 
       01 00       
041FF8 01 00 00 10 0187*   	dl 1, 16, 16, 256, fn_pinky_4, 322
       00 00 10 00 
       00 00 01 00 
       AC 29 04 42 
       01 00       
04200A 01 00 00 10 0188*   	dl 1, 16, 16, 256, fn_pinky_5, 323
       00 00 10 00 
       00 00 01 00 
       C2 29 04 43 
       01 00       
04201C 01 00 00 10 0189*   	dl 1, 16, 16, 256, fn_pinky_6, 324
       00 00 10 00 
       00 00 01 00 
       D8 29 04 44 
       01 00       
04202E 01 00 00 10 0190*   	dl 1, 16, 16, 256, fn_pinky_7, 325
       00 00 10 00 
       00 00 01 00 
       EE 29 04 45 
       01 00       
042040 01 00 00 10 0191*   	dl 1, 16, 16, 256, fn_reverse_0, 326
       00 00 10 00 
       00 00 01 00 
       04 2A 04 46 
       01 00       
042052 01 00 00 10 0192*   	dl 1, 16, 16, 256, fn_reverse_1, 327
       00 00 10 00 
       00 00 01 00 
       1C 2A 04 47 
       01 00       
042064 01 00 00 10 0193*   	dl 1, 16, 16, 256, fn_reverse_2, 328
       00 00 10 00 
       00 00 01 00 
       34 2A 04 48 
       01 00       
042076 01 00 00 10 0194*   	dl 1, 16, 16, 256, fn_reverse_3, 329
       00 00 10 00 
       00 00 01 00 
       4C 2A 04 49 
       01 00       
042088 01 00 00 10 0195*   	dl 1, 16, 16, 256, fn_reverse_4, 330
       00 00 10 00 
       00 00 01 00 
       64 2A 04 4A 
       01 00       
04209A 01 00 00 10 0196*   	dl 1, 16, 16, 256, fn_reverse_5, 331
       00 00 10 00 
       00 00 01 00 
       7C 2A 04 4B 
       01 00       
0420AC 01 00 00 10 0197*   	dl 1, 16, 16, 256, fn_reverse_6, 332
       00 00 10 00 
       00 00 01 00 
       94 2A 04 4C 
       01 00       
0420BE 01 00 00 10 0198*   	dl 1, 16, 16, 256, fn_reverse_7, 333
       00 00 10 00 
       00 00 01 00 
       AC 2A 04 4D 
       01 00       
0420D0 01 00 00 08 0199*   	dl 1, 8, 8, 64, fn_tile_00, 334
       00 00 08 00 
       00 40 00 00 
       C4 2A 04 4E 
       01 00       
0420E2 01 00 00 08 0200*   	dl 1, 8, 8, 64, fn_tile_01, 335
       00 00 08 00 
       00 40 00 00 
       DA 2A 04 4F 
       01 00       
0420F4 01 00 00 08 0201*   	dl 1, 8, 8, 64, fn_tile_02, 336
       00 00 08 00 
       00 40 00 00 
       F0 2A 04 50 
       01 00       
042106 01 00 00 08 0202*   	dl 1, 8, 8, 64, fn_tile_03, 337
       00 00 08 00 
       00 40 00 00 
       06 2B 04 51 
       01 00       
042118 01 00 00 08 0203*   	dl 1, 8, 8, 64, fn_tile_04, 338
       00 00 08 00 
       00 40 00 00 
       1C 2B 04 52 
       01 00       
04212A 01 00 00 08 0204*   	dl 1, 8, 8, 64, fn_tile_05, 339
       00 00 08 00 
       00 40 00 00 
       32 2B 04 53 
       01 00       
04213C 01 00 00 08 0205*   	dl 1, 8, 8, 64, fn_tile_06, 340
       00 00 08 00 
       00 40 00 00 
       48 2B 04 54 
       01 00       
04214E 01 00 00 08 0206*   	dl 1, 8, 8, 64, fn_tile_07, 341
       00 00 08 00 
       00 40 00 00 
       5E 2B 04 55 
       01 00       
042160 01 00 00 08 0207*   	dl 1, 8, 8, 64, fn_tile_08, 342
       00 00 08 00 
       00 40 00 00 
       74 2B 04 56 
       01 00       
042172 01 00 00 08 0208*   	dl 1, 8, 8, 64, fn_tile_09, 343
       00 00 08 00 
       00 40 00 00 
       8A 2B 04 57 
       01 00       
042184 01 00 00 08 0209*   	dl 1, 8, 8, 64, fn_tile_10, 344
       00 00 08 00 
       00 40 00 00 
       A0 2B 04 58 
       01 00       
042196 01 00 00 08 0210*   	dl 1, 8, 8, 64, fn_tile_11, 345
       00 00 08 00 
       00 40 00 00 
       B6 2B 04 59 
       01 00       
0421A8 01 00 00 08 0211*   	dl 1, 8, 8, 64, fn_tile_12, 346
       00 00 08 00 
       00 40 00 00 
       CC 2B 04 5A 
       01 00       
0421BA 01 00 00 08 0212*   	dl 1, 8, 8, 64, fn_tile_13, 347
       00 00 08 00 
       00 40 00 00 
       E2 2B 04 5B 
       01 00       
0421CC 01 00 00 08 0213*   	dl 1, 8, 8, 64, fn_tile_14, 348
       00 00 08 00 
       00 40 00 00 
       F8 2B 04 5C 
       01 00       
0421DE 01 00 00 08 0214*   	dl 1, 8, 8, 64, fn_tile_15, 349
       00 00 08 00 
       00 40 00 00 
       0E 2C 04 5D 
       01 00       
0421F0 01 00 00 08 0215*   	dl 1, 8, 8, 64, fn_tile_16, 350
       00 00 08 00 
       00 40 00 00 
       24 2C 04 5E 
       01 00       
042202 01 00 00 08 0216*   	dl 1, 8, 8, 64, fn_tile_17, 351
       00 00 08 00 
       00 40 00 00 
       3A 2C 04 5F 
       01 00       
042214 01 00 00 08 0217*   	dl 1, 8, 8, 64, fn_tile_18, 352
       00 00 08 00 
       00 40 00 00 
       50 2C 04 60 
       01 00       
042226 01 00 00 08 0218*   	dl 1, 8, 8, 64, fn_tile_19, 353
       00 00 08 00 
       00 40 00 00 
       66 2C 04 61 
       01 00       
042238 01 00 00 08 0219*   	dl 1, 8, 8, 64, fn_tile_20, 354
       00 00 08 00 
       00 40 00 00 
       7C 2C 04 62 
       01 00       
04224A 01 00 00 08 0220*   	dl 1, 8, 8, 64, fn_tile_21, 355
       00 00 08 00 
       00 40 00 00 
       92 2C 04 63 
       01 00       
04225C 01 00 00 08 0221*   	dl 1, 8, 8, 64, fn_tile_22, 356
       00 00 08 00 
       00 40 00 00 
       A8 2C 04 64 
       01 00       
04226E 01 00 00 08 0222*   	dl 1, 8, 8, 64, fn_tile_23, 357
       00 00 08 00 
       00 40 00 00 
       BE 2C 04 65 
       01 00       
042280 01 00 00 08 0223*   	dl 1, 8, 8, 64, fn_tile_24, 358
       00 00 08 00 
       00 40 00 00 
       D4 2C 04 66 
       01 00       
042292 01 00 00 08 0224*   	dl 1, 8, 8, 64, fn_tile_25, 359
       00 00 08 00 
       00 40 00 00 
       EA 2C 04 67 
       01 00       
0422A4 01 00 00 08 0225*   	dl 1, 8, 8, 64, fn_tile_26, 360
       00 00 08 00 
       00 40 00 00 
       00 2D 04 68 
       01 00       
0422B6 01 00 00 08 0226*   	dl 1, 8, 8, 64, fn_tile_27, 361
       00 00 08 00 
       00 40 00 00 
       16 2D 04 69 
       01 00       
0422C8 01 00 00 08 0227*   	dl 1, 8, 8, 64, fn_tile_28, 362
       00 00 08 00 
       00 40 00 00 
       2C 2D 04 6A 
       01 00       
0422DA 01 00 00 08 0228*   	dl 1, 8, 8, 64, fn_tile_29, 363
       00 00 08 00 
       00 40 00 00 
       42 2D 04 6B 
       01 00       
0422EC 01 00 00 08 0229*   	dl 1, 8, 8, 64, fn_tile_30, 364
       00 00 08 00 
       00 40 00 00 
       58 2D 04 6C 
       01 00       
0422FE 01 00 00 08 0230*   	dl 1, 8, 8, 64, fn_tile_31, 365
       00 00 08 00 
       00 40 00 00 
       6E 2D 04 6D 
       01 00       
042310 01 00 00 08 0231*   	dl 1, 8, 8, 64, fn_tile_32, 366
       00 00 08 00 
       00 40 00 00 
       84 2D 04 6E 
       01 00       
042322 01 00 00 08 0232*   	dl 1, 8, 8, 64, fn_tile_33, 367
       00 00 08 00 
       00 40 00 00 
       9A 2D 04 6F 
       01 00       
042334 01 00 00 08 0233*   	dl 1, 8, 8, 64, fn_tile_34, 368
       00 00 08 00 
       00 40 00 00 
       B0 2D 04 70 
       01 00       
042346             0234*   
042346             0235*   ; files_list: ; filename:
042346 73 70 72 69 0236*   fn_blinky_0: db "sprites/blinky_0.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 30 
       2E 72 67 62 
       61 32 00    
04235D 73 70 72 69 0237*   fn_blinky_1: db "sprites/blinky_1.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 31 
       2E 72 67 62 
       61 32 00    
042374 73 70 72 69 0238*   fn_blinky_2: db "sprites/blinky_2.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 32 
       2E 72 67 62 
       61 32 00    
04238B 73 70 72 69 0239*   fn_blinky_3: db "sprites/blinky_3.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 33 
       2E 72 67 62 
       61 32 00    
0423A2 73 70 72 69 0240*   fn_blinky_4: db "sprites/blinky_4.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 34 
       2E 72 67 62 
       61 32 00    
0423B9 73 70 72 69 0241*   fn_blinky_5: db "sprites/blinky_5.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 35 
       2E 72 67 62 
       61 32 00    
0423D0 73 70 72 69 0242*   fn_blinky_6: db "sprites/blinky_6.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 36 
       2E 72 67 62 
       61 32 00    
0423E7 73 70 72 69 0243*   fn_blinky_7: db "sprites/blinky_7.rgba2",0
       74 65 73 2F 
       62 6C 69 6E 
       6B 79 5F 37 
       2E 72 67 62 
       61 32 00    
0423FE 73 70 72 69 0244*   fn_clyde_0: db "sprites/clyde_0.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 30 2E 
       72 67 62 61 
       32 00       
042414 73 70 72 69 0245*   fn_clyde_1: db "sprites/clyde_1.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 31 2E 
       72 67 62 61 
       32 00       
04242A 73 70 72 69 0246*   fn_clyde_2: db "sprites/clyde_2.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 32 2E 
       72 67 62 61 
       32 00       
042440 73 70 72 69 0247*   fn_clyde_3: db "sprites/clyde_3.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 33 2E 
       72 67 62 61 
       32 00       
042456 73 70 72 69 0248*   fn_clyde_4: db "sprites/clyde_4.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 34 2E 
       72 67 62 61 
       32 00       
04246C 73 70 72 69 0249*   fn_clyde_5: db "sprites/clyde_5.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 35 2E 
       72 67 62 61 
       32 00       
042482 73 70 72 69 0250*   fn_clyde_6: db "sprites/clyde_6.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 36 2E 
       72 67 62 61 
       32 00       
042498 73 70 72 69 0251*   fn_clyde_7: db "sprites/clyde_7.rgba2",0
       74 65 73 2F 
       63 6C 79 64 
       65 5F 37 2E 
       72 67 62 61 
       32 00       
0424AE 73 70 72 69 0252*   fn_fruit_0: db "sprites/fruit_0.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 30 2E 
       72 67 62 61 
       32 00       
0424C4 73 70 72 69 0253*   fn_fruit_1: db "sprites/fruit_1.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 31 2E 
       72 67 62 61 
       32 00       
0424DA 73 70 72 69 0254*   fn_fruit_2: db "sprites/fruit_2.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 32 2E 
       72 67 62 61 
       32 00       
0424F0 73 70 72 69 0255*   fn_fruit_3: db "sprites/fruit_3.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 33 2E 
       72 67 62 61 
       32 00       
042506 73 70 72 69 0256*   fn_fruit_4: db "sprites/fruit_4.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 34 2E 
       72 67 62 61 
       32 00       
04251C 73 70 72 69 0257*   fn_fruit_5: db "sprites/fruit_5.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 35 2E 
       72 67 62 61 
       32 00       
042532 73 70 72 69 0258*   fn_fruit_6: db "sprites/fruit_6.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 36 2E 
       72 67 62 61 
       32 00       
042548 73 70 72 69 0259*   fn_fruit_7: db "sprites/fruit_7.rgba2",0
       74 65 73 2F 
       66 72 75 69 
       74 5F 37 2E 
       72 67 62 61 
       32 00       
04255E 73 70 72 69 0260*   fn_inky_0: db "sprites/inky_0.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 30 2E 72 
       67 62 61 32 
       00          
042573 73 70 72 69 0261*   fn_inky_1: db "sprites/inky_1.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 31 2E 72 
       67 62 61 32 
       00          
042588 73 70 72 69 0262*   fn_inky_2: db "sprites/inky_2.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 32 2E 72 
       67 62 61 32 
       00          
04259D 73 70 72 69 0263*   fn_inky_3: db "sprites/inky_3.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 33 2E 72 
       67 62 61 32 
       00          
0425B2 73 70 72 69 0264*   fn_inky_4: db "sprites/inky_4.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 34 2E 72 
       67 62 61 32 
       00          
0425C7 73 70 72 69 0265*   fn_inky_5: db "sprites/inky_5.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 35 2E 72 
       67 62 61 32 
       00          
0425DC 73 70 72 69 0266*   fn_inky_6: db "sprites/inky_6.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 36 2E 72 
       67 62 61 32 
       00          
0425F1 73 70 72 69 0267*   fn_inky_7: db "sprites/inky_7.rgba2",0
       74 65 73 2F 
       69 6E 6B 79 
       5F 37 2E 72 
       67 62 61 32 
       00          
042606 73 70 72 69 0268*   fn_maze_pellets_00: db "sprites/maze_pellets_00.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 30 2E 
       72 67 62 61 
       32 00       
042624 73 70 72 69 0269*   fn_maze_pellets_01: db "sprites/maze_pellets_01.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 31 2E 
       72 67 62 61 
       32 00       
042642 73 70 72 69 0270*   fn_maze_pellets_02: db "sprites/maze_pellets_02.rgba2",0
       74 65 73 2F 
       6D 61 7A 65 
       5F 70 65 6C 
       6C 65 74 73 
       5F 30 32 2E 
       72 67 62 61 
       32 00       
042660 73 70 72 69 0271*   fn_pac_big_00_00: db "sprites/pac_big_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
04267C 73 70 72 69 0272*   fn_pac_big_00_01: db "sprites/pac_big_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
042698 73 70 72 69 0273*   fn_pac_big_00_02: db "sprites/pac_big_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       62 69 67 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
0426B4 73 70 72 69 0274*   fn_pac_ded_00_00: db "sprites/pac_ded_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
0426D0 73 70 72 69 0275*   fn_pac_ded_00_01: db "sprites/pac_ded_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
0426EC 73 70 72 69 0276*   fn_pac_ded_00_02: db "sprites/pac_ded_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
042708 73 70 72 69 0277*   fn_pac_ded_00_03: db "sprites/pac_ded_00_03.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       33 2E 72 67 
       62 61 32 00 
042724 73 70 72 69 0278*   fn_pac_ded_00_04: db "sprites/pac_ded_00_04.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       34 2E 72 67 
       62 61 32 00 
042740 73 70 72 69 0279*   fn_pac_ded_00_05: db "sprites/pac_ded_00_05.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       35 2E 72 67 
       62 61 32 00 
04275C 73 70 72 69 0280*   fn_pac_ded_00_06: db "sprites/pac_ded_00_06.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       36 2E 72 67 
       62 61 32 00 
042778 73 70 72 69 0281*   fn_pac_ded_00_07: db "sprites/pac_ded_00_07.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       37 2E 72 67 
       62 61 32 00 
042794 73 70 72 69 0282*   fn_pac_ded_00_08: db "sprites/pac_ded_00_08.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       38 2E 72 67 
       62 61 32 00 
0427B0 73 70 72 69 0283*   fn_pac_ded_00_09: db "sprites/pac_ded_00_09.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 30 
       39 2E 72 67 
       62 61 32 00 
0427CC 73 70 72 69 0284*   fn_pac_ded_00_10: db "sprites/pac_ded_00_10.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       64 65 64 5F 
       30 30 5F 31 
       30 2E 72 67 
       62 61 32 00 
0427E8 73 70 72 69 0285*   fn_pac_liv_00_00: db "sprites/pac_liv_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6C 69 76 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
042804 73 70 72 69 0286*   fn_pac_man_00_00: db "sprites/pac_man_00_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       30 2E 72 67 
       62 61 32 00 
042820 73 70 72 69 0287*   fn_pac_man_00_01: db "sprites/pac_man_00_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       31 2E 72 67 
       62 61 32 00 
04283C 73 70 72 69 0288*   fn_pac_man_00_02: db "sprites/pac_man_00_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 30 5F 30 
       32 2E 72 67 
       62 61 32 00 
042858 73 70 72 69 0289*   fn_pac_man_01_00: db "sprites/pac_man_01_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       30 2E 72 67 
       62 61 32 00 
042874 73 70 72 69 0290*   fn_pac_man_01_01: db "sprites/pac_man_01_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       31 2E 72 67 
       62 61 32 00 
042890 73 70 72 69 0291*   fn_pac_man_01_02: db "sprites/pac_man_01_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 31 5F 30 
       32 2E 72 67 
       62 61 32 00 
0428AC 73 70 72 69 0292*   fn_pac_man_02_00: db "sprites/pac_man_02_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       30 2E 72 67 
       62 61 32 00 
0428C8 73 70 72 69 0293*   fn_pac_man_02_01: db "sprites/pac_man_02_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       31 2E 72 67 
       62 61 32 00 
0428E4 73 70 72 69 0294*   fn_pac_man_02_02: db "sprites/pac_man_02_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 32 5F 30 
       32 2E 72 67 
       62 61 32 00 
042900 73 70 72 69 0295*   fn_pac_man_03_00: db "sprites/pac_man_03_00.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       30 2E 72 67 
       62 61 32 00 
04291C 73 70 72 69 0296*   fn_pac_man_03_01: db "sprites/pac_man_03_01.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       31 2E 72 67 
       62 61 32 00 
042938 73 70 72 69 0297*   fn_pac_man_03_02: db "sprites/pac_man_03_02.rgba2",0
       74 65 73 2F 
       70 61 63 5F 
       6D 61 6E 5F 
       30 33 5F 30 
       32 2E 72 67 
       62 61 32 00 
042954 73 70 72 69 0298*   fn_pinky_0: db "sprites/pinky_0.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 30 2E 
       72 67 62 61 
       32 00       
04296A 73 70 72 69 0299*   fn_pinky_1: db "sprites/pinky_1.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 31 2E 
       72 67 62 61 
       32 00       
042980 73 70 72 69 0300*   fn_pinky_2: db "sprites/pinky_2.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 32 2E 
       72 67 62 61 
       32 00       
042996 73 70 72 69 0301*   fn_pinky_3: db "sprites/pinky_3.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 33 2E 
       72 67 62 61 
       32 00       
0429AC 73 70 72 69 0302*   fn_pinky_4: db "sprites/pinky_4.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 34 2E 
       72 67 62 61 
       32 00       
0429C2 73 70 72 69 0303*   fn_pinky_5: db "sprites/pinky_5.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 35 2E 
       72 67 62 61 
       32 00       
0429D8 73 70 72 69 0304*   fn_pinky_6: db "sprites/pinky_6.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 36 2E 
       72 67 62 61 
       32 00       
0429EE 73 70 72 69 0305*   fn_pinky_7: db "sprites/pinky_7.rgba2",0
       74 65 73 2F 
       70 69 6E 6B 
       79 5F 37 2E 
       72 67 62 61 
       32 00       
042A04 73 70 72 69 0306*   fn_reverse_0: db "sprites/reverse_0.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       30 2E 72 67 
       62 61 32 00 
042A1C 73 70 72 69 0307*   fn_reverse_1: db "sprites/reverse_1.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       31 2E 72 67 
       62 61 32 00 
042A34 73 70 72 69 0308*   fn_reverse_2: db "sprites/reverse_2.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       32 2E 72 67 
       62 61 32 00 
042A4C 73 70 72 69 0309*   fn_reverse_3: db "sprites/reverse_3.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       33 2E 72 67 
       62 61 32 00 
042A64 73 70 72 69 0310*   fn_reverse_4: db "sprites/reverse_4.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       34 2E 72 67 
       62 61 32 00 
042A7C 73 70 72 69 0311*   fn_reverse_5: db "sprites/reverse_5.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       35 2E 72 67 
       62 61 32 00 
042A94 73 70 72 69 0312*   fn_reverse_6: db "sprites/reverse_6.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       36 2E 72 67 
       62 61 32 00 
042AAC 73 70 72 69 0313*   fn_reverse_7: db "sprites/reverse_7.rgba2",0
       74 65 73 2F 
       72 65 76 65 
       72 73 65 5F 
       37 2E 72 67 
       62 61 32 00 
042AC4 73 70 72 69 0314*   fn_tile_00: db "sprites/tile_00.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 30 2E 
       72 67 62 61 
       32 00       
042ADA 73 70 72 69 0315*   fn_tile_01: db "sprites/tile_01.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 31 2E 
       72 67 62 61 
       32 00       
042AF0 73 70 72 69 0316*   fn_tile_02: db "sprites/tile_02.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 32 2E 
       72 67 62 61 
       32 00       
042B06 73 70 72 69 0317*   fn_tile_03: db "sprites/tile_03.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 33 2E 
       72 67 62 61 
       32 00       
042B1C 73 70 72 69 0318*   fn_tile_04: db "sprites/tile_04.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 34 2E 
       72 67 62 61 
       32 00       
042B32 73 70 72 69 0319*   fn_tile_05: db "sprites/tile_05.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 35 2E 
       72 67 62 61 
       32 00       
042B48 73 70 72 69 0320*   fn_tile_06: db "sprites/tile_06.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 36 2E 
       72 67 62 61 
       32 00       
042B5E 73 70 72 69 0321*   fn_tile_07: db "sprites/tile_07.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 37 2E 
       72 67 62 61 
       32 00       
042B74 73 70 72 69 0322*   fn_tile_08: db "sprites/tile_08.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 38 2E 
       72 67 62 61 
       32 00       
042B8A 73 70 72 69 0323*   fn_tile_09: db "sprites/tile_09.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 30 39 2E 
       72 67 62 61 
       32 00       
042BA0 73 70 72 69 0324*   fn_tile_10: db "sprites/tile_10.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 30 2E 
       72 67 62 61 
       32 00       
042BB6 73 70 72 69 0325*   fn_tile_11: db "sprites/tile_11.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 31 2E 
       72 67 62 61 
       32 00       
042BCC 73 70 72 69 0326*   fn_tile_12: db "sprites/tile_12.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 32 2E 
       72 67 62 61 
       32 00       
042BE2 73 70 72 69 0327*   fn_tile_13: db "sprites/tile_13.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 33 2E 
       72 67 62 61 
       32 00       
042BF8 73 70 72 69 0328*   fn_tile_14: db "sprites/tile_14.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 34 2E 
       72 67 62 61 
       32 00       
042C0E 73 70 72 69 0329*   fn_tile_15: db "sprites/tile_15.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 35 2E 
       72 67 62 61 
       32 00       
042C24 73 70 72 69 0330*   fn_tile_16: db "sprites/tile_16.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 36 2E 
       72 67 62 61 
       32 00       
042C3A 73 70 72 69 0331*   fn_tile_17: db "sprites/tile_17.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 37 2E 
       72 67 62 61 
       32 00       
042C50 73 70 72 69 0332*   fn_tile_18: db "sprites/tile_18.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 38 2E 
       72 67 62 61 
       32 00       
042C66 73 70 72 69 0333*   fn_tile_19: db "sprites/tile_19.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 31 39 2E 
       72 67 62 61 
       32 00       
042C7C 73 70 72 69 0334*   fn_tile_20: db "sprites/tile_20.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 30 2E 
       72 67 62 61 
       32 00       
042C92 73 70 72 69 0335*   fn_tile_21: db "sprites/tile_21.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 31 2E 
       72 67 62 61 
       32 00       
042CA8 73 70 72 69 0336*   fn_tile_22: db "sprites/tile_22.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 32 2E 
       72 67 62 61 
       32 00       
042CBE 73 70 72 69 0337*   fn_tile_23: db "sprites/tile_23.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 33 2E 
       72 67 62 61 
       32 00       
042CD4 73 70 72 69 0338*   fn_tile_24: db "sprites/tile_24.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 34 2E 
       72 67 62 61 
       32 00       
042CEA 73 70 72 69 0339*   fn_tile_25: db "sprites/tile_25.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 35 2E 
       72 67 62 61 
       32 00       
042D00 73 70 72 69 0340*   fn_tile_26: db "sprites/tile_26.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 36 2E 
       72 67 62 61 
       32 00       
042D16 73 70 72 69 0341*   fn_tile_27: db "sprites/tile_27.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 37 2E 
       72 67 62 61 
       32 00       
042D2C 73 70 72 69 0342*   fn_tile_28: db "sprites/tile_28.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 38 2E 
       72 67 62 61 
       32 00       
042D42 73 70 72 69 0343*   fn_tile_29: db "sprites/tile_29.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 32 39 2E 
       72 67 62 61 
       32 00       
042D58 73 70 72 69 0344*   fn_tile_30: db "sprites/tile_30.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 30 2E 
       72 67 62 61 
       32 00       
042D6E 73 70 72 69 0345*   fn_tile_31: db "sprites/tile_31.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 31 2E 
       72 67 62 61 
       32 00       
042D84 73 70 72 69 0346*   fn_tile_32: db "sprites/tile_32.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 32 2E 
       72 67 62 61 
       32 00       
042D9A 73 70 72 69 0347*   fn_tile_33: db "sprites/tile_33.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 33 2E 
       72 67 62 61 
       32 00       
042DB0 73 70 72 69 0348*   fn_tile_34: db "sprites/tile_34.rgba2",0
       74 65 73 2F 
       74 69 6C 65 
       5F 33 34 2E 
       72 67 62 61 
       32 00       
042DC6             0047        include "maze.inc"
042DC6             0001*   maze_cols: equ 0
042DC6             0002*   maze_rows: equ 3
042DC6             0003*   maze_tile_size: equ 6
042DC6             0004*   maze_null_tile: equ 9
042DC6             0005*   maze_x: equ 12
042DC6             0006*   maze_y: equ 15
042DC6             0007*   maze_base_bufferId: equ 18
042DC6             0008*   orient_up: equ 2
042DC6             0009*   orient_left: equ 1
042DC6             0010*   orient_down: equ 3
042DC6             0011*   orient_right: equ 0
042DC6             0012*   
042DC6             0013*   ; draw a maze based on a maze definition table
042DC6             0014*   ; inputs: ix = pointer to maze definition table
042DC6             0015*   ; outputs: pretty pixels
042DC6             0016*   ; destroys: all the things
042DC6             0017*   ; TODO: this could be significantly simplified if the null tile number
042DC6             0018*   ;       and low byte of the base bufferId are both 0
042DC6             0019*   draw_maze:
042DC6             0020*   ; initialize variables
042DC6 DD E5       0021*       push ix
042DC8 FD E1       0022*       pop iy
042DCA ED 32 15    0023*       lea ix,ix+maze_base_bufferId+3 ; point to the first cell of the maze data
042DCD 21 00 00 00 0024*       ld hl,0
042DD1 FD 2F 0C    0025*       ld (iy+maze_x),hl
042DD4 FD 2F 0F    0026*       ld (iy+maze_y),hl
042DD7 FD 6E 00    0027*       ld l,(iy+maze_cols)
042DDA FD 66 03    0028*       ld h,(iy+maze_rows)
042DDD             0029*   @loop:
042DDD E5          0030*       push hl ; row/col loop counter
042DDE DD 7E 00    0031*       ld a,(ix) ; tile number
042DE1 FD BE 09    0032*       cp (iy+maze_null_tile) ; is it the null tile?
042DE4 28 19       0033*       jr z,@next_tile ; yes, so don't draw anything
042DE6 FD 27 12    0034*       ld hl,(iy+maze_base_bufferId) ; base bufferId
042DE9 11 00 00 00 0035*       ld de,0 ; clear deu and d
042DED DD 5E 00    0036*       ld e,(ix) ; tile number
042DF0 19          0037*       add hl,de ; hl = tile bufferId
042DF1 CD 38 14 04 0038*       call vdu_buff_select
042DF5 FD 07 0C    0039*       ld bc,(iy+maze_x) ; x-coordinate
042DF8 FD 17 0F    0040*       ld de,(iy+maze_y) ; y-coordinate
042DFB CD 20 18 04 0041*       call vdu_plot_bmp
042DFF             0042*   @next_tile:
042DFF FD 27 0C    0043*       ld hl,(iy+maze_x) ; x-coordinate
042E02 FD 17 06    0044*       ld de,(iy+maze_tile_size) ; tile size
042E05 19          0045*       add hl,de ; x-coordinate + tile size
042E06 FD 2F 0C    0046*       ld (iy+maze_x),hl ; x-coordinate = x-coordinate + tile size
042E09 DD 23       0047*       inc ix ; bump pointer to next tile
042E0B E1          0048*       pop hl ; row/col loop counter
042E0C 2D          0049*       dec l
042E0D C2 DD 2D 04 0050*       jp nz,@loop
042E11 25          0051*       dec h
042E12 C8          0052*       ret z ; done
042E13 FD 6E 00    0053*       ld l,(iy+maze_cols) ; number of columns
042E16 E5          0054*       push hl
042E17 FD 27 0F    0055*       ld hl,(iy+maze_y) ; y-coordinate
042E1A FD 17 06    0056*       ld de,(iy+maze_tile_size) ; tile size
042E1D 19          0057*       add hl,de ; y-coordinate + tile size
042E1E FD 2F 0F    0058*       ld (iy+maze_y),hl ; y-coordinate = y-coordinate + tile size
042E21 21 00 00 00 0059*       ld hl,0 ; x-coordinate
042E25 FD 2F 0C    0060*       ld (iy+maze_x),hl ; x-coordinate = 0
042E28 E1          0061*       pop hl
042E29 C3 DD 2D 04 0062*       jp @loop
042E2D             0063*   
042E2D             0064*   ; converts screen coordinates to map cell coordinates
042E2D             0065*   ; inputs: ix = pointer to map defintion, ub.c = x-coordinate, ud.e = y-coordinate in 16.8 fixed point format
042E2D             0066*   ; outputs: bc,de = row,col, hl = cell index, ix = pointer to cell data
042E2D             0067*   ; destroys: a, hl, ix
042E2D             0068*   ; notes: map and screen coordinates assume inverted y-axis with origin at top left
042E2D             0069*   ;        tile size must be a power of two
042E2D             0070*   ;        screen coordinates are treated as unsigned with no checks to the contrary
042E2D             0071*   screen_to_map:
042E2D             0072*   ; get the x-coordinate
042E2D C5          0073*       push bc
042E2E E1          0074*       pop hl
042E2F CD 6D 05 04 0075*       call hlu_udiv256 ; hl = int(x)
042E33 DD 7E 06    0076*       ld a,(ix+maze_tile_size)
042E36 CD C5 04 04 0077*       call shr_hlu_log2a ; hl = int(int(x) / tile size) = col
042E3A EB          0078*       ex de,hl ; uh.l = y-coordinate, de = col
042E3B             0079*   ; get the y-coordinate
042E3B CD 6D 05 04 0080*       call hlu_udiv256 ; hl = int(y)
042E3F DD 7E 06    0081*       ld a,(ix+maze_tile_size)
042E42 CD C5 04 04 0082*       call shr_hlu_log2a ; hl = int(int(y) / tile size) = row
042E46 E5          0083*       push hl ; save row
042E47             0084*   ; compute cell index = row * cols + col
042E47             0085*   ; at this point hl = row, de = col
042E47 DD 66 00    0086*       ld h,(ix+maze_cols)
042E4A ED 6C       0087*       mlt hl ; hl = row * cols
042E4C 19          0088*       add hl,de ; hl = row * cols + col = cell index
042E4D EB          0089*       ex de,hl ; de = cell index, hl = col
042E4E             0090*   ; point to cell data
042E4E ED 32 15    0091*       lea ix,ix+maze_base_bufferId+3
042E51 DD 19       0092*       add ix,de
042E53             0093*   ; return results
042E53 EB          0094*       ex de,hl ; de = col, hl = cell index
042E54 D5          0095*       push de
042E55 C1          0096*       pop bc ; bc = col
042E56 D1          0097*       pop de ; de = row
042E57             0098*   
042E57 C9          0099*       ret
042E58             0100*   
042E58             0101*   ; converts map cell coordinates to screen coordinates
042E58             0102*   ; inputs: ix = pointer to map definition, ub.c = col, ud.e = row in 16.8 fixed point format
042E58             0103*   ; outputs: bc,de = x,y as 24-bit integers
042E58             0104*   ; destroys: a, hl, bc, de
042E58             0105*   map_to_screen:
042E58             0106*   ; get the x-coordinate
042E58 C5          0107*       push bc
042E59 E1          0108*       pop hl ; uh.l = col
042E5A DD 7E 06    0109*       ld a,(ix+maze_tile_size)
042E5D CD DB 04 04 0110*       call shl_hlu_log2a ; uh.l = col * tile size
042E61 E5          0111*       push hl ; save x-coordinate
042E62             0112*   ; get the y-coordinate
042E62 EB          0113*       ex de,hl ; uh.l = row
042E63 DD 7E 06    0114*       ld a,(ix+maze_tile_size)
042E66 CD DB 04 04 0115*       call shl_hlu_log2a ; uh.l = row * tile size
042E6A             0116*   ; return results
042E6A EB          0117*       ex de,hl ; de = y-coordinate
042E6B C1          0118*       pop bc ; bc = x-coordinate
042E6C C9          0119*       ret
042E6D             0120*   
042E6D             0121*   ; TODO: not tested yet, and shouldn't be needed anyway but we leave it for academic interest
042E6D             0122*   ; like map_to_screen but returns the exact tile coordinates from a cell index value
042E6D             0123*   ; inputs: ix = pointer to map definition, hl = cell index
042E6D             0124*   ; outputs: bc,de = x,y as 24-bit integers
042E6D             0125*   ; destroys: a, hl, bc, de
042E6D             0126*   cell_to_screen:
042E6D             0127*   ; compute row = int(idx / cols), col = idx % cols
042E6D 11 00 00 00 0128*       ld de,0 ; clear deu and d
042E71 DD 5E 00    0129*       ld e,(ix+maze_cols)
042E74 CD 07 04 04 0130*       call udiv24 ; de = row, hl = col TODO: a udiv24x8 would be a nice thingy for this
042E78 4D          0131*       ld c,l ; c = col
042E79             0132*   ; compute y = row * tile_size
042E79 DD 56 06    0133*       ld d,(ix+maze_tile_size)
042E7C 42          0134*       ld b,d ; we'll use for x in a sec
042E7D ED 5C       0135*       mlt de ; de = y
042E7F             0136*   ; compute x = col * tile_size
042E7F ED 4C       0137*       mlt bc ; bc = x
042E81 C9          0138*       ret
042E82             0139*   ; end cell_to_screen
042E82             0140*   
042E82             0141*   ; get a pointer to a map cell from col and row input
042E82             0142*   ; by computing cell index = row * cols + col
042E82             0143*   ; inputs: ix = pointer to map definition, ub.c = col, ud.e = row in 16.8 fixed point format
042E82             0144*   ; returns: ix = pointer to cell data, hl = cell index, a = cell value
042E82             0145*   ; destroys: a, hl, ix
042E82             0146*   map_get_cell_from_xy:
042E82 6A          0147*       ld l,d ; int(row)
042E83 DD 66 00    0148*       ld h,(ix+maze_cols)
042E86 ED 6C       0149*       mlt hl ; row * cols
042E88 78          0150*       ld a,b ; int(col)
042E89 85          0151*       add a,l
042E8A 6F          0152*       ld l,a
042E8B 3E 00       0153*       ld a,0 ; we need carry
042E8D 8C          0154*       adc a,h
042E8E 67          0155*       ld h,a ; hl = cell index
042E8F EB          0156*       ex de,hl ; can't add ix,hl
042E90 ED 32 15    0157*       lea ix,ix+maze_base_bufferId+3 ; point to cell 0
042E93 DD 19       0158*       add ix,de ; point to cell data
042E95 DD 7E 00    0159*       ld a,(ix) ; cell value
042E98 EB          0160*       ex de,hl ; restore de, hl = cell index
042E99 C9          0161*       ret
042E9A             0162*   ; end map_get_cell_from_xy
042E9A             0163*   
042E9A             0164*   ; get a pointer to a map cell from cell index input
042E9A             0165*   ; inputs: ix = pointer to map definition, hl = cell index
042E9A             0166*   ; returns: ix = pointer to cell data, a = cell value
042E9A             0167*   ; destroys: a, ix
042E9A             0168*   map_get_cell_from_idx:
042E9A D5          0169*       push de ; preserve
042E9B EB          0170*       ex de,hl ; can't add ix,hl
042E9C ED 32 15    0171*       lea ix,ix+maze_base_bufferId+3 ; point to cell 0
042E9F DD 19       0172*       add ix,de ; point to cell data
042EA1 DD 7E 00    0173*       ld a,(ix) ; cell value
042EA4 EB          0174*       ex de,hl ; put index back into hl
042EA5 D1          0175*       pop de ; restore de
042EA6 C9          0176*       ret
042EA7             0177*   
042EA7             0178*   ; snap row and or col values to the nearest half as required by the path mask of the current cell
042EA7             0179*   ; inputs: ix = pointer to map cell, ub.c = col, ud.e = row in 16.8 fixed point format
042EA7             0180*   ; outputs: ub.c = col, ud.e = row adjusted as required
042EA7             0181*   snap_to_path:
042EA7 3E 80       0182*       ld a,0x80
042EA9 DD CB 00 56 0183*       bit orient_up,(ix)
042EAD CC CA 2E 04 0184*       call z,@up
042EB1 DD CB 00 4E 0185*       bit orient_left,(ix)
042EB5 CC CE 2E 04 0186*       call z,@left
042EB9 DD CB 00 5E 0187*       bit orient_down,(ix)
042EBD CC D2 2E 04 0188*       call z,@down
042EC1 DD CB 00 46 0189*       bit orient_right,(ix)
042EC5 CC D6 2E 04 0190*       call z,@right
042EC9 C9          0191*       ret ; all the directions checked, so we're done
042ECA             0192*   @up:
042ECA BB          0193*       cp e ; fractional portion
042ECB D8          0194*       ret c ; no adjustment needed
042ECC 5F          0195*       ld e,a ; snap fractional portion to 1/2
042ECD C9          0196*       ret ; up done
042ECE             0197*   @left:
042ECE B9          0198*       cp c ; fractional portion
042ECF D8          0199*       ret c ; no adjustment needed
042ED0 4F          0200*       ld c,a ; snap fractional portion to 1/2
042ED1 C9          0201*       ret ; left done
042ED2             0202*   @down:
042ED2 BB          0203*       cp e ; fractional portion
042ED3 D0          0204*       ret nc ; no adjustment needed
042ED4 5F          0205*       ld e,a ; snap fractional portion to 1/2
042ED5 C9          0206*       ret ; down done
042ED6             0207*   @right:
042ED6 B9          0208*       cp c ; fractional portion
042ED7 D0          0209*       ret nc ; no adjustment needed
042ED8 4F          0210*       ld c,a ; snap fractional portion to 1/2
042ED9 C9          0211*       ret ; right done
042EDA             0212*   ; end snap_to_path
042EDA             0048        include "maze_index.inc" ; DEBUG
042EDA             0001*   ; for easy verification that screen_to_map and other maze lookup functions work correctly
042EDA             0002*   
042EDA             0003*   maze_index:
042EDA 1C 00 00    0004*   maze_index_num_cols: dl 28
042EDD 1F 00 00    0005*   maze_index_num_rows: dl 31
042EE0 08 00 00    0006*   maze_index_tile_size: dl 8
042EE3 00 00 00    0007*   maze_index_null_tile: dl 0 ; not used for maze index definitions.
042EE6 00 00 00    0008*   maze_index_x: dl 0
042EE9 00 00 00    0009*   maze_index_y: dl 0
042EEC 00 00 00    0010*   maze_index_base_bufferId: dl 0 ; not used for maze index definitions.
042EEF             0011*   
042EEF             0012*   maze_index_map:
042EEF 00 01 02 03 0013*       db 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
       10 11 12 13 
       14 15 16 17 
       18 19 1A 1B 
042F0B 1C 1D 1E 1F 0014*       db 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
       2C 2D 2E 2F 
       30 31 32 33 
       34 35 36 37 
042F27 38 39 3A 3B 0015*       db 56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
       48 49 4A 4B 
       4C 4D 4E 4F 
       50 51 52 53 
042F43 54 55 56 57 0016*       db 84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
       64 65 66 67 
       68 69 6A 6B 
       6C 6D 6E 6F 
042F5F 70 71 72 73 0017*       db 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139
       74 75 76 77 
       78 79 7A 7B 
       7C 7D 7E 7F 
       80 81 82 83 
       84 85 86 87 
       88 89 8A 8B 
042F7B 8C 8D 8E 8F 0018*       db 140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167
       90 91 92 93 
       94 95 96 97 
       98 99 9A 9B 
       9C 9D 9E 9F 
       A0 A1 A2 A3 
       A4 A5 A6 A7 
042F97 A8 A9 AA AB 0019*       db 168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195
       AC AD AE AF 
       B0 B1 B2 B3 
       B4 B5 B6 B7 
       B8 B9 BA BB 
       BC BD BE BF 
       C0 C1 C2 C3 
042FB3 C4 C5 C6 C7 0020*       db 196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
       C8 C9 CA CB 
       CC CD CE CF 
       D0 D1 D2 D3 
       D4 D5 D6 D7 
       D8 D9 DA DB 
       DC DD DE DF 
042FCF E0 E1 E2 E3 0021*       db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251
       E4 E5 E6 E7 
       E8 E9 EA EB 
       EC ED EE EF 
       F0 F1 F2 F3 
       F4 F5 F6 F7 
       F8 F9 FA FB 
042FEB FC FD FE FF 0022*       db 252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23
       00 01 02 03 
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
       10 11 12 13 
       14 15 16 17 
043007 18 19 1A 1B 0023*       db 24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51
       1C 1D 1E 1F 
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
       2C 2D 2E 2F 
       30 31 32 33 
043023 34 35 36 37 0024*       db 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
       38 39 3A 3B 
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
       48 49 4A 4B 
       4C 4D 4E 4F 
04303F 50 51 52 53 0025*       db 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107
       54 55 56 57 
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
       64 65 66 67 
       68 69 6A 6B 
04305B 6C 6D 6E 6F 0026*       db 108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135
       70 71 72 73 
       74 75 76 77 
       78 79 7A 7B 
       7C 7D 7E 7F 
       80 81 82 83 
       84 85 86 87 
043077 88 89 8A 8B 0027*       db 136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163
       8C 8D 8E 8F 
       90 91 92 93 
       94 95 96 97 
       98 99 9A 9B 
       9C 9D 9E 9F 
       A0 A1 A2 A3 
043093 A4 A5 A6 A7 0028*       db 164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191
       A8 A9 AA AB 
       AC AD AE AF 
       B0 B1 B2 B3 
       B4 B5 B6 B7 
       B8 B9 BA BB 
       BC BD BE BF 
0430AF C0 C1 C2 C3 0029*       db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219
       C4 C5 C6 C7 
       C8 C9 CA CB 
       CC CD CE CF 
       D0 D1 D2 D3 
       D4 D5 D6 D7 
       D8 D9 DA DB 
0430CB DC DD DE DF 0030*       db 220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247
       E0 E1 E2 E3 
       E4 E5 E6 E7 
       E8 E9 EA EB 
       EC ED EE EF 
       F0 F1 F2 F3 
       F4 F5 F6 F7 
0430E7 F8 F9 FA FB 0031*       db 248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
       FC FD FE FF 
       00 01 02 03 
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
       10 11 12 13 
043103 14 15 16 17 0032*       db 20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47
       18 19 1A 1B 
       1C 1D 1E 1F 
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
       2C 2D 2E 2F 
04311F 30 31 32 33 0033*       db 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75
       34 35 36 37 
       38 39 3A 3B 
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
       48 49 4A 4B 
04313B 4C 4D 4E 4F 0034*       db 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103
       50 51 52 53 
       54 55 56 57 
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
       64 65 66 67 
043157 68 69 6A 6B 0035*       db 104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131
       6C 6D 6E 6F 
       70 71 72 73 
       74 75 76 77 
       78 79 7A 7B 
       7C 7D 7E 7F 
       80 81 82 83 
043173 84 85 86 87 0036*       db 132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
       88 89 8A 8B 
       8C 8D 8E 8F 
       90 91 92 93 
       94 95 96 97 
       98 99 9A 9B 
       9C 9D 9E 9F 
04318F A0 A1 A2 A3 0037*       db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187
       A4 A5 A6 A7 
       A8 A9 AA AB 
       AC AD AE AF 
       B0 B1 B2 B3 
       B4 B5 B6 B7 
       B8 B9 BA BB 
0431AB BC BD BE BF 0038*       db 188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215
       C0 C1 C2 C3 
       C4 C5 C6 C7 
       C8 C9 CA CB 
       CC CD CE CF 
       D0 D1 D2 D3 
       D4 D5 D6 D7 
0431C7 D8 D9 DA DB 0039*       db 216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243
       DC DD DE DF 
       E0 E1 E2 E3 
       E4 E5 E6 E7 
       E8 E9 EA EB 
       EC ED EE EF 
       F0 F1 F2 F3 
0431E3 F4 F5 F6 F7 0040*       db 244,245,246,247,248,249,250,251,252,253,254,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
       F8 F9 FA FB 
       FC FD FE FF 
       00 01 02 03 
       04 05 06 07 
       08 09 0A 0B 
       0C 0D 0E 0F 
0431FF 10 11 12 13 0041*       db 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43
       14 15 16 17 
       18 19 1A 1B 
       1C 1D 1E 1F 
       20 21 22 23 
       24 25 26 27 
       28 29 2A 2B 
04321B 2C 2D 2E 2F 0042*       db 44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71
       30 31 32 33 
       34 35 36 37 
       38 39 3A 3B 
       3C 3D 3E 3F 
       40 41 42 43 
       44 45 46 47 
043237 48 49 4A 4B 0043*       db 72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99
       4C 4D 4E 4F 
       50 51 52 53 
       54 55 56 57 
       58 59 5A 5B 
       5C 5D 5E 5F 
       60 61 62 63 
043253             0049        include "maze_walls.inc"
043253             0001*   ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
043253             0002*   
043253             0003*   maze_walls:
043253 1C 00 00    0004*   maze_walls_num_cols: dl 28
043256 1F 00 00    0005*   maze_walls_num_rows: dl 31
043259 08 00 00    0006*   maze_walls_tile_size: dl 8
04325C 06 00 00    0007*   maze_walls_null_tile: dl 6
04325F 00 00 00    0008*   maze_walls_x: dl 0
043262 00 00 00    0009*   maze_walls_y: dl 0
043265 4E 01 00    0010*   maze_walls_base_bufferId: dl BUF_TILE_00
043268             0011*   
043268             0012*   maze_walls_map:
043268 00 01 01 01 0013*       db 00,01,01,01,01,01,01,01,01,01,01,01,01,02,03,01,01,01,01,01,01,01,01,01,01,01,01,04
       01 01 01 01 
       01 01 01 01 
       01 02 03 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 04 
043284 05 06 06 06 0014*       db 05,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 07 08 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
0432A0 05 06 0A 0B 0015*       db 05,06,10,11,11,12,06,10,11,11,11,12,06,07,08,06,10,11,11,11,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0B 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 0B 
       0C 06 0A 0B 
       0B 0C 06 09 
0432BC 05 06 07 06 0016*       db 05,06,07,06,06,08,06,07,06,06,06,08,06,07,08,06,07,06,06,06,08,06,07,06,06,08,06,09
       06 08 06 07 
       06 06 06 08 
       06 07 08 06 
       07 06 06 06 
       08 06 07 06 
       06 08 06 09 
0432D8 05 06 0D 0E 0017*       db 05,06,13,14,14,15,06,13,14,14,14,15,06,13,15,06,13,14,14,14,15,06,13,14,14,15,06,09
       0E 0F 06 0D 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0F 06 0D 0E 
       0E 0F 06 09 
0432F4 05 06 06 06 0018*       db 05,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
043310 05 06 0A 0B 0019*       db 05,06,10,11,11,12,06,10,12,06,10,11,11,11,11,11,11,12,06,10,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0C 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 0A 
       0C 06 0A 0B 
       0B 0C 06 09 
04332C 05 06 0D 0E 0020*       db 05,06,13,14,14,15,06,07,08,06,13,14,14,16,17,14,14,15,06,07,08,06,13,14,14,15,06,09
       0E 0F 06 07 
       08 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 07 
       08 06 0D 0E 
       0E 0F 06 09 
043348 05 06 06 06 0021*       db 05,06,06,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,06,06,09
       06 06 06 07 
       08 06 06 06 
       06 07 08 06 
       06 06 06 07 
       08 06 06 06 
       06 06 06 09 
043364 12 13 13 13 0022*       db 18,19,19,19,19,12,06,07,20,11,11,12,06,07,08,06,10,11,11,21,08,06,10,19,19,19,19,22
       13 0C 06 07 
       14 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 15 
       08 06 0A 13 
       13 13 13 16 
043380 06 06 06 06 0023*       db 06,06,06,06,06,05,06,07,17,14,14,15,06,13,15,06,13,14,14,16,08,06,09,06,06,06,06,06
       06 05 06 07 
       11 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 10 
       08 06 09 06 
       06 06 06 06 
04339C 06 06 06 06 0024*       db 06,06,06,06,06,05,06,07,08,06,06,06,06,06,06,06,06,06,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 06 06 
       06 06 06 06 
       06 06 06 07 
       08 06 09 06 
       06 06 06 06 
0433B8 06 06 06 06 0025*       db 06,06,06,06,06,05,06,07,08,06,23,19,24,06,06,25,19,26,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 17 13 
       18 06 06 19 
       13 1A 06 07 
       08 06 09 06 
       06 06 06 06 
0433D4 01 01 01 01 0026*       db 01,01,01,01,01,15,06,13,15,06,09,06,06,06,06,06,06,05,06,13,15,06,13,01,01,01,01,01
       01 0F 06 0D 
       0F 06 09 06 
       06 06 06 06 
       06 05 06 0D 
       0F 06 0D 01 
       01 01 01 01 
0433F0 06 06 06 06 0027*       db 06,06,06,06,06,06,06,06,06,06,09,06,06,06,06,06,06,05,06,06,06,06,06,06,06,06,06,06
       06 06 06 06 
       06 06 09 06 
       06 06 06 06 
       06 05 06 06 
       06 06 06 06 
       06 06 06 06 
04340C 13 13 13 13 0028*       db 19,19,19,19,19,12,06,10,12,06,09,06,06,06,06,06,06,05,06,10,12,06,10,19,19,19,19,19
       13 0C 06 0A 
       0C 06 09 06 
       06 06 06 06 
       06 05 06 0A 
       0C 06 0A 13 
       13 13 13 13 
043428 06 06 06 06 0029*       db 06,06,06,06,06,05,06,07,08,06,27,01,01,01,01,01,01,28,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 1B 01 
       01 01 01 01 
       01 1C 06 07 
       08 06 09 06 
       06 06 06 06 
043444 06 06 06 06 0030*       db 06,06,06,06,06,05,06,07,08,06,06,06,06,06,06,06,06,06,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 06 06 
       06 06 06 06 
       06 06 06 07 
       08 06 09 06 
       06 06 06 06 
043460 06 06 06 06 0031*       db 06,06,06,06,06,05,06,07,08,06,10,11,11,11,11,11,11,12,06,07,08,06,09,06,06,06,06,06
       06 05 06 07 
       08 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 07 
       08 06 09 06 
       06 06 06 06 
04347C 00 01 01 01 0032*       db 00,01,01,01,01,15,06,13,15,06,13,14,14,16,17,14,14,15,06,13,15,06,13,01,01,01,01,29
       01 0F 06 0D 
       0F 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 0D 
       0F 06 0D 01 
       01 01 01 1D 
043498 05 06 06 06 0033*       db 05,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 07 08 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
0434B4 05 06 0A 0B 0034*       db 05,06,10,11,11,12,06,10,11,11,11,12,06,07,08,06,10,11,11,11,12,06,10,11,11,12,06,09
       0B 0C 06 0A 
       0B 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 0B 
       0C 06 0A 0B 
       0B 0C 06 09 
0434D0 05 06 0D 0E 0035*       db 05,06,13,14,16,08,06,13,14,14,14,15,06,13,15,06,13,14,14,14,15,06,07,17,14,15,06,09
       10 08 06 0D 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0F 06 07 11 
       0E 0F 06 09 
0434EC 05 06 06 06 0036*       db 05,06,06,06,07,08,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,07,08,06,06,06,09
       07 08 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 07 08 
       06 06 06 09 
043508 1E 0B 0C 06 0037*       db 30,11,12,06,07,08,06,10,12,06,10,11,11,11,11,11,11,12,06,10,12,06,07,08,06,10,11,31
       07 08 06 0A 
       0C 06 0A 0B 
       0B 0B 0B 0B 
       0B 0C 06 0A 
       0C 06 07 08 
       06 0A 0B 1F 
043524 20 0E 0F 06 0038*       db 32,14,15,06,13,15,06,07,08,06,13,14,14,16,17,14,14,15,06,07,08,06,13,15,06,13,14,33
       0D 0F 06 07 
       08 06 0D 0E 
       0E 10 11 0E 
       0E 0F 06 07 
       08 06 0D 0F 
       06 0D 0E 21 
043540 05 06 06 06 0039*       db 05,06,06,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,07,08,06,06,06,06,06,06,09
       06 06 06 07 
       08 06 06 06 
       06 07 08 06 
       06 06 06 07 
       08 06 06 06 
       06 06 06 09 
04355C 05 06 0A 0B 0040*       db 05,06,10,11,11,11,11,21,20,11,11,12,06,07,08,06,10,11,11,21,20,11,11,11,11,12,06,09
       0B 0B 0B 15 
       14 0B 0B 0C 
       06 07 08 06 
       0A 0B 0B 15 
       14 0B 0B 0B 
       0B 0C 06 09 
043578 05 06 0D 0E 0041*       db 05,06,13,14,14,14,14,14,14,14,14,15,06,13,15,06,13,14,14,14,14,14,14,14,14,15,06,09
       0E 0E 0E 0E 
       0E 0E 0E 0F 
       06 0D 0F 06 
       0D 0E 0E 0E 
       0E 0E 0E 0E 
       0E 0F 06 09 
043594 05 06 06 06 0042*       db 05,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,06,09
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 06 
       06 06 06 09 
0435B0 12 13 13 13 0043*       db 18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,34
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 13 
       13 13 13 22 
0435CC             0050        include "maze_path.inc"
0435CC             0001*   ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
0435CC             0002*   ; Source file: beegee747/src/assets/design/sprites/maze_path/maze_path.csv
0435CC             0003*   
0435CC             0004*   maze_path:
0435CC 1C 00 00    0005*   maze_path_num_cols: dl 28
0435CF 1F 00 00    0006*   maze_path_num_rows: dl 31
0435D2 08 00 00    0007*   maze_path_tile_size: dl 8
0435D5 00 00 00    0008*   maze_path_null_tile: dl 0 ; not used for maze path definitions.
0435D8 00 00 00    0009*   maze_path_x: dl 0
0435DB 00 00 00    0010*   maze_path_y: dl 0
0435DE 00 00 00    0011*   maze_path_base_bufferId: dl 0 ; now used for maze path definitions.
0435E1             0012*   
0435E1             0013*   maze_path_map:
0435E1 00 00 00 00 0014*       db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0435FD 00 09 03 03 0015*       db 00,09,03,03,03,03,11,03,03,03,03,03,10,00,00,09,03,03,03,03,03,11,03,03,03,03,10,00
       03 03 0B 03 
       03 03 03 03 
       0A 00 00 09 
       03 03 03 03 
       03 0B 03 03 
       03 03 0A 00 
043619 00 0C 00 00 0016*       db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
043635 00 0C 00 00 0017*       db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
043651 00 0C 00 00 0018*       db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
04366D 00 0D 03 03 0019*       db 00,13,03,03,03,03,15,03,03,11,03,03,07,03,03,07,03,03,11,03,03,15,03,03,03,03,14,00
       03 03 0F 03 
       03 0B 03 03 
       07 03 03 07 
       03 03 0B 03 
       03 0F 03 03 
       03 03 0E 00 
043689 00 0C 00 00 0020*       db 00,12,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 0C 00 
0436A5 00 0C 00 00 0021*       db 00,12,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 0C 00 
0436C1 00 05 03 03 0022*       db 00,05,03,03,03,03,14,00,00,05,03,03,10,00,00,09,03,03,06,00,00,13,03,03,03,03,06,00
       03 03 0E 00 
       00 05 03 03 
       0A 00 00 09 
       03 03 06 00 
       00 0D 03 03 
       03 03 06 00 
0436DD 00 00 00 00 0023*       db 00,00,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 00 00 
0436F9 00 00 00 00 0024*       db 00,00,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 00 00 
043715 00 00 00 00 0025*       db 00,00,00,00,00,00,12,00,00,09,03,03,07,03,03,07,03,03,10,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 09 03 03 
       07 03 03 07 
       03 03 0A 00 
       00 0C 00 00 
       00 00 00 00 
043731 00 00 00 00 0026*       db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
04374D 00 00 00 00 0027*       db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
043769 03 03 03 03 0028*       db 03,03,03,03,03,03,15,03,03,14,00,00,00,00,00,00,00,00,13,03,03,15,03,03,03,03,03,03
       03 03 0F 03 
       03 0E 00 00 
       00 00 00 00 
       00 00 0D 03 
       03 0F 03 03 
       03 03 03 03 
043785 00 00 00 00 0029*       db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
0437A1 00 00 00 00 0030*       db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
0437BD 00 00 00 00 0031*       db 00,00,00,00,00,00,12,00,00,13,03,03,03,03,03,03,03,03,14,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0D 03 03 
       03 03 03 03 
       03 03 0E 00 
       00 0C 00 00 
       00 00 00 00 
0437D9 00 00 00 00 0032*       db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
0437F5 00 00 00 00 0033*       db 00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
043811 00 09 03 03 0034*       db 00,09,03,03,03,03,15,03,03,07,03,03,10,00,00,09,03,03,07,03,03,15,03,03,03,03,10,00
       03 03 0F 03 
       03 07 03 03 
       0A 00 00 09 
       03 03 07 03 
       03 0F 03 03 
       03 03 0A 00 
04382D 00 0C 00 00 0035*       db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
043849 00 0C 00 00 0036*       db 00,12,00,00,00,00,12,00,00,00,00,00,12,00,00,12,00,00,00,00,00,12,00,00,00,00,12,00
       00 00 0C 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 0C 00 00 
       00 00 0C 00 
043865 00 05 03 0A 0037*       db 00,05,03,10,00,00,13,03,03,11,03,03,07,03,03,07,03,03,11,03,03,14,00,00,09,03,06,00
       00 00 0D 03 
       03 0B 03 03 
       07 03 03 07 
       03 03 0B 03 
       03 0E 00 00 
       09 03 06 00 
043881 00 00 00 0C 0038*       db 00,00,00,12,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,12,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       0C 00 00 00 
04389D 00 00 00 0C 0039*       db 00,00,00,12,00,00,12,00,00,12,00,00,00,00,00,00,00,00,12,00,00,12,00,00,12,00,00,00
       00 00 0C 00 
       00 0C 00 00 
       00 00 00 00 
       00 00 0C 00 
       00 0C 00 00 
       0C 00 00 00 
0438B9 00 09 03 07 0040*       db 00,09,03,07,03,03,06,00,00,05,03,03,10,00,00,09,03,03,06,00,00,05,03,03,07,03,10,00
       03 03 06 00 
       00 05 03 03 
       0A 00 00 09 
       03 03 06 00 
       00 05 03 03 
       07 03 0A 00 
0438D5 00 0C 00 00 0041*       db 00,12,00,00,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,00,00,12,00
       00 00 00 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 00 00 00 
       00 00 0C 00 
0438F1 00 0C 00 00 0042*       db 00,12,00,00,00,00,00,00,00,00,00,00,12,00,00,12,00,00,00,00,00,00,00,00,00,00,12,00
       00 00 00 00 
       00 00 00 00 
       0C 00 00 0C 
       00 00 00 00 
       00 00 00 00 
       00 00 0C 00 
04390D 00 05 03 03 0043*       db 00,05,03,03,03,03,03,03,03,03,03,03,07,03,03,07,03,03,03,03,03,03,03,03,03,03,06,00
       03 03 03 03 
       03 03 03 03 
       07 03 03 07 
       03 03 03 03 
       03 03 03 03 
       03 03 06 00 
043929 00 00 00 00 0044*       db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043945             0051        include "maze_pellets.inc"
043945             0001*   ; Generated by beegee747/build/scripts/build_99_asm_maze_walls.py
043945             0002*   
043945             0003*   maze_pellets:
043945 1C 00 00    0004*   maze_pellets_num_cols: dl 28
043948 1F 00 00    0005*   maze_pellets_num_rows: dl 31
04394B 08 00 00    0006*   maze_pellets_tile_size: dl 8
04394E 00 00 00    0007*   maze_pellets_null_tile: dl 0
043951 00 00 00    0008*   maze_pellets_x: dl 0
043954 00 00 00    0009*   maze_pellets_y: dl 0
043957 20 01 00    0010*   maze_pellets_base_bufferId: dl BUF_MAZE_PELLETS_00
04395A             0011*   
04395A             0012*   maze_pellets_map:
04395A 00 00 00 00 0013*       db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043976 00 01 01 01 0014*       db 00,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 00 00 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043992 00 01 00 00 0015*       db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
0439AE 00 02 00 00 0016*       db 00,02,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,02,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 02 00 
0439CA 00 01 00 00 0017*       db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
0439E6 00 01 01 01 0018*       db 00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043A02 00 01 00 00 0019*       db 00,01,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 01 00 
043A1E 00 01 00 00 0020*       db 00,01,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 01 00 
043A3A 00 01 01 01 0021*       db 00,01,01,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,01,01,00
       01 01 01 00 
       00 01 01 01 
       01 00 00 01 
       01 01 01 00 
       00 01 01 01 
       01 01 01 00 
043A56 00 00 00 00 0022*       db 00,00,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 00 00 
043A72 00 00 00 00 0023*       db 00,00,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 00 00 
043A8E 00 00 00 00 0024*       db 00,00,00,00,00,00,01,00,00,01,01,01,01,01,01,01,01,01,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 01 01 
       01 01 01 01 
       01 01 01 00 
       00 01 00 00 
       00 00 00 00 
043AAA 00 00 00 00 0025*       db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043AC6 00 00 00 00 0026*       db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043AE2 01 01 01 01 0027*       db 01,01,01,01,01,01,01,01,01,01,00,00,00,00,00,00,00,00,01,01,01,01,01,01,01,01,01,01
       01 01 01 01 
       01 01 00 00 
       00 00 00 00 
       00 00 01 01 
       01 01 01 01 
       01 01 01 01 
043AFE 00 00 00 00 0028*       db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B1A 00 00 00 00 0029*       db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B36 00 00 00 00 0030*       db 00,00,00,00,00,00,01,00,00,01,01,01,01,01,01,01,01,01,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 01 01 
       01 01 01 01 
       01 01 01 00 
       00 01 00 00 
       00 00 00 00 
043B52 00 00 00 00 0031*       db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B6E 00 00 00 00 0032*       db 00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
043B8A 00 01 01 01 0033*       db 00,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 00 00 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043BA6 00 01 00 00 0034*       db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
043BC2 00 01 00 00 0035*       db 00,01,00,00,00,00,01,00,00,00,00,00,01,00,00,01,00,00,00,00,00,01,00,00,00,00,01,00
       00 00 01 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 01 00 00 
       00 00 01 00 
043BDE 00 02 01 01 0036*       db 00,02,01,01,00,00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00,01,01,02,00
       00 00 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 00 00 
       01 01 02 00 
043BFA 00 00 00 01 0037*       db 00,00,00,01,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,01,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       01 00 00 00 
043C16 00 00 00 01 0038*       db 00,00,00,01,00,00,01,00,00,01,00,00,00,00,00,00,00,00,01,00,00,01,00,00,01,00,00,00
       00 00 01 00 
       00 01 00 00 
       00 00 00 00 
       00 00 01 00 
       00 01 00 00 
       01 00 00 00 
043C32 00 01 01 01 0039*       db 00,01,01,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,00,00,01,01,01,01,01,01,00
       01 01 01 00 
       00 01 01 01 
       01 00 00 01 
       01 01 01 00 
       00 01 01 01 
       01 01 01 00 
043C4E 00 01 00 00 0040*       db 00,01,00,00,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,00,00,01,00
       00 00 00 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 00 00 00 
       00 00 01 00 
043C6A 00 01 00 00 0041*       db 00,01,00,00,00,00,00,00,00,00,00,00,01,00,00,01,00,00,00,00,00,00,00,00,00,00,01,00
       00 00 00 00 
       00 00 00 00 
       01 00 00 01 
       00 00 00 00 
       00 00 00 00 
       00 00 01 00 
043C86 00 01 01 01 0042*       db 00,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 01 
       01 01 01 00 
043CA2 00 00 00 00 0043*       db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
043CBE             0052        include "player.inc"
043CBE             0001*   ; ######## GAME STATE VARIABLES #######
043CBE 00 00 00    0002*   player_score: dl 0 ; integer
043CC1 03          0003*   player_lives: db 3 ; integer
043CC2             0004*   speed_player: equ 0x000020 ; 0.125 map units per frame 16.8 fixed
043CC2             0005*   
043CC2             0006*   ; ######### PLAYER SPRITE PARAMETERS ##########
043CC2             0007*   ; uses the same offsets from its table base as the main sprite table:
043CC2             0008*   player_start_variables: ; label marking beginning of table
043CC2 0F          0009*   player_id:               db table_max_records-1
043CC3 00          0010*   player_type:             db     0x00 ; 1 bytes currently not used
043CC4 32 01 00    0011*   player_base_bufferId:    dl BUF_PAC_MAN_00_00 ; 3 bytes bitmap bufferId
043CC7 00 00 00    0012*   player_move_program:     dl 0x000000 ; 3 bytes not currently used
043CCA 00          0013*   player_collisions:       db     0x00 ; 1 bytes uses sprite_alive and sprite_just_died flags
043CCB 00          0014*   player_dim_x:            db     0x00 ; 1 bytes sprite width in pixels
043CCC 00          0015*   player_dim_y:            db     0x00 ; 1 bytes sprite height in pixels
043CCD 00 0D 00    0016*   player_x:                dl 0x000D00 ; 13 ; 3 bytes 16.8 fractional x position in pixels
043CD0 00 17 00    0017*   player_y:                dl 0x001700 ; 23 ; 3 bytes 16.8 fractional y position in pixels
043CD3 00 00 00    0018*   player_xvel:             dl 0x000000 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043CD6 00 00 00    0019*   player_yvel:             dl 0x000000 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043CD9 00 00 00    0020*   player_vel:              dl 0x000000 ; 3 bytes velocity px/frame (16.8 fixed)
043CDC 00 00 00    0021*   player_heading:          dl 0x000000 ; 3 bytes sprite movement direction deg256 16.8 fixed
043CDF 01 00 00    0022*   player_orientation:      dl 1 ; 3 bytes, low four bits are direction mask, bit 0 = right
043CE2 00          0023*   player_animation:        db     0x00 ; 1 bytes current animation index, zero-based
043CE3 08          0024*   player_animation_timer:  db     8 ; 1 bytes
043CE4 00          0025*   player_move_timer:       db     0x00 ; 1 bytes not currently used
043CE5 00          0026*   player_move_step:        db     0x00 ; 1 bytes not currently used
043CE6 00          0027*   player_points:           db     0x00 ; 1 bytes not currently used
043CE7 00          0028*   player_shield_damage:    db     0x00 ; 1 bytes not currently used
043CE8 00 00 00    0029*   player_current_cell:     dl 0x000000 ; 3 bytes current cell index
043CEB             0030*   player_end_variables: ; for when we want to traverse this table in reverse
043CEB             0031*   
043CEB             0032*   ; set initial player position
043CEB             0033*   ; inputs: none,everything is hardcoded
043CEB             0034*   ; outputs: player_x/y set to bottom-left corner of screen
043CEB             0035*   ; destroys: a
043CEB             0036*   player_init:
043CEB FD 21 C2 3C 0037*       ld iy,player_start_variables
       04          
043CF0 FD 7E 00    0038*   	ld a,(iy+sprite_id)
043CF3 CD 00 19 04 0039*   	call vdu_sprite_select
043CF7 CD 13 19 04 0040*       call vdu_sprite_clear_frames
043CFB 21 32 01 00 0041*       ld hl,BUF_PAC_MAN_00_00
043CFF 06 0C       0042*       ld b,12 ; number of frames in the sprite
043D01             0043*   @loop:
043D01 C5          0044*       push bc ; backup loop counter
043D02 E5          0045*       push hl
043D03 CD 55 1A 04 0046*       call vdu_sprite_add_buff
043D07 E1          0047*       pop hl
043D08 23          0048*       inc hl
043D09 C1          0049*       pop bc
043D0A 10 F5       0050*       djnz @loop
043D0C             0051*   ; initialize player position
043D0C 01 00 0D 00 0052*       ld bc,0x000D00 ; 13
043D10 11 00 17 00 0053*       ld de,0x001700 ; 23
043D14 FD 0F 0B    0054*       ld (iy+sprite_x),bc
043D17 FD 1F 0E    0055*       ld (iy+sprite_y),de
043D1A DD 21 CC 35 0056*       ld ix,maze_path
       04          
043D1F CD 82 2E 04 0057*       call map_get_cell_from_xy
043D23 FD 2F 26    0058*       ld (iy+sprite_current_cell),hl
043D26 DD 21 CC 35 0059*       ld ix,maze_path
       04          
043D2B CD 58 2E 04 0060*       call map_to_screen
043D2F CD CC 19 04 0061*       call vdu_sprite_move_abs168
043D33 CD 76 19 04 0062*       call vdu_sprite_show
043D37 21 96 43 04 0063*       ld hl,player_alive
043D3B 22 88 43 04 0064*       ld (player_state),hl
043D3F 21 CA 3C 04 0065*       ld hl,player_collisions
043D43 CB F6       0066*       set sprite_alive,(hl)
043D45             0067*   
043D45             0068*   ; ; DEBUG
043D45             0069*   ;     ld hl,speed_player
043D45             0070*   ;     ld (player_xvel),hl
043D45             0071*   ; ; END DEBUG
043D45 C9          0072*       ret
043D46             0073*   
043D46             0074*   ; process player keyboard input, set player bitmap
043D46             0075*   ; velocities and draw player bitmap at updated coordinates
043D46             0076*   ; Inputs: player_x/y set at desired position
043D46             0077*   ; Returns: player bitmap drawn at updated position
043D46             0078*   ; Destroys: probably everything except maybe iy
043D46             0079*   ; NOTE: in mode 9 we draw the player as a sprite, not a bitmap
043D46             0080*   ; TODO: requires sprite implementation
043D46             0081*   player_input:
043D46             0082*   ; set player as the active sprite
043D46 FD 21 C2 3C 0083*       ld iy,player_start_variables
       04          
043D4B FD 22 6D 41 0084*       ld (table_pointer),iy
       04          
043D50 FD 7E 00    0085*       ld a,(iy+sprite_id)
043D53 CD 00 19 04 0086*       call vdu_sprite_select
043D57             0087*   ; DEBUG
043D57 CD 00 13 04 0088*       call vdu_home_cursor
043D5B             0089*   ; END DEBUG
043D5B             0090*   ; did we die last frame?
043D5B FD 7E 08    0091*       ld a,(iy+sprite_collisions)
043D5E E6 02       0092*       and %00000010 ; zero flag will be set if not dead
043D60 28 05       0093*       jr z,player_not_dead
043D62             0094*   ; yes we died
043D62 CD B8 3E 04 0095*       call kill_player
043D66 C9          0096*       ret ; done
043D67             0097*   player_not_dead: ; yay we didn't die
043D67             0098*   ; check for keypresses and branch accordingly
043D67             0099*   ; for how this works,see: https://github.com/breakintoprogram/agon-docs/wiki/MOS-API-%E2%80%90-Virtual-Keyboard
043D67             0100*       MOSCALL	mos_getkbmap ;ix = pointer to MOS virtual keys table
043D67 3E 1E       0001*M1 			LD	A, function
043D69 5B CF       0002*M1 			RST.LIL	08h
043D6B             0101*   ; we test all four arrow keys and add/subract velocities accordingly
043D6B             0102*   ; this handles the case where two opposing movement keys
043D6B             0103*   ; are down simultaneously (velocities will net to zero)
043D6B AF          0104*       xor a ; reset orientation bits
043D6C             0105*   ; 26 Left: move player left
043D6C DD CB 03 4E 0106*       bit 1,(ix+3)
043D70 CA 76 3D 04 0107*       jp z,@F
043D74 CB CF       0108*       set orient_left,a
043D76             0109*   @@:
043D76             0110*   ; 122 Right: move player right
043D76 DD CB 0F 4E 0111*       bit 1,(ix+15)
043D7A CA 80 3D 04 0112*   	jp z,@F
043D7E CB C7       0113*       set orient_right,a
043D80             0114*   @@:
043D80             0115*   ; 58 Up: move player up
043D80 DD CB 07 4E 0116*       bit 1,(ix+7)
043D84 CA 8A 3D 04 0117*   	jp z,@F
043D88 CB D7       0118*       set orient_up,a
043D8A             0119*   @@:
043D8A             0120*   ; 42 Down: move player down
043D8A DD CB 05 4E 0121*       bit 1,(ix+5)
043D8E CA 94 3D 04 0122*   	jp z,@F
043D92 CB DF       0123*       set orient_down,a
043D94             0124*   @@:
043D94             0125*   ; test for no keyboard input
043D94 A7          0126*       and a
043D95 C2 A0 3D 04 0127*       jp nz,@F ; we have input
043D99 FD 7E 1D    0128*       ld a,(iy+sprite_orientation) ; use last orientation
043D9C C3 AB 3D 04 0129*       jp @animation_timer
043DA0             0130*   @@:
043DA0             0131*   ; test for more than one input key pressed
043DA0 47          0132*       ld b,a
043DA1 3D          0133*       dec a
043DA2 A0          0134*       and a,b
043DA3 78          0135*       ld a,b
043DA4             0136*   ; zero means only one key pressed
043DA4             0137*   ; (or none, if we had not done the zero check above)
043DA4 CA AB 3D 04 0138*       jp z,@animation_timer
043DA8 FD 7E 1D    0139*       ld a,(iy+sprite_orientation) ; use last orientation
043DAB             0140*       ; fall through to @animation_timer
043DAB             0141*   @animation_timer:
043DAB FD 77 1D    0142*       ld (iy+sprite_orientation),a
043DAE             0143*   ; time to bump the animation frame?
043DAE FD 35 21    0144*       dec (iy+sprite_animation_timer)
043DB1 C2 CA 3D 04 0145*       jp nz,@select_frame ; not time yet
043DB5             0146*   ; reset animation timer
043DB5 3E 08       0147*       ld a,8
043DB7 FD 77 21    0148*       ld (iy+sprite_animation_timer),a
043DBA             0149*   ; bump the animation frame
043DBA FD 34 20    0150*       inc (iy+sprite_animation)
043DBD             0151*   ; time to wrap around to first frame?
043DBD 3E 03       0152*       ld a,3
043DBF FD BE 20    0153*       cp a,(iy+sprite_animation)
043DC2 C2 CA 3D 04 0154*       jp nz,@select_frame ; not time yet
043DC6             0155*   ; reset animation frame
043DC6 AF          0156*       xor a
043DC7 FD 77 20    0157*       ld (iy+sprite_animation),a
043DCA             0158*       ; fall through to @select_frame
043DCA             0159*   @select_frame:
043DCA FD 7E 1D    0160*       ld a,(iy+sprite_orientation)
043DCD             0161*   ; find which bit is set in orientation
043DCD 2E 00       0162*       ld l,0 ; bit counter
043DCF             0163*   @find_bit:
043DCF 0F          0164*       rrca ; bit 0 to carry
043DD0 DA D9 3D 04 0165*       jp c,@found_bit
043DD4 2C          0166*       inc l ; next bit
043DD5 C3 CF 3D 04 0167*       jp @find_bit
043DD9             0168*   @found_bit:
043DD9 26 03       0169*       ld h,3 ; three frames per orientation
043DDB ED 6C       0170*       mlt hl
043DDD FD 7E 20    0171*       ld a,(iy+sprite_animation)
043DE0 85          0172*       add a,l
043DE1 CD 63 19 04 0173*       call vdu_sprite_select_frame
043DE5             0174*   ; set player velocities based on orientation
043DE5 FD 7E 1D    0175*       ld a,(iy+sprite_orientation)
043DE8 21 20 00 00 0176*       ld hl,speed_player
043DEC CD 85 3E 04 0177*       call velocity_from_orientation ; ub.c and ud.e are vel_x and vel_y in 16.8 fixed format
043DF0             0178*   ; compute preliminary new position based on velocities
043DF0             0179*   ; x-axis movement
043DF0 FD 27 0B    0180*       ld hl,(iy+sprite_x)
043DF3 09          0181*       add hl,bc
043DF4 E5          0182*       push hl
043DF5 C1          0183*       pop bc ; ub.c = preliminary x position
043DF6             0184*   ; y-axis movement
043DF6 FD 27 0E    0185*       ld hl,(iy+sprite_y)
043DF9 19          0186*       add hl,de ; uh.l = preliminary y position
043DFA             0187*   ; short diversion to get the path mask at the player's current position
043DFA FD 17 26    0188*       ld de,(iy+sprite_current_cell)
043DFD DD 21 E1 35 0189*       ld ix,maze_path_map
       04          
043E02 DD 19       0190*       add ix,de ; ix points to the current cell's path mask
043E04             0191*   ; now back to the y axis value
043E04 EB          0192*       ex de,hl ; ud.e = preliminary x position
043E05 CD A7 2E 04 0193*       call snap_to_path
043E09             0194*   ; save modified results back to sprite record
043E09 FD 0F 0B    0195*       ld (iy+sprite_x),bc
043E0C FD 1F 0E    0196*       ld (iy+sprite_y),de
043E0F             0197*   ; update current cell pointer with new position
043E0F DD 21 CC 35 0198*       ld ix,maze_path
       04          
043E14 CD 82 2E 04 0199*       call map_get_cell_from_xy
043E18 FD 2F 26    0200*       ld (iy+sprite_current_cell),hl
043E1B             0201*   ; convert new position to screen coordinates and draw sprite
043E1B DD 21 CC 35 0202*       ld ix,maze_path
       04          
043E20 CD 58 2E 04 0203*       call map_to_screen
043E24 CD CC 19 04 0204*   	call vdu_sprite_move_abs168
043E28             0205*   ; did we eat a pellet?
043E28 DD 21 45 39 0206*       ld ix,maze_pellets
       04          
043E2D FD 27 26    0207*       ld hl,(iy+sprite_current_cell)
043E30 CD 9A 2E 04 0208*       call map_get_cell_from_idx
043E34 A7          0209*       and a ; if zero cell was empty
043E35 C8          0210*       ret z ; ... so we're done
043E36             0211*   ; what kind of pellet did we eat?
043E36 FE 02       0212*       cp 2 ; big pellet
043E38 CA 79 3E 04 0213*       jp z,big_pellet ; will return to caller from there
043E3C             0214*       ; fall through to small_pellet
043E3C             0215*   ; end player_input
043E3C             0216*   
043E3C             0217*   ; process actions for eating a small pellet
043E3C             0218*   ; inputs: iy = player sprite record, ix = pointer to pellet cell, hl = cell index
043E3C             0219*   ; outputs: player_score incremented, pellet cell set to zero, pellet bitmap erased, eventually sound played
043E3C             0220*   ; destroys: everything except maybe iy
043E3C             0221*   small_pellet:
043E3C 11 0A 00 00 0222*       ld de,10 ; TODO: should be a constant
043E40             0223*   _pellet:
043E40 2A BE 3C 04 0224*       ld hl,(player_score)
043E44 19          0225*       add hl,de
043E45 22 BE 3C 04 0226*       ld (player_score),hl
043E49 DD 35 00    0227*       dec (ix) ; cell to zero = no pellet
043E4C 21 20 01 00 0228*       ld hl,BUF_MAZE_PELLETS_00 ; blank pellet bitmap
043E50             0229*       ; ld hl,BUF_FRUIT_0 ; DEBUG
043E50 CD 38 14 04 0230*       call vdu_buff_select
043E54 DD 21 45 39 0231*       ld ix,maze_pellets
       04          
043E59 FD 07 0B    0232*       ld bc,(iy+sprite_x)
043E5C FD 17 0E    0233*       ld de,(iy+sprite_y)
043E5F             0234*   ; TODO: make this a function
043E5F 3E 80       0235*       ld a,0x80 ; 0.5 map units in 16.8 fixed point format
043E61 4F          0236*       ld c,a ; snap to ...
043E62 5F          0237*       ld e,a ; cell centers
043E63 CD 58 2E 04 0238*       call map_to_screen
043E67 21 00 04 00 0239*       ld hl,4*256 ; offset to center the bitmap
043E6B 09          0240*       add hl,bc
043E6C E5          0241*       push hl
043E6D C1          0242*       pop bc
043E6E 21 00 04 00 0243*       ld hl,4*256 ; offset to center the bitmap
043E72 19          0244*       add hl,de
043E73 EB          0245*       ex de,hl
043E74 CD 3C 18 04 0246*       call vdu_plot_bmp168
043E78             0247*   ; END TODO
043E78 C9          0248*       ret
043E79             0249*   ; end small_pellet
043E79             0250*   
043E79             0251*   ; process actions for eating a big pellet
043E79             0252*   ; inputs: iy = player sprite record, ix = pointer to pellet cell, ub.c, ud.e = player's position
043E79             0253*   ; outputs: player_score incremented, pellet cell set to zero, pellet bitmap erased, eventually sound played
043E79             0254*   ;          enemies set to scared state
043E79             0255*   ; destroys: everything except maybe iy, and hopefully lots of ghosts
043E79             0256*   big_pellet:
043E79 CD 53 1B 04 0257*       call scare_ghosts ; TODO: implement this
043E7D 11 32 00 00 0258*       ld de,50 ; TODO: should be a constant
043E81 C3 40 3E 04 0259*       jp _pellet ; do the rest of the pellet processing
043E85             0260*   ; end big_pellet
043E85             0261*   
043E85             0262*   ; inputs: a = orientation, uh.l = speed in 16.8 fixed format
043E85             0263*   ; outputs: ub.c and ud.e are vel_x and vel_y in 16.8 fixed format
043E85             0264*   velocity_from_orientation:
043E85             0265*   ; initialize velocities to zero
043E85 01 00 00 00 0266*       ld bc,0
043E89 11 00 00 00 0267*       ld de,0
043E8D             0268*   ; test for orientation
043E8D CB 4F       0269*       bit orient_left,a
043E8F C2 A6 3E 04 0270*       jp nz,@left
043E93 CB 47       0271*       bit orient_right,a
043E95 C2 AD 3E 04 0272*       jp nz,@right
043E99 CB 57       0273*       bit orient_up,a
043E9B C2 B0 3E 04 0274*       jp nz,@up
043E9F CB 5F       0275*       bit orient_down,a
043EA1 C2 B6 3E 04 0276*       jp nz,@down
043EA5 C9          0277*       ret ; no orientation set so velocities are zero
043EA6             0278*   @left:
043EA6 CD 16 05 04 0279*       call neg_hlu
043EAA E5          0280*       push hl
043EAB C1          0281*       pop bc
043EAC C9          0282*       ret
043EAD             0283*   @right:
043EAD E5          0284*       push hl
043EAE C1          0285*       pop bc
043EAF C9          0286*       ret
043EB0             0287*   @up:
043EB0 CD 16 05 04 0288*       call neg_hlu
043EB4 EB          0289*       ex de,hl
043EB5 C9          0290*       ret
043EB6             0291*   @down:
043EB6 EB          0292*       ex de,hl
043EB7 C9          0293*       ret
043EB8             0294*   ; end velocity_from_orientation
043EB8             0295*   
043EB8             0296*   ; ###################################################################
043EB8             0297*   ; TODO: the below is all stuff from the original code we need to port
043EB8             0298*   ; ###################################################################
043EB8             0299*   
043EB8             0300*   kill_player:
043EB8             0301*   ; ; set player status to dead
043EB8             0302*   ;     xor a; sets all player flags to zero
043EB8             0303*   ;     ld (player_collisions),a
043EB8             0304*   ; ; deduct a player from the inventory
043EB8             0305*   ;     ld a,(player_lives)
043EB8             0306*   ;     dec a
043EB8             0307*   ;     ld (player_lives),a
043EB8             0308*   ; ; are we out of players?
043EB8             0309*   ;     jp z,game_over
043EB8             0310*   ; ; wait a few ticks
043EB8             0311*   ;     ld a,32 ; 32-cycle timer ~1/2 second at 60fps
043EB8             0312*   ;     ld (player_move_timer),a
043EB8             0313*   ; kill_player_loop:
043EB8             0314*   ;     call vdu_vblank
043EB8             0315*   ;     ld a,(player_move_timer)
043EB8             0316*   ;     dec a
043EB8             0317*   ;     ld (player_move_timer),a
043EB8             0318*   ;     jr nz,kill_player_loop
043EB8             0319*   ;     call player_init ; player respawn if timer zero
043EB8 C9          0320*       ret ; and out
043EB9             0321*   
043EB9             0322*   ; draws the player's shields level
043EB9             0323*   ; draw_shields:
043EB9             0324*   ; TODO: Agonize this routine
043EB9             0325*   ; ; prep the loop to draw the bars
043EB9             0326*   ;     ld a,(player_shields) ; snag shields
043EB9             0327*   ;     and a
043EB9             0328*   ;     ret z ; don't draw if zero shields
043EB9             0329*   ; ; set loop counter and drawing position
043EB9             0330*   ;     ld b,a ; loop counter
043EB9             0331*   ;     ld hl,#5300+48+12
043EB9             0332*   ; ; set color based on bars remaining
043EB9             0333*   ;     ld c,103 ; bright green 28fe0a
043EB9             0334*   ;     cp 9
043EB9             0335*   ;     jp p,draw_shields_loop
043EB9             0336*   ;     ld c,74 ; bright yellow eafe5b
043EB9             0337*   ;     cp 3
043EB9             0338*   ;     jp p,draw_shields_loop
043EB9             0339*   ;     ld c,28 ; bright red fe0a0a
043EB9             0340*   ; draw_shields_loop:
043EB9             0341*   ;     push bc ; yup,outta
043EB9             0342*   ;     push hl ; registers again
043EB9             0343*   ;     ; ld a,#A8 ; ▀,168
043EB9             0344*   ;     ld a,10 ; ▀,168 ; we renumber because we don't use the full charset
043EB9             0345*   ;     ; call draw_char
043EB9             0346*   ;     call draw_num ; we nuked draw_char for the time being
043EB9             0347*   ;     pop hl
043EB9             0348*   ;     ld a,8
043EB9             0349*   ;     add a,l
043EB9             0350*   ;     ld l,a
043EB9             0351*   ;     pop bc
043EB9             0352*   ;     djnz draw_shields_loop
043EB9             0353*       ; ret
043EB9             0354*   
043EB9             0355*   score_x: equ 0
043EB9             0356*   score_y: equ 1
043EB9             0357*   ; prints the player's score
043EB9             0358*   print_score:
043EB9             0359*   ; DEBUG
043EB9 0E 00       0360*       ld c,score_x
043EBB 06 00       0361*       ld b,score_y-1
043EBD CD 37 13 04 0362*       call vdu_move_cursor
043EC1 CD 00 01 04 0363*       call printInline
043EC5 53 63 6F 72 0364*       asciz "Score:"
       65 3A 00    
043ECC             0365*   ; END DEBUG
043ECC 0E 00       0366*       ld c,score_x
043ECE 06 01       0367*       ld b,score_y
043ED0 CD 37 13 04 0368*       call vdu_move_cursor
043ED4 2A BE 3C 04 0369*       ld hl,(player_score)
043ED8 CD 53 01 04 0370*       call printDec
043EDC C9          0371*       ret
043EDD             0372*   
043EDD             0373*   ; draw_lives:
043EDD             0374*   ;     ld hl,player_small ; make small yellow player the active sprite
043EDD             0375*   ;     ld (sprite_base_bufferId),hl
043EDD             0376*   ;     ; ld a,#80 ; northern orientation
043EDD             0377*   ;     ; ld (sprite_orientation),a
043EDD             0378*   ;     ld hl,0 ; north
043EDD             0379*   ;     ld (sprite_heading),hl
043EDD             0380*   ;     xor a
043EDD             0381*   ;     ld (sprite_animation),a
043EDD             0382*   ;     ld a,#56 ; top of visible screen
043EDD             0383*   ;     ld (sprite_y+1),a
043EDD             0384*   ;     call vdu_bmp_select ; TODO: convert to vdu_buff_select
043EDD             0385*   ;     ld a,(player_lives)
043EDD             0386*   ;     dec a ; we draw one fewer players than lives
043EDD             0387*   ;     ret z ; nothing to draw here, move along
043EDD             0388*   ;     ld b,a ; loop counter
043EDD             0389*   ;     ld a,256-16 ; initial x position
043EDD             0390*   ; draw_lives_loop:
043EDD             0391*   ;     ld (sprite_x+1),a
043EDD             0392*   ;     push af
043EDD             0393*   ;     push bc
043EDD             0394*   ;     call vdu_bmp_draw ; convert to vdu_bmp_plot
043EDD             0395*   ;     pop bc
043EDD             0396*   ;     pop af
043EDD             0397*   ;     sub 10
043EDD             0398*   ;     djnz draw_lives_loop
043EDD             0399*   ;     ret
043EDD             0053        include "sprites.inc"
043EDD             0001*   ; ###### SPRITE TABLE FIELD INDICES ######
043EDD             0002*   table_bytes_per_record: equ 41 ; 41 bytes per sprite record
043EDD             0003*   sprite_id:              equ 00 ; 1 bytes unique spriteId, zero-based
043EDD             0004*   sprite_type:            equ 01 ; 1 bytes type of sprite as defined in enemies.inc
043EDD             0005*   sprite_base_bufferId:   equ 02 ; 3 bytes bitmap bufferId
043EDD             0006*   sprite_move_program:    equ 05 ; 3 bytes address of sprite's behavior subroutine
043EDD             0007*   sprite_collisions:      equ 08 ; 1 bytes see collisions.inc constants for bit definitions
043EDD             0008*   sprite_dim_x:           equ 09 ; 1 bytes sprite width in pixels
043EDD             0009*   sprite_dim_y:           equ 10 ; 1 bytes sprite height in pixels
043EDD             0010*   sprite_x:               equ 11 ; 3 bytes 16.8 fractional x position in pixels
043EDD             0011*   sprite_y:               equ 14 ; 3 bytes 16.8 fractional y position in pixels
043EDD             0012*   sprite_xvel:            equ 17 ; 3 bytes x-component velocity, 16.8 fixed, pixels
043EDD             0013*   sprite_yvel:            equ 20 ; 3 bytes y-component velocity, 16.8 fixed, pixels
043EDD             0014*   sprite_vel:             equ 23 ; 3 bytes velocity px/frame (16.8 fixed)
043EDD             0015*   sprite_heading:         equ 26 ; 3 bytes sprite movement direction deg256 16.8 fixed
043EDD             0016*   sprite_orientation:     equ 29 ; 3 bytes orientation bits
043EDD             0017*   sprite_animation:       equ 32 ; 1 bytes current animation index, zero-based
043EDD             0018*   sprite_animation_timer: equ 33 ; 1 bytes when hits zero, draw next animation
043EDD             0019*   sprite_move_timer:      equ 34 ; 1 bytes when zero, go to next move program, or step
043EDD             0020*   sprite_move_step:       equ 35 ; 1 bytes stage in a move program sequence, varies
043EDD             0021*   sprite_points:          equ 36 ; 1 bytes points awarded for killing this sprite type
043EDD             0022*   sprite_shield_damage:   equ 37 ; 1 bytes shield points deducted for collision
043EDD             0023*   sprite_current_cell:    equ 38 ; 3 bytes current cell index
043EDD             0024*   
043EDD             0025*   ; ###### SPRITE TABLE VARIABLES ######
043EDD             0026*   ; maximum number of sprites
043EDD             0027*   table_max_records: equ 16 ; it can handle more but this is pushing it
043EDD             0028*   table_total_bytes: equ table_max_records*table_bytes_per_record
043EDD             0029*   
043EDD             0030*   ; #### THIS IS THE SPACE ALLOCATED TO THE SPRITE TABLE ####
043EDD             0031*   table_base:
043EDD 00 00 00 00 0032*   sprite_start_variables:  blkb table_total_bytes, 0 ; fill with zeroes
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04416D             0033*   sprite_end_variables: ; in case we want to traverse the table in reverse
04416D             0034*   
04416D             0035*   ; pointer to top address of current record, initialized to table_base
04416D DD 3E 04    0036*   table_pointer: dl table_base
044170             0037*   ; how many active sprites
044170 00          0038*   table_active_sprites: db 0x00
044171             0039*   ; flag indicating collision with screen edge
044171             0040*   ; uses orientation codes to specify which edge(s)
044171 00          0041*   sprite_screen_edge: db #00
044172             0042*   ; next sprite id to use
044172 00          0043*   sprite_next_id: db 0
044173             0044*   
044173             0045*   ; origin_top: equ 48
044173             0046*   origin_top: equ 0 ; DEBUG
044173             0047*   origin_left: equ 128
044173             0048*   field_top: equ 0
044173             0049*   field_bottom: equ 383-origin_top
044173             0050*   field_left: equ 0
044173             0051*   field_right: equ 255
044173             0052*   sprite_top: equ 0
044173             0053*   sprite_bottom: equ field_bottom-16
044173             0054*   sprite_left: equ field_left
044173             0055*   sprite_right: equ field_right-16
044173             0056*   
044173             0057*   ; ######### COLLISION SPRITE PARAMETERS ##########
044173             0058*   ; integer coordinates are all that are needed for collision calculations
044173 00          0059*   collision_x: db 0x00
044174 00          0060*   collision_y: db 0x00
044175 00          0061*   collision_dim_x: db 0x00
044176 00          0062*   collision_dim_y: db 0x00
044177             0063*   
044177             0064*   ; scratch variables
044177 00          0065*   x: db 0x00 ; 8-bit signed integer
044178 00          0066*   y: db 0x00 ; 8-bit signed integer
044179 00 00 00    0067*   x0: dl 0x000000 ; 16.8 signed fixed place
04417C 00 00 00    0068*   y0: dl 0x000000 ; 16.8 signed fixed place
04417F 00 00 00    0069*   incx1: dl 0x000000 ; 16.8 signed fixed place
044182 00 00 00    0070*   incy1: dl 0x000000 ; 16.8 signed fixed place
044185 00 00 00    0071*   incx2: dl 0x000000 ; 16.8 signed fixed place
044188 00 00 00    0072*   incy2: dl 0x000000 ; 16.8 signed fixed place
04418B             0073*   
04418B             0074*   ; sprite_heading: dl 0x000000 ; signed fixed 16.8
04418B 00 00 00    0075*   radius: dl 0x000000 ; signed fixed 16.8 (but should always be positive)
04418E 00 00 00    0076*   sin_sprite_heading: dl 0x000000 ; signed fixed 16.8
044191 00 00 00    0077*   cos_sprite_heading: dl 0x000000 ; signed fixed 16.8
044194             0078*   
044194             0079*   ; gets the next available sprite id
044194             0080*   ; inputs; none
044194             0081*   ; returns: if new sprite available, a = sprite id,
044194             0082*   ;           ix pointing to new sprite vars, carry set
044194             0083*   ;      otherwise, a = 0, carry flag reset, ix pointing to highest sprite vars
044194             0084*   ; destroys: a,b,hl,ix
044194             0085*   ; affects: bumps table_active_sprites by one
044194             0086*   table_get_next_id:
044194 DD 21 DD 3E 0087*       ld ix,table_base
       04          
044199 11 29 00 00 0088*       ld de,table_bytes_per_record
04419D 06 10       0089*       ld b,table_max_records
04419F             0090*   @loop:
04419F DD 7E 01    0091*       ld a,(ix+sprite_type)
0441A2 A7          0092*       and a
0441A3 28 06       0093*       jr z,@found
0441A5 DD 19       0094*       add ix,de
0441A7 10 F6       0095*       djnz @loop
0441A9             0096*   @notfound:
0441A9 AF          0097*       xor a ; a = 0 and reset carry flag indicating that we didn't find a free sprite
0441AA C9          0098*       ret
0441AB             0099*   @found:
0441AB             0100*   ; bump number of active sprites
0441AB 21 70 41 04 0101*       ld hl,table_active_sprites
0441AF 34          0102*       inc (hl)
0441B0             0103*   ; return sprite id
0441B0 3E 10       0104*       ld a,table_max_records
0441B2 90          0105*       sub b
0441B3 32 72 41 04 0106*       ld (sprite_next_id),a
0441B7 37          0107*       scf ; sets carry flag indicating we found a free sprite
0441B8 C9          0108*       ret ; done
0441B9             0109*   ; end table_get_next_id
0441B9             0110*   
0441B9             0111*   ; deactivate the sprite with the given id
0441B9             0112*   ; inputs: iy set to sprite record, vdu_sprite_select called
0441B9             0113*   ; outputs: nothing
0441B9             0114*   ; destroys: a,hl
0441B9             0115*   ; affects: decrements table_active_sprites by one
0441B9             0116*   table_deactivate_sprite:
0441B9 CD 84 19 04 0117*       call vdu_sprite_hide
0441BD AF          0118*       xor a
0441BE FD 77 01    0119*       ld (iy+sprite_type),a
0441C1 21 70 41 04 0120*       ld hl,table_active_sprites
0441C5 35          0121*       dec (hl)
0441C6 C9          0122*       ret
0441C7             0123*   ; end table_deactivate_sprite
0441C7             0124*   
0441C7             0125*   sprites_init:
0441C7             0126*   ; initialize sprites
0441C7 CD 34 1A 04 0127*   	call vdu_sprite_reset ; out of an abundance of caution (copilot: and paranoia)
0441CB AF          0128*   	xor a
0441CC             0129*   @sprite_loop:
0441CC F5          0130*   	push af
0441CD CD 00 19 04 0131*   	call vdu_sprite_select
0441D1 21 00 01 00 0132*   	ld hl,256 ; can be anything, so we just use the first one on the list
0441D5 CD 55 1A 04 0133*   	call vdu_sprite_add_buff
0441D9 F1          0134*   	pop af
0441DA 3C          0135*   	inc a
0441DB FE 10       0136*   	cp table_max_records
0441DD 20 ED       0137*   	jr nz,@sprite_loop
0441DF CD 34 19 04 0138*   	call vdu_sprite_activate
0441E3             0139*   ; all done
0441E3 C9          0140*       ret
0441E4             0141*   ; end sprites_init
0441E4             0142*   
0441E4             0143*   ; compute a sprite's new position based on its component x,y velocities
0441E4             0144*   ; with screen boundary checking and update its sprite table record accordingly
0441E4             0145*   ; inputs: table_pointer set to sprite record
0441E4             0146*   ; returns: updated x, y positions and edge collision flags in sprite table record
0441E4             0147*   ; destroys: everything
0441E4             0148*   ; note: actual rendering of sprite must be handled by caller
0441E4             0149*   move_sprite:
0441E4 FD 2A 6D 41 0150*       ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
0441E9             0151*   ; x-axis movement
0441E9 FD 27 0B    0152*       ld hl,(iy+sprite_x)
0441EC FD 17 11    0153*       ld de,(iy+sprite_xvel)
0441EF 19          0154*       add hl,de
0441F0 FD 2F 0B    0155*       ld (iy+sprite_x),hl
0441F3             0156*   ; y-axis movement
0441F3 FD 27 0E    0157*       ld hl,(iy+sprite_y)
0441F6 FD 17 14    0158*       ld de,(iy+sprite_yvel)
0441F9 19          0159*       add hl,de
0441FA FD 2F 0E    0160*       ld (iy+sprite_y),hl
0441FD             0161*   ; detect screen edge collisions
0441FD AF          0162*       xor a ; reset screen edge collision flag and clear carry
0441FE 32 71 41 04 0163*       ld (sprite_screen_edge),a
044202             0164*   ; y-axis first since we already have it in hl
044202 11 00 00 00 0165*       ld de,-sprite_top*256
044206 ED 5A       0166*       adc hl,de
044208 FA 32 42 04 0167*       jp m,@top
04420C ED 52       0168*       sbc hl,de ; hl back to original value
04420E 11 00 91 FE 0169*       ld de,-sprite_bottom*256
044212 ED 5A       0170*       adc hl,de
044214 F2 3C 42 04 0171*       jp p,@bottom
044218             0172*   @xaxis:
044218 FD 27 0B    0173*       ld hl,(iy+sprite_x)
04421B 11 00 00 00 0174*       ld de,-sprite_left*256
04421F ED 5A       0175*       adc hl,de
044221 FA 57 42 04 0176*       jp m,@left
044225 ED 52       0177*       sbc hl,de ; hl back to original value
044227 11 00 11 FF 0178*       ld de,-sprite_right*256
04422B ED 5A       0179*       adc hl,de
04422D F2 65 42 04 0180*       jp p,@right
044231             0181*   ; no edge collisions so go home
044231 C9          0182*       ret
044232             0183*   @top:
044232 3E 08       0184*       ld a,collide_top
044234 21 00 00 00 0185*       ld hl,sprite_top*256
044238 C3 42 42 04 0186*       jp @collide_y
04423C             0187*   @bottom:
04423C 3E 04       0188*       ld a,collide_bottom
04423E 21 00 6F 01 0189*       ld hl,sprite_bottom*256
044242             0190*   @collide_y:
044242 32 71 41 04 0191*       ld (sprite_screen_edge),a
044246 FD 2F 0E    0192*       ld (iy+sprite_y),hl
044249             0193*   ; reverse y-axis velocity
044249 FD 27 14    0194*       ld hl,(iy+sprite_yvel)
04424C CD 16 05 04 0195*       call neg_hlu
044250 FD 2F 14    0196*       ld (iy+sprite_yvel),hl
044253             0197*   ; go check for x-axis collisions
044253 C3 18 42 04 0198*       jp @xaxis
044257             0199*   @left:
044257 3A 71 41 04 0200*       ld a,(sprite_screen_edge)
04425B F6 02       0201*       or a,collide_left
04425D 21 00 00 00 0202*       ld hl,sprite_left*256
044261 C3 6F 42 04 0203*       jp @collide_x
044265             0204*   @right:
044265 3A 71 41 04 0205*       ld a,(sprite_screen_edge)
044269 F6 01       0206*       or a,collide_right
04426B 21 00 EF 00 0207*       ld hl,sprite_right*256
04426F             0208*   @collide_x:
04426F 32 71 41 04 0209*       ld (sprite_screen_edge),a
044273 FD 2F 0B    0210*       ld (iy+sprite_x),hl
044276             0211*   ; reverse x-axis velocity
044276 FD 27 11    0212*       ld hl,(iy+sprite_xvel)
044279 CD 16 05 04 0213*       call neg_hlu
04427D FD 2F 11    0214*       ld (iy+sprite_xvel),hl
044280             0215*   ; final collision flag to a and return
044280 3A 71 41 04 0216*       ld a,(sprite_screen_edge)
044284 C9          0217*       ret
044285             0218*   ; end move_sprite
044285             0219*   
044285             0220*   sprite_compute_velocities:
044285 FD 2A 6D 41 0221*       ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
04428A FD 17 17    0222*       ld de,(iy+sprite_vel)
04428D CD A0 07 04 0223*       call polar_to_cartesian
044291 FD 2A 6D 41 0224*       ld iy,(table_pointer) ; TODO: see if we can get IY to land here with the proper value
       04          
044296 FD 0F 11    0225*       ld (iy+sprite_xvel),bc ; save x-velocity component
044299 FD 1F 14    0226*       ld (iy+sprite_yvel),de ; save y-velocity component
04429C C9          0227*       ret
04429D             0228*   ; end sprite_compute_velocities
04429D             0054        include "state.inc"
04429D 00          0001*   cur_level: db 0
04429E             0002*   
04429E             0003*   init_level:
04429E             0004*   ; offset gfx origin to account for sprite size
04429E 01 88 00 00 0005*       ld bc,origin_left+8
0442A2 11 08 00 00 0006*       ld de,origin_top+8
0442A6 CD D0 13 04 0007*       call vdu_set_gfx_origin
0442AA             0008*   ; draw maze and pellets
0442AA DD 21 53 32 0009*       ld ix,maze_walls
       04          
0442AF 21 4E 01 00 0010*       ld hl,BUF_TILE_00
0442B3 CD C6 2D 04 0011*       call draw_maze
0442B7 DD 21 45 39 0012*       ld ix,maze_pellets
       04          
0442BC 21 20 01 00 0013*       ld hl,BUF_MAZE_PELLETS_00
0442C0 CD C6 2D 04 0014*       call draw_maze
0442C4             0015*   ; restore gfx origin to normal
0442C4 01 80 00 00 0016*       ld bc,origin_left
0442C8 11 00 00 00 0017*       ld de,origin_top
0442CC CD D0 13 04 0018*       call vdu_set_gfx_origin
0442D0 C9          0019*       ret
0442D1             0020*   
0442D1             0021*   ; Game state variables
0442D1 DF 42 04    0022*   game_state:  dl game_main_menu
0442D4             0023*   
0442D4             0024*   do_game:
0442D4 2A D1 42 04 0025*       ld hl,(game_state)   ; Load the current game state
0442D8             0026*       CALL_HL                ; Call the corresponding state handler
0442D8 01 DE 42 04 0001*M1     ld bc,$+6 ; Address of first instruction after the jump
0442DC C5          0002*M1     push bc ; which constitutes the return address
0442DD E9          0003*M1     jp (hl) ; Jump to the address in HL
0442DE C9          0027*       ret
0442DF             0028*   
0442DF             0029*   ; ========================
0442DF             0030*   ; Main Game States
0442DF             0031*   ; ========================
0442DF             0032*   
0442DF             0033*   game_main_menu:
0442DF             0034*       ; Handle main menu options
0442DF             0035*       ; Example: Check input for "Start Game"
0442DF CD B0 43 04 0036*       call check_input_menu
0442E3 C2 E8 42 04 0037*       jp nz, game_initialize ; Start game on selection
0442E7 C9          0038*       ret
0442E8             0039*   
0442E8             0040*   game_initialize:
0442E8             0041*   ; reset the sprite table
0442E8 AF          0042*       xor a
0442E9 32 70 41 04 0043*       ld (table_active_sprites),a
0442ED 21 DD 3E 04 0044*       ld hl,table_base
0442F1 22 6D 41 04 0045*       ld (table_pointer),hl
0442F5             0046*   ; initialize sprites
0442F5 CD C7 41 04 0047*       call sprites_init
0442F9             0048*   ; initialize the first level
0442F9 AF          0049*       xor a
0442FA 32 9D 42 04 0050*       ld (cur_level),a
0442FE CD 9E 42 04 0051*       call init_level
044302             0052*   ; initialize player
044302 21 00 00 00 0053*       ld hl,0
044306 22 BE 3C 04 0054*       ld (player_score),hl
04430A 3E 03       0055*       ld a,3
04430C 32 C1 3C 04 0056*       ld (player_lives),a
044310 CD EB 3C 04 0057*       call player_init
044314             0058*   ; set the game state to playing
044314 21 1E 43 04 0059*       ld hl,game_playing
044318 22 D1 42 04 0060*       ld (game_state), hl
04431C C9          0061*       ret
04431D             0062*   ; done initializing
04431D C9          0063*       ret
04431E             0064*   
04431E             0065*   game_playing:
04431E             0066*   ; Main gameplay loop
04431E CD 8B 43 04 0067*       call do_player
044322 CD 9C 43 04 0068*       call do_enemies
044326             0069*   ; update UI: TODO make this a standalone function
044326 CD B9 3E 04 0070*       call print_score
04432A C9          0071*       ret
04432B             0072*   
04432B             0073*   game_paused:
04432B             0074*       ; Pause menu logic
04432B CD B3 43 04 0075*       call check_input_pause
04432F C2 1E 43 04 0076*       jp nz, game_playing ; Resume game
044333 CA DF 42 04 0077*       jp z, game_main_menu ; Exit to main menu
044337 C9          0078*       ret
044338             0079*   
044338             0080*   game_level_transition:
044338             0081*       ; Handle level transitions
044338 CD B4 43 04 0082*       call load_next_level
04433C 21 1E 43 04 0083*       ld hl, game_playing
044340 22 D1 42 04 0084*       ld (game_state), hl
044344 C9          0085*       ret
044345             0086*   
044345             0087*   game_over:
044345             0088*       ; Display game over screen
044345 CD B5 43 04 0089*       call display_game_over
044349 C2 DF 42 04 0090*       jp nz, game_main_menu ; Return to main menu on input
04434D C9          0091*       ret
04434E             0092*   
04434E             0093*   game_victory:
04434E             0094*       ; Display victory screen
04434E CD B6 43 04 0095*       call display_victory
044352 C2 DF 42 04 0096*       jp nz, game_main_menu ; Return to main menu on input
044356 C9          0097*       ret
044357             0098*   
044357             0099*   ; ========================
044357             0100*   ; Supporting States
044357             0101*   ; ========================
044357             0102*   
044357             0103*   game_loading:
044357             0104*       ; Show loading screen while preparing assets
044357 CD B7 43 04 0105*       call load_resources
04435B 21 E8 42 04 0106*       ld hl, game_initialize
04435F 22 D1 42 04 0107*       ld (game_state), hl
044363 C9          0108*       ret
044364             0109*   
044364             0110*   game_cutscene:
044364             0111*       ; Play a non-interactive cutscene
044364 CD B8 43 04 0112*       call play_cutscene
044368 C2 1E 43 04 0113*       jp nz, game_playing ; Return to gameplay after cutscene
04436C C9          0114*       ret
04436D             0115*   
04436D             0116*   game_inventory:
04436D             0117*       ; Open inventory or shop
04436D CD B9 43 04 0118*       call display_inventory
044371 C2 1E 43 04 0119*       jp nz, game_playing ; Return to gameplay after inventory close
044375 C9          0120*       ret
044376             0121*   
044376             0122*   game_map:
044376             0123*       ; Display map or quest
044376 CD BA 43 04 0124*       call display_map
04437A C2 1E 43 04 0125*       jp nz, game_playing ; Return to gameplay after map close
04437E C9          0126*       ret
04437F             0127*   
04437F             0128*   game_exit:
04437F             0129*       ; Handle exit logic
04437F CD BB 43 04 0130*       call save_game
044383 C3 BC 43 04 0131*       jp exit_game         ; Safely shut down
044387 C9          0132*       ret
044388             0133*   
044388             0134*   ; ========================
044388             0135*   ; Sub-state branching (Example for player state)
044388             0136*   ; ========================
044388             0137*   
044388 96 43 04    0138*   player_state:  dl player_alive ; Player state variable
04438B             0139*   
04438B             0140*   do_player:
04438B 2A 88 43 04 0141*       ld hl,(player_state)
04438F             0142*       CALL_HL                ; Call the corresponding player state
04438F 01 95 43 04 0001*M1     ld bc,$+6 ; Address of first instruction after the jump
044393 C5          0002*M1     push bc ; which constitutes the return address
044394 E9          0003*M1     jp (hl) ; Jump to the address in HL
044395 C9          0143*       ret
044396             0144*   
044396             0145*   player_alive:
044396 CD 46 3D 04 0146*       call player_input     ; Handle player input
04439A C9          0147*       ret
04439B             0148*   
04439B             0149*   player_dead:
04439B C9          0150*       ret
04439C             0151*   
04439C             0152*   do_enemies:
04439C 2A A7 43 04 0153*       ld hl, (enemies_state)
0443A0             0154*       CALL_HL
0443A0 01 A6 43 04 0001*M1     ld bc,$+6 ; Address of first instruction after the jump
0443A4 C5          0002*M1     push bc ; which constitutes the return address
0443A5 E9          0003*M1     jp (hl) ; Jump to the address in HL
0443A6 C9          0155*       ret
0443A7 AA 43 04    0156*   enemies_state: dl enemies_dead
0443AA             0157*   enemies_dead:
0443AA C9          0158*       ret
0443AB             0159*   
0443AB             0160*   enemies_alive:
0443AB CD 9D 1A 04 0161*       call move_enemies
0443AF C9          0162*       ret
0443B0             0163*   
0443B0             0164*   check_input_menu:
0443B0 C9          0165*       ret
0443B1             0166*   
0443B1             0167*   update_game_world:
0443B1 C9          0168*       ret
0443B2             0169*   
0443B2             0170*   check_game_events:
0443B2 C9          0171*       ret
0443B3             0172*   
0443B3             0173*   check_input_pause:
0443B3 C9          0174*       ret
0443B4             0175*   
0443B4             0176*   load_next_level:
0443B4 C9          0177*       ret
0443B5             0178*   
0443B5             0179*   display_game_over:
0443B5 C9          0180*       ret
0443B6             0181*   
0443B6             0182*   display_victory:
0443B6 C9          0183*       ret
0443B7             0184*   
0443B7             0185*   load_resources:
0443B7 C9          0186*       ret
0443B8             0187*   
0443B8             0188*   play_cutscene:
0443B8 C9          0189*       ret
0443B9             0190*   
0443B9             0191*   display_inventory:
0443B9 C9          0192*       ret
0443BA             0193*   
0443BA             0194*   display_map:
0443BA C9          0195*       ret
0443BB             0196*   
0443BB             0197*   save_game:
0443BB C9          0198*       ret
0443BC             0199*   
0443BC             0200*   exit_game:
0443BC C9          0201*       ret
0443BD             0202*   
0443BD             0055        include "debug.inc"
0443BD FF FF FF FF 0001*       align 256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
044400             0002*   
044400             0003*   
044400             0004*   printHexA:
044400 F5          0005*       push af
044401 C5          0006*       push bc
044402 CD 35 01 04 0007*       call printHex8
044406 3E 20       0008*       ld a,' '
044408 5B D7       0009*       rst.lil 10h
04440A C1          0010*       pop bc
04440B F1          0011*       pop af
04440C C9          0012*       ret
04440D             0013*   
04440D             0014*   printHexHL:
04440D F5          0015*       push af
04440E C5          0016*       push bc
04440F CD 2F 01 04 0017*       call printHex16
044413 3E 20       0018*       ld a,' '
044415 5B D7       0019*       rst.lil 10h
044417 C1          0020*       pop bc
044418 F1          0021*       pop af
044419 C9          0022*       ret
04441A             0023*   
04441A             0024*   printHexUHL:
04441A F5          0025*       push af
04441B C5          0026*       push bc
04441C CD 27 01 04 0027*       call printHex24
044420 3E 20       0028*       ld a,' '
044422 5B D7       0029*       rst.lil 10h
044424 C1          0030*       pop bc
044425 F1          0031*       pop af
044426 C9          0032*       ret
044427             0033*   
044427             0034*   printHexAUHL:
044427 F5          0035*       push af
044428 C5          0036*       push bc
044429 CD 35 01 04 0037*       call printHex8
04442D 3E 2E       0038*       ld a,'.'
04442F 5B D7       0039*       rst.lil 10h
044431 CD 27 01 04 0040*       call printHex24
044435 3E 20       0041*       ld a,' '
044437 5B D7       0042*       rst.lil 10h
044439 C1          0043*       pop bc
04443A F1          0044*       pop af
04443B C9          0045*       ret
04443C             0046*   
04443C             0047*   printHexABHL:
04443C             0048*   ; preserve registers
04443C C5          0049*       push bc ; b will be ok c will not
04443D F5          0050*       push af ; will get totally destroyed
04443E             0051*   ; print a
04443E CD 35 01 04 0052*       call printHex8
044442             0053*   ; print b
044442 78          0054*       ld a,b
044443 CD 35 01 04 0055*       call printHex8
044447             0056*   ; print hl
044447 CD 2F 01 04 0057*       call printHex16
04444B             0058*   ; restore registers
04444B F1          0059*       pop af
04444C C1          0060*       pop bc
04444D C9          0061*       ret
04444E             0062*   
04444E             0063*   printHexBHL:
04444E             0064*   ; preserve registers
04444E C5          0065*       push bc ; b will be ok c will not
04444F F5          0066*       push af ; will get totally destroyed
044450             0067*   ; print b
044450 78          0068*       ld a,b
044451 CD 35 01 04 0069*       call printHex8
044455             0070*   ; print hl
044455 CD 2F 01 04 0071*       call printHex16
044459             0072*   ; restore registers
044459 F1          0073*       pop af
04445A C1          0074*       pop bc
04445B C9          0075*       ret
04445C             0076*   
04445C             0077*   printHexCDE:
04445C             0078*   ; preserve registers
04445C C5          0079*       push bc ; b will be ok c will not
04445D F5          0080*       push af ; will get totally destroyed
04445E             0081*   ; print c
04445E 79          0082*       ld a,c
04445F CD 35 01 04 0083*       call printHex8
044463             0084*   ; print de
044463 EB          0085*       ex de,hl
044464 CD 2F 01 04 0086*       call printHex16
044468 EB          0087*       ex de,hl
044469             0088*   ; restore registers
044469 F1          0089*       pop af
04446A C1          0090*       pop bc
04446B C9          0091*       ret
04446C             0092*   
04446C             0093*   printHexUIX:
04446C             0094*   ; store everything in scratch
04446C 22 BC 03 04 0095*       ld (uhl),hl
044470 ED 43 BF 03 0096*       ld (ubc),bc
       04          
044475 ED 53 C2 03 0097*       ld (ude),de
       04          
04447A DD 22 C5 03 0098*       ld (uix),ix
       04          
04447F FD 22 C8 03 0099*       ld (uiy),iy
       04          
044484 F5          0100*       push af ; fml
044485             0101*   
044485 21 53 03 04 0102*       ld hl,str_ixu
044489 CD 07 01 04 0103*       call printString
04448D 2A C5 03 04 0104*       ld hl,(uix)
044491 CD 27 01 04 0105*       call printHex24
044495 CD 1C 01 04 0106*       call printNewLine
044499             0107*   
044499             0108*   ; restore everything
044499 2A BC 03 04 0109*       ld hl, (uhl)
04449D ED 4B BF 03 0110*       ld bc, (ubc)
       04          
0444A2 ED 5B C2 03 0111*       ld de, (ude)
       04          
0444A7 DD 2A C5 03 0112*       ld ix, (uix)
       04          
0444AC FD 2A C8 03 0113*       ld iy, (uiy)
       04          
0444B1 F1          0114*       pop af
0444B2             0115*   ; all done
0444B2 C9          0116*       ret
0444B3             0117*   
0444B3             0118*   
0444B3             0119*   ; print registers to screen in hexidecimal format
0444B3             0120*   ; inputs: none
0444B3             0121*   ; outputs: values of every register printed to screen
0444B3             0122*   ;    values of each register in global scratch memory
0444B3             0123*   ; destroys: nothing
0444B3             0124*   stepRegistersHex:
0444B3             0125*   ; store everything in scratch
0444B3 22 BC 03 04 0126*       ld (uhl),hl
0444B7 ED 43 BF 03 0127*       ld (ubc),bc
       04          
0444BC ED 53 C2 03 0128*       ld (ude),de
       04          
0444C1 DD 22 C5 03 0129*       ld (uix),ix
       04          
0444C6 FD 22 C8 03 0130*       ld (uiy),iy
       04          
0444CB F5          0131*       push af ; fml
0444CC E1          0132*       pop hl ; thanks, zilog
0444CD 22 B9 03 04 0133*       ld (uaf),hl
0444D1 F5          0134*       push af ; dammit
0444D2             0135*   
0444D2             0136*   ; home the cursor
0444D2             0137*       ; call vdu_home_cursor
0444D2             0138*   
0444D2             0139*   ; print each register
0444D2 21 3F 03 04 0140*       ld hl,str_afu
0444D6 CD 07 01 04 0141*       call printString
0444DA 2A B9 03 04 0142*       ld hl,(uaf)
0444DE CD 27 01 04 0143*       call printHex24
0444E2 CD 1C 01 04 0144*       call printNewLine
0444E6             0145*   
0444E6 21 44 03 04 0146*       ld hl,str_hlu
0444EA CD 07 01 04 0147*       call printString
0444EE 2A BC 03 04 0148*       ld hl,(uhl)
0444F2 CD 27 01 04 0149*       call printHex24
0444F6 CD 1C 01 04 0150*       call printNewLine
0444FA             0151*   
0444FA 21 49 03 04 0152*       ld hl,str_bcu
0444FE CD 07 01 04 0153*       call printString
044502 2A BF 03 04 0154*       ld hl,(ubc)
044506 CD 27 01 04 0155*       call printHex24
04450A CD 1C 01 04 0156*       call printNewLine
04450E             0157*   
04450E 21 4E 03 04 0158*       ld hl,str_deu
044512 CD 07 01 04 0159*       call printString
044516 2A C2 03 04 0160*       ld hl,(ude)
04451A CD 27 01 04 0161*       call printHex24
04451E CD 1C 01 04 0162*       call printNewLine
044522             0163*   
044522 21 53 03 04 0164*       ld hl,str_ixu
044526 CD 07 01 04 0165*       call printString
04452A 2A C5 03 04 0166*       ld hl,(uix)
04452E CD 27 01 04 0167*       call printHex24
044532 CD 1C 01 04 0168*       call printNewLine
044536             0169*   
044536 21 58 03 04 0170*       ld hl,str_iyu
04453A CD 07 01 04 0171*       call printString
04453E 2A C8 03 04 0172*       ld hl,(uiy)
044542 CD 27 01 04 0173*       call printHex24
044546 CD 1C 01 04 0174*       call printNewLine
04454A             0175*   
04454A             0176*       ; call vsync
04454A             0177*   
04454A CD 1C 01 04 0178*       call printNewLine
04454E             0179*   
04454E             0180*   ; check for right shift key and quit if pressed
04454E             0181*       MOSCALL mos_getkbmap
04454E 3E 1E       0001*M1 			LD	A, function
044550 5B CF       0002*M1 			RST.LIL	08h
044552             0182*   @stayhere:
044552             0183*   ; 7 RightShift
044552 DD CB 00 76 0184*       bit 6,(ix+0)
044556 20 02       0185*       jr nz,@RightShift
044558 18 F8       0186*       jr @stayhere
04455A             0187*   @RightShift:
04455A DD CB 0E 86 0188*       res 0,(ix+14) ; debounce the key (hopefully)
04455E 3E 80       0189*       ld a,%10000000
044560             0190*       ; call multiPurposeDelay
044560             0191*   
044560             0192*   ; restore everything
044560 2A BC 03 04 0193*       ld hl, (uhl)
044564 ED 4B BF 03 0194*       ld bc, (ubc)
       04          
044569 ED 5B C2 03 0195*       ld de, (ude)
       04          
04456E DD 2A C5 03 0196*       ld ix, (uix)
       04          
044573 FD 2A C8 03 0197*       ld iy, (uiy)
       04          
044578 F1          0198*       pop af
044579             0199*   ; all done
044579 C9          0200*       ret
04457A             0201*   
04457A             0202*   ; print registers to screen in hexidecimal format
04457A             0203*   ; inputs: none
04457A             0204*   ; outputs: values of every register printed to screen
04457A             0205*   ;    values of each register in global scratch memory
04457A             0206*   ; destroys: nothing
04457A             0207*   dumpRegistersHex:
04457A             0208*   ; store everything in scratch
04457A 22 BC 03 04 0209*       ld (uhl),hl
04457E ED 43 BF 03 0210*       ld (ubc),bc
       04          
044583 ED 53 C2 03 0211*       ld (ude),de
       04          
044588 DD 22 C5 03 0212*       ld (uix),ix
       04          
04458D FD 22 C8 03 0213*       ld (uiy),iy
       04          
044592 F5          0214*       push af ; fml
044593 E1          0215*       pop hl ; thanks, zilog
044594 22 B9 03 04 0216*       ld (uaf),hl
044598 F5          0217*       push af ; dammit
044599             0218*   
044599             0219*   ; home the cursor
044599             0220*       ; call vdu_home_cursor
044599             0221*       ; call printNewLine
044599             0222*   
044599             0223*   ; print each register
044599 21 3F 03 04 0224*       ld hl,str_afu
04459D CD 07 01 04 0225*       call printString
0445A1 2A B9 03 04 0226*       ld hl,(uaf)
0445A5 CD 27 01 04 0227*       call printHex24
0445A9 CD 1C 01 04 0228*       call printNewLine
0445AD             0229*   
0445AD 21 44 03 04 0230*       ld hl,str_hlu
0445B1 CD 07 01 04 0231*       call printString
0445B5 2A BC 03 04 0232*       ld hl,(uhl)
0445B9 CD 27 01 04 0233*       call printHex24
0445BD CD 1C 01 04 0234*       call printNewLine
0445C1             0235*   
0445C1 21 49 03 04 0236*       ld hl,str_bcu
0445C5 CD 07 01 04 0237*       call printString
0445C9 2A BF 03 04 0238*       ld hl,(ubc)
0445CD CD 27 01 04 0239*       call printHex24
0445D1 CD 1C 01 04 0240*       call printNewLine
0445D5             0241*   
0445D5 21 4E 03 04 0242*       ld hl,str_deu
0445D9 CD 07 01 04 0243*       call printString
0445DD 2A C2 03 04 0244*       ld hl,(ude)
0445E1 CD 27 01 04 0245*       call printHex24
0445E5 CD 1C 01 04 0246*       call printNewLine
0445E9             0247*   
0445E9 21 53 03 04 0248*       ld hl,str_ixu
0445ED CD 07 01 04 0249*       call printString
0445F1 2A C5 03 04 0250*       ld hl,(uix)
0445F5 CD 27 01 04 0251*       call printHex24
0445F9 CD 1C 01 04 0252*       call printNewLine
0445FD             0253*   
0445FD 21 58 03 04 0254*       ld hl,str_iyu
044601 CD 07 01 04 0255*       call printString
044605 2A C8 03 04 0256*       ld hl,(uiy)
044609 CD 27 01 04 0257*       call printHex24
04460D             0258*   
04460D CD 1C 01 04 0259*       call printNewLine
044611 CD 1C 01 04 0260*       call printNewLine
044615             0261*   ; restore everything
044615 2A BC 03 04 0262*       ld hl, (uhl)
044619 ED 4B BF 03 0263*       ld bc, (ubc)
       04          
04461E ED 5B C2 03 0264*       ld de, (ude)
       04          
044623 DD 2A C5 03 0265*       ld ix, (uix)
       04          
044628 FD 2A C8 03 0266*       ld iy, (uiy)
       04          
04462D F1          0267*       pop af
04462E             0268*   ; all done
04462E C9          0269*       ret
04462F             0270*   
04462F             0271*   dumpRegistersHexPrime:
04462F D9          0272*       exx
044630 08          0273*       ex af,af'
044631 CD 7A 45 04 0274*       call dumpRegistersHex
044635 08          0275*       ex af,af'
044636 D9          0276*       exx
044637 C9          0277*       ret
044638             0278*   
044638             0279*   ; additionally dump prime registers
044638             0280*   ; inputs: none
044638             0281*   ; outputs: values of every register printed to screen
044638             0282*   ; destroys: nothing
044638             0283*   dumpRegistersHexAll:
044638 CD 7A 45 04 0284*       call dumpRegistersHex
04463C 08          0285*       ex af,af'
04463D D9          0286*       exx
04463E CD 7A 45 04 0287*       call dumpRegistersHex
044642 08          0288*       ex af,af'
044643 D9          0289*       exx
044644 C9          0290*       ret
044645             0291*   
044645             0292*   ; print hlu to screen in hexidecimal format
044645             0293*   ; inputs: none
044645             0294*   ; destroys: nothing
044645             0295*   print_hex_hl:
044645 F5          0296*       push af
044646 E5          0297*       push hl
044647 21 44 03 04 0298*       ld hl,str_hlu
04464B CD 07 01 04 0299*       call printString
04464F E1          0300*       pop hl
044650 E5          0301*       push hl
044651 CD 27 01 04 0302*       call printHex24
044655 3E 20       0303*       ld a,' '
044657 5B D7       0304*       rst.lil 10h
044659 E1          0305*       pop hl
04465A F1          0306*       pop af
04465B C9          0307*       ret
04465C             0308*   
04465C             0309*   ; print bcu to screen in hexidecimal format
04465C             0310*   ; inputs: none
04465C             0311*   ; destroys: nothing
04465C             0312*   print_hex_bc:
04465C F5          0313*       push af
04465D E5          0314*       push hl
04465E C5          0315*       push bc
04465F 21 49 03 04 0316*       ld hl,str_bcu
044663 CD 07 01 04 0317*       call printString
044667 E1          0318*       pop hl
044668 E5          0319*       push hl
044669 CD 27 01 04 0320*       call printHex24
04466D 3E 20       0321*       ld a,' '
04466F 5B D7       0322*       rst.lil 10h
044671 C1          0323*       pop bc
044672 E1          0324*       pop hl
044673 F1          0325*       pop af
044674 C9          0326*       ret
044675             0327*   
044675             0328*   ; print deu to screen in hexidecimal format
044675             0329*   ; inputs: none
044675             0330*   ; destroys: nothing
044675             0331*   print_hex_de:
044675 F5          0332*       push af
044676 E5          0333*       push hl
044677 D5          0334*       push de
044678 21 4E 03 04 0335*       ld hl,str_deu
04467C CD 07 01 04 0336*       call printString
044680 E1          0337*       pop hl
044681 E5          0338*       push hl
044682 CD 27 01 04 0339*       call printHex24
044686 3E 20       0340*       ld a,' '
044688 5B D7       0341*       rst.lil 10h
04468A D1          0342*       pop de
04468B E1          0343*       pop hl
04468C F1          0344*       pop af
04468D C9          0345*       ret
04468E             0346*   
04468E             0347*   
04468E             0348*   ; inputs: whatever is in the flags register
04468E             0349*   ; outputs: binary representation of flags
04468E             0350*   ;          with a header so we know which is what
04468E             0351*   ; destroys: nothing
04468E             0352*   ; preserves: everything
04468E             0353*   dumpFlags:
04468E             0354*   ; first we curse zilog for not giving direct access to flags
04468E F5          0355*       push af ; this is so we can send it back unharmed
04468F F5          0356*       push af ; this is so we can pop it to hl
044690             0357*   ; store everything in scratch
044690 22 BC 03 04 0358*       ld (uhl),hl
044694 ED 43 BF 03 0359*       ld (ubc),bc
       04          
044699 ED 53 C2 03 0360*       ld (ude),de
       04          
04469E DD 22 C5 03 0361*       ld (uix),ix
       04          
0446A3 FD 22 C8 03 0362*       ld (uiy),iy
       04          
0446A8             0363*   ; next we print the header
0446A8 21 D4 46 04 0364*       ld hl,@header
0446AC CD 07 01 04 0365*       call printString
0446B0 E1          0366*       pop hl ; flags are now in l
0446B1 7D          0367*       ld a,l ; flags are now in a
0446B2 CD F5 02 04 0368*       call printBin8
0446B6 CD 1C 01 04 0369*       call printNewLine
0446BA             0370*   ; restore everything
0446BA 2A BC 03 04 0371*       ld hl, (uhl)
0446BE ED 4B BF 03 0372*       ld bc, (ubc)
       04          
0446C3 ED 5B C2 03 0373*       ld de, (ude)
       04          
0446C8 DD 2A C5 03 0374*       ld ix, (uix)
       04          
0446CD FD 2A C8 03 0375*       ld iy, (uiy)
       04          
0446D2 F1          0376*       pop af ; send her home the way she came
0446D3 C9          0377*       ret
0446D4             0378*   ; Bit 7 (S): Sign flag
0446D4             0379*   ; Bit 6 (Z): Zero flag
0446D4             0380*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0446D4             0381*   ; Bit 4 (H): Half Carry flag
0446D4             0382*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0446D4             0383*   ; Bit 2 (PV): Parity/Overflow flag
0446D4             0384*   ; Bit 1 (N): Subtract flag
0446D4             0385*   ; Bit 0 (C): Carry flag
0446D4 53 5A 78 48 0386*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0446DF             0387*   
0446DF             0388*   
0446DF             0389*   ; print bytes from an address to the screen in hexidecimal format
0446DF             0390*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0446DF             0391*   ; outputs: values of each byte printed to screen separated by spaces
0446DF             0392*   ; destroys: nothing
0446DF             0393*   dumpMemoryHex:
0446DF             0394*   ; save registers to the stack
0446DF C5          0395*       push bc
0446E0 E5          0396*       push hl
0446E1 F5          0397*       push af
0446E2             0398*   
0446E2             0399*   ; print the address and separator
0446E2 CD 27 01 04 0400*       call printHex24
0446E6 3E 3A       0401*       ld a,':'
0446E8 5B D7       0402*       rst.lil 10h
0446EA 3E 20       0403*       ld a,' '
0446EC 5B D7       0404*       rst.lil 10h
0446EE             0405*   
0446EE             0406*   ; set b to be our loop counter
0446EE F1          0407*       pop af
0446EF 47          0408*       ld b,a
0446F0 E1          0409*       pop hl
0446F1 E5          0410*       push hl
0446F2 F5          0411*       push af
0446F3             0412*   @loop:
0446F3             0413*   ; print the byte
0446F3 7E          0414*       ld a,(hl)
0446F4 CD 35 01 04 0415*       call printHex8
0446F8             0416*   ; print a space
0446F8 3E 20       0417*       ld a,' '
0446FA 5B D7       0418*       rst.lil 10h
0446FC 23          0419*       inc hl
0446FD 10 F4       0420*       djnz @loop
0446FF CD 1C 01 04 0421*       call printNewLine
044703             0422*   
044703             0423*   ; restore everything
044703 F1          0424*       pop af
044704 E1          0425*       pop hl
044705 C1          0426*       pop bc
044706             0427*   
044706             0428*   ; all done
044706 C9          0429*       ret
044707             0430*   
044707             0431*   
044707             0432*   ; print bytes from an address to the screen in binary format
044707             0433*   ; inputs: hl = address of first byte to print, a = number of bytes to print
044707             0434*   ; outputs: values of each byte printed to screen separated by spaces
044707             0435*   ; destroys: nothing
044707             0436*   dumpMemoryBin:
044707             0437*   ; save all registers to the stack
044707 F5          0438*       push af
044708 C5          0439*       push bc
044709 D5          0440*       push de
04470A E5          0441*       push hl
04470B DD E5       0442*       push ix
04470D FD E5       0443*       push iy
04470F             0444*   
04470F             0445*   ; set b to be our loop counter
04470F 47          0446*       ld b,a
044710             0447*   @loop:
044710             0448*   ; print the byte
044710 7E          0449*       ld a,(hl)
044711 E5          0450*       push hl
044712 C5          0451*       push bc
044713 CD F5 02 04 0452*       call printBin8
044717 C1          0453*       pop bc
044718             0454*   ; print a space
044718 3E 20       0455*       ld a,' '
04471A 5B D7       0456*       rst.lil 10h
04471C E1          0457*       pop hl
04471D 23          0458*       inc hl
04471E 10 F0       0459*       djnz @loop
044720 CD 1C 01 04 0460*       call printNewLine
044724             0461*   
044724             0462*   ; restore everything
044724 FD E1       0463*       pop iy
044726 DD E1       0464*       pop ix
044728 E1          0465*       pop hl
044729 D1          0466*       pop de
04472A C1          0467*       pop bc
04472B F1          0468*       pop af
04472C             0469*   ; all done
04472C C9          0470*       ret
04472D             0471*   
04472D             0472*   ; print bytes from an address to the screen in binary format
04472D             0473*   ; with the bits of each byte in reverse order (lsb first)
04472D             0474*   ; inputs: hl = address of first byte to print, a = number of bytes to print
04472D             0475*   ; outputs: values of each byte printed to screen separated by spaces
04472D             0476*   ; destroys: nothing
04472D             0477*   dumpMemoryBinRev:
04472D             0478*   ; save all registers to the stack
04472D F5          0479*       push af
04472E C5          0480*       push bc
04472F D5          0481*       push de
044730 E5          0482*       push hl
044731 DD E5       0483*       push ix
044733 FD E5       0484*       push iy
044735             0485*   
044735             0486*   ; set b to be our loop counter
044735 47          0487*       ld b,a
044736             0488*   @loop:
044736             0489*   ; print the byte
044736 7E          0490*       ld a,(hl)
044737 E5          0491*       push hl
044738 C5          0492*       push bc
044739 CD 1A 03 04 0493*       call printBin8Rev
04473D C1          0494*       pop bc
04473E             0495*   ; print a space
04473E 3E 20       0496*       ld a,' '
044740 5B D7       0497*       rst.lil 10h
044742 E1          0498*       pop hl
044743 23          0499*       inc hl
044744 10 F0       0500*       djnz @loop
044746 CD 1C 01 04 0501*       call printNewLine
04474A             0502*   
04474A             0503*   ; restore everything
04474A FD E1       0504*       pop iy
04474C DD E1       0505*       pop ix
04474E E1          0506*       pop hl
04474F D1          0507*       pop de
044750 C1          0508*       pop bc
044751 F1          0509*       pop af
044752             0510*   ; all done
044752 C9          0511*       ret
044753             0512*   
044753             0513*   DEBUG_PRINT:
044753             0514*       PUSH_ALL
044753 08          0001*M1     ex af,af'
044754 D9          0002*M1     exx
044755 F5          0003*M1     push af
044756 E5          0004*M1     push hl
044757 C5          0005*M1     push bc
044758 D5          0006*M1     push de
044759             0007*M1 
044759 08          0008*M1     ex af,af'
04475A D9          0009*M1     exx
04475B F5          0010*M1     push af
04475C E5          0011*M1     push hl
04475D C5          0012*M1     push bc
04475E D5          0013*M1     push de
04475F DD E5       0014*M1     push ix
044761 FD E5       0015*M1     push iy
044763 0E 00       0515*       ld c,0 ; X
044765 06 00       0516*       ld b,0 ; Y
044767 CD 37 13 04 0517*       call vdu_move_cursor
04476B             0518*       POP_ALL
04476B FD E1       0001*M1     pop iy
04476D DD E1       0002*M1     pop ix
04476F D1          0003*M1     pop de
044770 C1          0004*M1     pop bc
044771 E1          0005*M1     pop hl
044772 F1          0006*M1     pop af
044773 08          0007*M1     ex af,af'
044774 D9          0008*M1     exx
044775             0009*M1 
044775 D1          0010*M1     pop de
044776 C1          0011*M1     pop bc
044777 E1          0012*M1     pop hl
044778 F1          0013*M1     pop af
044779 08          0014*M1     ex af,af'
04477A D9          0015*M1     exx
04477B             0519*       PUSH_ALL
04477B 08          0001*M1     ex af,af'
04477C D9          0002*M1     exx
04477D F5          0003*M1     push af
04477E E5          0004*M1     push hl
04477F C5          0005*M1     push bc
044780 D5          0006*M1     push de
044781             0007*M1 
044781 08          0008*M1     ex af,af'
044782 D9          0009*M1     exx
044783 F5          0010*M1     push af
044784 E5          0011*M1     push hl
044785 C5          0012*M1     push bc
044786 D5          0013*M1     push de
044787 DD E5       0014*M1     push ix
044789 FD E5       0015*M1     push iy
04478B CD 8E 46 04 0520*       call dumpFlags
04478F             0521*       POP_ALL
04478F FD E1       0001*M1     pop iy
044791 DD E1       0002*M1     pop ix
044793 D1          0003*M1     pop de
044794 C1          0004*M1     pop bc
044795 E1          0005*M1     pop hl
044796 F1          0006*M1     pop af
044797 08          0007*M1     ex af,af'
044798 D9          0008*M1     exx
044799             0009*M1 
044799 D1          0010*M1     pop de
04479A C1          0011*M1     pop bc
04479B E1          0012*M1     pop hl
04479C F1          0013*M1     pop af
04479D 08          0014*M1     ex af,af'
04479E D9          0015*M1     exx
04479F             0522*       PUSH_ALL
04479F 08          0001*M1     ex af,af'
0447A0 D9          0002*M1     exx
0447A1 F5          0003*M1     push af
0447A2 E5          0004*M1     push hl
0447A3 C5          0005*M1     push bc
0447A4 D5          0006*M1     push de
0447A5             0007*M1 
0447A5 08          0008*M1     ex af,af'
0447A6 D9          0009*M1     exx
0447A7 F5          0010*M1     push af
0447A8 E5          0011*M1     push hl
0447A9 C5          0012*M1     push bc
0447AA D5          0013*M1     push de
0447AB DD E5       0014*M1     push ix
0447AD FD E5       0015*M1     push iy
0447AF CD 7A 45 04 0523*       call dumpRegistersHex
0447B3             0524*       ; call waitKeypress
0447B3             0525*       POP_ALL
0447B3 FD E1       0001*M1     pop iy
0447B5 DD E1       0002*M1     pop ix
0447B7 D1          0003*M1     pop de
0447B8 C1          0004*M1     pop bc
0447B9 E1          0005*M1     pop hl
0447BA F1          0006*M1     pop af
0447BB 08          0007*M1     ex af,af'
0447BC D9          0008*M1     exx
0447BD             0009*M1 
0447BD D1          0010*M1     pop de
0447BE C1          0011*M1     pop bc
0447BF E1          0012*M1     pop hl
0447C0 F1          0013*M1     pop af
0447C1 08          0014*M1     ex af,af'
0447C2 D9          0015*M1     exx
0447C3 C9          0526*       ret
0447C4             0527*   DEBUG_WAITKEYPRESS:
0447C4             0528*       PUSH_ALL
0447C4 08          0001*M1     ex af,af'
0447C5 D9          0002*M1     exx
0447C6 F5          0003*M1     push af
0447C7 E5          0004*M1     push hl
0447C8 C5          0005*M1     push bc
0447C9 D5          0006*M1     push de
0447CA             0007*M1 
0447CA 08          0008*M1     ex af,af'
0447CB D9          0009*M1     exx
0447CC F5          0010*M1     push af
0447CD E5          0011*M1     push hl
0447CE C5          0012*M1     push bc
0447CF D5          0013*M1     push de
0447D0 DD E5       0014*M1     push ix
0447D2 FD E5       0015*M1     push iy
0447D4 CD E1 03 04 0529*       call waitKeypress
0447D8             0530*       POP_ALL
0447D8 FD E1       0001*M1     pop iy
0447DA DD E1       0002*M1     pop ix
0447DC D1          0003*M1     pop de
0447DD C1          0004*M1     pop bc
0447DE E1          0005*M1     pop hl
0447DF F1          0006*M1     pop af
0447E0 08          0007*M1     ex af,af'
0447E1 D9          0008*M1     exx
0447E2             0009*M1 
0447E2 D1          0010*M1     pop de
0447E3 C1          0011*M1     pop bc
0447E4 E1          0012*M1     pop hl
0447E5 F1          0013*M1     pop af
0447E6 08          0014*M1     ex af,af'
0447E7 D9          0015*M1     exx
0447E8 C9          0531*       RET
0447E9             0056    
0447E9 57 65 6C 63 0057    hello_world: asciz "Welcome to Pac-Man!"
       6F 6D 65 20 
       74 6F 20 50 
       61 63 2D 4D 
       61 6E 21 00 
0447FD 4C 6F 61 64 0058    loading_ui: asciz "Loading UI"
       69 6E 67 20 
       55 49 00    
044808 50 72 65 73 0059    loading_complete: asciz "Press any key to continue."
       73 20 61 6E 
       79 20 6B 65 
       79 20 74 6F 
       20 63 6F 6E 
       74 69 6E 75 
       65 2E 00    
044823             0060    
044823             0061    init:
044823             0062    ; clear all buffers
044823 CD 2A 15 04 0063        call vdu_clear_all_buffers
044827             0064    
044827             0065    ; set up the display
044827 3E 08       0066        ld a,8;+128 ; 136   320   240   64    60hz double-buffered
044829 CD 14 14 04 0067        call vdu_set_screen_mode
04482D AF          0068        xor a
04482E CD 25 14 04 0069        call vdu_set_scaling
044832             0070    
044832             0071    ; ; enable additional audio channels
044832             0072    ; 	call vdu_enable_channels
044832             0073    
044832             0074    ; set text background color
044832 3E 9A       0075        ld a,26+128 ; violet
044834 CD 7C 13 04 0076        call vdu_colour_text
044838             0077    
044838             0078    ; set text foreground color
044838 3E 2F       0079        ld a,47 ; aaaaff lavenderish
04483A CD 7C 13 04 0080        call vdu_colour_text
04483E             0081    
04483E             0082    ; set gfx bg color
04483E AF          0083        xor a ; plotting mode 0
04483F 3E 9A       0084        ld a,26+128 ; violet
044841 CD 8D 13 04 0085        call vdu_gcol
044845 CD 4B 13 04 0086        call vdu_cls
044849             0087    
044849             0088    ; set the cursor off
044849 CD 13 13 04 0089        call vdu_cursor_off
04484D             0090    
04484D             0091    ; VDU 28, left, bottom, right, top: Set text viewport **
04484D             0092    ; MIND THE LITTLE-ENDIANESS
04484D             0093    ; inputs: c=left,b=bottom,e=right,d=top
04484D 0E 00       0094        ld c,0 ; left
04484F 16 1D       0095        ld d,29 ; top
044851 1E 27       0096        ld e,39 ; right
044853 06 1D       0097        ld b,29; bottom
044855 CD A4 13 04 0098        call vdu_set_txt_viewport
044859             0099    
044859             0100    ; ; print loading ui message
044859             0101    ;     ld hl,loading_ui
044859             0102    ;     call printString
044859             0103    ;     call vdu_flip
044859             0104    
044859             0105    ; ; load UI images
044859             0106    ;     call load_ui_images
044859             0107    
044859             0108    ; load sprites
044859             0109        ; call img_load_init ; sets up the animated load screen
044859 CD 5D 10 04 0110        call load_sprite_images
04485D             0111    
04485D             0112    ; ; load sound effects ; TODO
04485D             0113    ; 	ld bc,SFX_num_buffers
04485D             0114    ; 	ld hl,SFX_buffer_id_lut
04485D             0115    ; 	ld (cur_buffer_id_lut),hl
04485D             0116    ; 	ld hl,SFX_load_routines_table
04485D             0117    ; 	ld (cur_load_jump_table),hl
04485D             0118    ; 	call sfx_load_main
04485D             0119    
04485D             0120    ; print loading complete message and wait for user keypress
04485D CD 4B 13 04 0121        call vdu_cls
044861 21 08 48 04 0122        ld hl,loading_complete
044865 CD 07 01 04 0123        call printString
044869 CD 50 13 04 0124        call vdu_flip
04486D CD E1 03 04 0125        call waitKeypress
044871             0126    
044871             0127    ; set up display for gameplay
044871             0128        ; ld a,8
044871 3E 14       0129        ld a,20
044873 CD 14 14 04 0130        call vdu_set_screen_mode
044877 AF          0131        xor a
044878 CD 25 14 04 0132        call vdu_set_scaling
04487C CD 13 13 04 0133        call vdu_cursor_off
044880             0134    ; ; load fonts
044880             0135    ; 	call fonts_load
044880             0136    ; ; select font
044880             0137    ;     ld hl,computer_pixel_7_8x16
044880             0138    ;     ld a,1 ; flags
044880             0139    ;     call vdu_font_select
044880             0140    ; ; plot bezel art
044880             0141    ;     ld hl,BUF_BEZEL_L
044880             0142    ;     call vdu_buff_select
044880             0143    ;     ld bc,0
044880             0144    ;     ld de,0
044880             0145    ;     call vdu_plot_bmp
044880             0146    ;     ld hl,BUF_BEZEL_R
044880             0147    ;     call vdu_buff_select
044880             0148    ;     ld bc,384
044880             0149    ;     ld de,0
044880             0150    ;     call vdu_plot_bmp
044880             0151    ; set gfx origin and viewport to playing field window
044880 01 80 00 00 0152        ld bc,origin_left
044884 11 00 00 00 0153        ld de,origin_top
044888 CD D0 13 04 0154        call vdu_set_gfx_origin
04488C 01 00 00 00 0155        ld bc,field_left
044890 11 00 00 00 0156        ld de,field_top
044894 DD 21 FF 00 0157        ld ix,field_right
       00          
044899 FD 21 7F 01 0158        ld iy,field_bottom
       00          
04489E CD EB 13 04 0159        call vdu_set_gfx_viewport
0448A2             0160    ; set background color
0448A2 3E 9A       0161        ld a,26+128 ; violet
0448A4 CD 8D 13 04 0162        call vdu_gcol
0448A8 CD 5E 13 04 0163        call vdu_clg
0448AC             0164    ; ; VDU 28, left, bottom, right, top: Set text viewport **
0448AC             0165    ;     ld c,0 ; left
0448AC             0166    ;     ld d,0 ; top
0448AC             0167    ;     ld e,62 ; right
0448AC             0168    ;     ld b,7; bottom
0448AC             0169    ;     call vdu_set_txt_viewport
0448AC             0170    
0448AC             0171    ; initialize the global timestamp
0448AC CD F9 11 04 0172        call timestamp_tick
0448B0             0173    
0448B0             0174    ; done with init
0448B0 C9          0175        ret
0448B1             0176    
0448B1             0177    main:
0448B1             0178    ; start a new game
0448B1 CD E8 42 04 0179        call game_initialize
0448B5             0180    
0448B5             0181    main_loop:
0448B5             0182    ; update the global timestamp
0448B5 CD F9 11 04 0183        call timestamp_tick
0448B9             0184    
0448B9             0185    ; do gamestate logic
0448B9 CD D4 42 04 0186        call do_game
0448BD             0187    
0448BD             0188    ; wait for the next vblank mitigate flicker and for loop timing
0448BD CD BF 13 04 0189        call vdu_vblank
0448C1             0190        ; call vdu_vblank ; DEBUG
0448C1             0191        ; call vdu_vblank ; DEBUG
0448C1             0192        ; call vdu_vblank ; DEBUG
0448C1             0193    
0448C1             0194    ; poll keyboard for escape keypress
0448C1 3E 08       0195        ld a, $08 ; code to send to MOS
0448C3 5B CF       0196        rst.lil $08 ; get IX pointer to System Variables
0448C5             0197    
0448C5 DD 7E 05    0198        ld a, (ix + $05) ; get ASCII code of key pressed
0448C8 FE 1B       0199        cp 27 ; check if 27 (ascii code for ESC)
0448CA CA D2 48 04 0200        jp z, main_end ; if pressed, jump to exit
0448CE             0201    
0448CE C3 B5 48 04 0202        jp main_loop
0448D2             0203    
0448D2             0204    main_end:
0448D2 CD 05 13 04 0205        call vdu_cursor_on
0448D6 C9          0206        ret
